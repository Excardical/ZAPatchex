[
  {
    "pluginId": 0,
    "title": "Directory Browsing",
    "defaultRisk": "Medium",
    "cweid": 548,
    "description": "Directory browsing vulnerabilities occur when web servers are configured to allow directory listings, enabling attackers to browse directory contents and discover sensitive files, configuration files, backup files, or source code that should not be publicly accessible.",
    "simplified_description": "Your website is allowing visitors to see a list of all files in your directories, like leaving your filing cabinet drawers open and letting anyone rummage through them. Attackers can exploit this to find sensitive files, backup copies, configuration files, or source code that helps them plan further attacks against your application.",
    "solution": "Disable directory browsing in web server configuration and ensure proper access controls are in place for all directories.",
    "simplified_solution": "Immediately disable directory browsing on your web server by adding 'Options -Indexes' to Apache configuration or 'autoindex off;' to Nginx configuration. Ensure every directory has an index file (index.html, index.php) or proper access controls. Review and secure sensitive directories, implement proper file permissions, and regularly audit your directory structure for exposed sensitive information.",
    "references": [
      {
        "name": "OWASP Directory Listing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/04-Review_Webserver_Metadata_for_Information_Leakage.html"
      },
      {
        "name": "CWE-548: Exposure of Directory Listing",
        "url": "https://cwe.mitre.org/data/definitions/548.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Web Server Configuration",
        "solution_description": "Disable directory browsing across all web servers and implement proper access controls for sensitive directories.",
        "affected_files": "Apache configuration files (httpd.conf, .htaccess), Nginx configuration files (nginx.conf), IIS configuration files (web.config), application server configurations",
        "code": "# APACHE CONFIGURATION\n# Disable directory browsing globally\n<Directory />\n    Options -Indexes\n    AllowOverride None\n    Require all denied\n</Directory>\n\n# .htaccess file\nOptions -Indexes\n\n# Prevent access to sensitive files\n<Files \"*.conf\">\n    Require all denied\n</Files>\n\n<Files \"*.log\">\n    Require all denied\n</Files>\n\n# NGINX CONFIGURATION\nserver {\n    # Disable directory browsing\n    autoindex off;\n    \n    # Protect sensitive directories\n    location /config {\n        deny all;\n        return 404;\n    }\n    \n    # Prevent access to sensitive files\n    location ~* \\.(conf|log|bak|backup|sql)$ {\n        deny all;\n        return 404;\n    }\n}\n\n# IIS CONFIGURATION (web.config)\n<configuration>\n    <system.webServer>\n        <directoryBrowse enabled=\"false\" />\n        \n        <security>\n            <requestFiltering>\n                <hiddenSegments>\n                    <add segment=\"config\" />\n                    <add segment=\"backup\" />\n                    <add segment=\"logs\" />\n                </hiddenSegments>\n            </requestFiltering>\n        </security>\n    </system.webServer>\n</configuration>"
      }
    ]
  },
  {
    "pluginId": 3,
    "title": "Session ID in URL Rewrite",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "Session ID in URL rewrite vulnerabilities occur when applications include session identifiers in URLs, making them visible in browser history, server logs, referrer headers, and bookmarks, allowing attackers to hijack user sessions through session fixation or session stealing attacks.",
    "simplified_description": "Your application is exposing session IDs in web addresses, like printing your membership card number on every receipt you hand out. Anyone who sees these URLs - in browser history, server logs, or shared links - can steal the user's session and impersonate them, accessing their accounts, personal data, and performing actions as if they were the legitimate user.",
    "solution": "Use cookies for session management instead of URL rewriting, implement secure session handling, and add additional authentication mechanisms for sensitive operations.",
    "simplified_solution": "Immediately switch from URL-based session management to secure cookie-based sessions. Enable HttpOnly, Secure, and SameSite attributes on session cookies. Implement session regeneration on login, set appropriate session timeouts, and add additional verification like CSRF tokens for sensitive actions. Ensure session IDs are never exposed in URLs or logs.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Session Management Implementation",
        "solution_description": "This solution demonstrates comprehensive secure session management using cookies instead of URL rewriting, including proper session configuration, secure cookie handling, session fixation prevention, and additional authentication mechanisms for web applications.",
        "affected_files": "Authentication controllers, session middleware, configuration files, login/logout handlers, security filters, frontend JavaScript",
        "code": "<?php\n// ============================================\n// SECURE SESSION MANAGEMENT CLASS\n// ============================================\n\nclass SecureSessionManager {\n    private $sessionTimeout = 1800; // 30 minutes\n    private $maxSessionLifetime = 7200; // 2 hours\n    private $secureCookieOptions = [\n        'lifetime' => 0,\n        'path' => '/',\n        'domain' => '',\n        'secure' => true,\n        'httponly' => true,\n        'samesite' => 'Strict'\n    ];\n    \n    public function __construct() {\n        // Configure secure session settings\n        $this->configureSecureSession();\n        \n        // Start session with security measures\n        $this->startSecureSession();\n        \n        // Validate current session\n        $this->validateSession();\n    }\n    \n    /**\n     * Configure secure PHP session settings\n     */\n    private function configureSecureSession() {\n        // Prevent session ID from appearing in URLs\n        ini_set('session.use_only_cookies', 1);\n        ini_set('session.use_cookies', 1);\n        ini_set('session.use_trans_sid', 0);\n        \n        // Secure session cookie settings\n        ini_set('session.cookie_httponly', 1);\n        ini_set('session.cookie_secure', 1);\n        ini_set('session.cookie_samesite', 'Strict');\n        \n        // Set session name to avoid default PHPSESSID\n        session_name('APP_SESSION_ID');\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 6,
    "title": "Path Traversal",
    "defaultRisk": "High",
    "cweid": "22",
    "description": "Path Traversal vulnerabilities allow attackers to read arbitrary files on the server's file system, potentially exposing sensitive configuration files, source code, or data.",
    "simplified_description": "Your application has a security weakness that allows attackers to access files on your server that they shouldn't be able to see. This is like leaving doors unlocked in a building - attackers can walk through corridors and peek into rooms they're not supposed to access. They could potentially read sensitive files like database credentials, user data, or system configuration files.",
    "solution": "Implement proper input validation and use secure file access methods that prevent directory traversal attacks.",
    "simplified_solution": "Add proper input validation to sanitize user input, restrict file access to specific directories only, use absolute file paths instead of relative ones, and implement proper access controls to ensure users can only access files they're authorized to see.",
    "references": [
      {
        "name": "OWASP Path Traversal",
        "url": "https://owasp.org/www-community/attacks/Path_Traversal"
      },
      {
        "name": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory",
        "url": "https://cwe.mitre.org/data/definitions/22.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure File Access Implementation",
        "solution_description": "This solution demonstrates how to prevent path traversal attacks by implementing proper input validation, using a whitelist approach for allowed files, and employing secure file access methods.",
        "affected_files": "File download controllers, file serving endpoints, template rendering functions",
        "code": "@RestController\n@RequestMapping(\"/api/files\")\npublic class FileController {\n    private static final String ALLOWED_BASE_DIR = \"/var/www/app/uploads\";\n    \n    @GetMapping(\"/download/{filename}\")\n    public ResponseEntity<Resource> downloadFile(@PathVariable String filename) {\n        try {\n            String sanitizedFilename = sanitizeFilename(filename);\n            Path filePath = Paths.get(ALLOWED_BASE_DIR, sanitizedFilename).normalize();\n            \n            if (!filePath.startsWith(ALLOWED_BASE_DIR)) {\n                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();\n            }\n            \n            File file = filePath.toFile();\n            if (!file.exists() || !file.canRead()) {\n                return ResponseEntity.notFound().build();\n            }\n            \n            Resource resource = new UrlResource(file.toURI());\n            return ResponseEntity.ok()\n                    .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                    .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + sanitizedFilename + \"\\\"\")\n                    .body(resource);\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n    }\n    \n    private String sanitizeFilename(String filename) {\n        return filename.replaceAll(\"[^a-zA-Z0-9._-]\", \"_\");\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 7,
    "title": "Remote File Inclusion",
    "defaultRisk": "Critical",
    "cweid": "98",
    "description": "Remote File Inclusion (RFI) vulnerabilities allow attackers to include remote files, potentially leading to remote code execution, data theft, or complete system compromise.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to load files from external websites into your application. This is like giving strangers the keys to your house and letting them bring in whatever they want - they could bring malicious code that takes over your entire application.",
    "solution": "Disable remote file inclusion in PHP configuration and implement strict input validation with whitelisting for all file inclusion operations.",
    "simplified_solution": "Turn off remote file inclusion features in your PHP configuration, validate all file inputs against an approved list of allowed files, use absolute paths instead of user-supplied paths.",
    "references": [
      {
        "name": "OWASP Remote File Inclusion",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/File_Inclusion_Cheat_Sheet.html"
      },
      {
        "name": "CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program",
        "url": "https://cwe.mitre.org/data/definitions/98.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure File Include Implementation",
        "solution_description": "This solution shows how to prevent Remote File Inclusion attacks by disabling remote includes in PHP configuration and implementing strict whitelist-based file inclusion.",
        "affected_files": "PHP configuration files, web server configuration, PHP files with include/require statements",
        "code": "// PHP CONFIGURATION - DISABLE REMOTE INCLUDES\nallow_url_fopen = Off\nallow_url_include = Off\n\n// SECURE FILE INCLUSION PATTERN\n<?php\nclass SecureFileIncluder {\n    private $allowedPages = [\n        'home' => '/var/www/app/pages/home.php',\n        'about' => '/var/www/app/pages/about.php',\n        'contact' => '/var/www/app/pages/contact.php'\n    ];\n    \n    public function includePage($pageName) {\n        if (empty($pageName) || !is_string($pageName)) {\n            throw new InvalidArgumentException('Invalid page name');\n        }\n        \n        if (!array_key_exists($pageName, $this->allowedPages)) {\n            throw new RuntimeException('Page not found');\n        }\n        \n        $filePath = $this->allowedPages[$pageName];\n        if (!file_exists($filePath) || !is_readable($filePath)) {\n            throw new RuntimeException('Page not available');\n        }\n        \n        include $filePath;\n    }\n}\n\n// GOOD: Secure inclusion with whitelist\ntry {\n    $page = filter_input(INPUT_GET, 'page', FILTER_SANITIZE_STRING);\n    $includer = new SecureFileIncluder();\n    $includer->includePage($page);\n} catch (Exception $e) {\n    include '/var/www/app/pages/404.php';\n}\n?>"
      }
    ]
  },
  {
    "pluginId": 10010,
    "title": "Cookie No HttpOnly Flag",
    "defaultRisk": "Medium",
    "cweid": 1004,
    "description": "Cookies are being set without the HttpOnly flag, making them accessible to client-side scripts. This creates a significant security vulnerability where malicious JavaScript can steal session cookies and other sensitive cookie data, leading to session hijacking and authentication bypass.",
    "simplified_description": "Your website is allowing JavaScript code to read cookies, which is like leaving your house keys on the kitchen table where anyone can grab them. Attackers can inject malicious scripts onto your pages and steal user session cookies, allowing them to impersonate legitimate users and access their accounts without passwords.",
    "solution": "Configure all cookies to include the HttpOnly flag to prevent client-side script access. This should be implemented at the application level for session cookies and any cookies containing sensitive information. Additionally, ensure proper cookie security configurations including Secure and SameSite attributes.",
    "simplified_solution": "Update your web application to mark all cookies as HttpOnly. This tells browsers that cookies should only be accessed by the server, not by JavaScript. Start with session cookies first, then apply to all cookies containing sensitive information. Test your application thoroughly to ensure no functionality breaks.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "OWASP HTTP Headers Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html"
      },
      {
        "name": "MDN HttpOnly Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#HttpOnly"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP Cookie Configuration",
        "solution_description": "This solution demonstrates secure cookie configuration in PHP applications. It includes session cookie hardening, custom cookie creation with HttpOnly flag, and comprehensive session security settings. The implementation addresses PHP versions from 5.2 to 8.x with proper fallback mechanisms.",
        "affected_files": "php.ini, session configuration files, login/authentication scripts, cookie management functions, framework configuration files (config.php, bootstrap.php)",
        "code": "<?php\n// PHP Cookie Security Configuration\n\n// ======================================\n// PHP.INI CONFIGURATION\n// ======================================\n\n/*\nAdd these lines to your php.ini file:\n\n; Enable HttpOnly for all cookies\nsession.cookie_httponly = 1\n\n; Enable secure cookies (HTTPS only)\nsession.cookie_secure = 1\n\n; Restrict cookie access to same site\nsession.cookie_samesite = Strict\n\n; Use strict mode for cookies\nsession.use_strict_mode = 1\n\n; Disable transparent session ID\nsession.use_trans_sid = 0\n\n; Enable session cookie parameters\nsession.use_cookies = 1\n\n; Set session cookie lifetime (seconds)\nsession.cookie_lifetime = 14400  ; 4 hours\n\n; Enable secure cookies for all cookies\n; (PHP 7.3+)\nsession.cookie_samesite = \"Strict\"\n*/\n\n// ======================================\n// RUNTIME CONFIGURATION (PHP CODE)\n// ======================================\n\n// Configure session parameters before session_start()\nini_set('session.cookie_httponly', 1);\nini_set('session.cookie_secure', 1);  // Only send over HTTPS\nini_set('session.use_only_cookies', 1);\nini_set('session.use_strict_mode', 1);\nini_set('session.cookie_samesite', 'Strict');\n\n// Start session\nsession_start();\n\n// ======================================\n// CUSTOM COOKIE CREATION WITH HTTPTONLY\n// ======================================\n\n// Secure cookie creation function\nfunction setSecureCookie($name, $value, $expire = 0, $path = '/', $domain = '', $secure = true) {\n    $options = [\n        'expires' => $expire,\n        'path' => $path,\n        'domain' => $domain,\n        'secure' => $secure,\n        'httponly' => true,\n        'samesite' => 'Strict'\n    ];\n    \n    // For PHP 7.3+ (supports array options)\n    if (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n        setcookie($name, $value, $options);\n    } else {\n        // Legacy PHP compatibility\n        $cookieString = sprintf(\n            '%s=%s; expires=%s; path=%s; domain=%s; %s %s HttpOnly',\n            $name,\n            urlencode($value),\n            gmdate('D, d-M-Y H:i:s T', $expire),\n            $path,\n            $domain,\n            $secure ? 'Secure;' : '',\n            'SameSite=Strict;'\n        );\n        header('Set-Cookie: ' . $cookieString, false);\n    }\n}\n\n// Example usage:\n// Set user preferences cookie\nsetSecureCookie('user_preferences', json_encode(['theme' => 'dark']), time() + (86400 * 30), '/');\n\n// Set authentication token\nsetSecureCookie('auth_token', $jwtToken, time() + 3600, '/', '.example.com');\n\n// ======================================\n// LARAVEL FRAMEWORK CONFIGURATION\n// ======================================\n\n// config/session.php\nreturn [\n    'driver' => env('SESSION_DRIVER', 'file'),\n    'lifetime' => env('SESSION_LIFETIME', 120),\n    'expire_on_close' => false,\n    'encrypt' => false,\n    'files' => storage_path('framework/sessions'),\n    'connection' => null,\n    'table' => 'sessions',\n    'store' => null,\n    'lottery' => [2, 100],\n    'cookie' => env('SESSION_COOKIE', 'laravel_session'),\n    'path' => '/',\n    'domain' => env('SESSION_DOMAIN', null),\n    'secure' => env('APP_ENV') === 'production',\n    'http_only' => true,\n    'same_site' => 'strict',\n];\n\n// ======================================\n// SYMFONY FRAMEWORK CONFIGURATION\n// ======================================\n\n// config/packages/framework.yaml\nframework:\n    session:\n        cookie_httponly: true\n        cookie_secure: auto\n        cookie_samesite: strict\n        handler_id: null\n        name: 'SESSID'\n        cookie_lifetime: 14400\n        gc_maxlifetime: 14400\n\n// ======================================\n// NODE.JS/EXPRESS CONFIGURATION\n// ======================================\n\nconst express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\n\n// Session middleware with secure cookies\napp.use(session({\n    name: 'sessionId',\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n        httpOnly: true,           // Prevent JavaScript access\n        secure: true,            // HTTPS only\n        sameSite: 'strict',      // CSRF protection\n        maxAge: 24 * 60 * 60 * 1000  // 24 hours\n    }\n}));\n\n// Custom cookie setting\napp.use((req, res, next) => {\n    // Set HttpOnly cookie\n    res.cookie('authToken', 'your-token-here', {\n        httpOnly: true,\n        secure: true,\n        sameSite: 'strict',\n        maxAge: 3600000  // 1 hour\n    });\n    \n    next();\n});\n\n// ======================================\n// ASP.NET CORE CONFIGURATION\n// ======================================\n\n// Startup.cs or Program.cs\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.Configure<CookiePolicyOptions>(options =>\n    {\n        options.HttpOnly = Microsoft.AspNetCore.Http.HttpOnlyPolicy.Always;\n        options.Secure = Microsoft.AspNetCore.Http.CookieSecurePolicy.Always;\n        options.MinimumSameSitePolicy = Microsoft.AspNetCore.Http.SameSiteMode.Strict;\n    });\n    \n    services.ConfigureApplicationCookie(options =>\n    {\n        options.Cookie.HttpOnly = true;\n        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n        options.Cookie.SameSite = SameSiteMode.Strict;\n        options.Cookie.Name = \"YourAppCookie\";\n        options.ExpireTimeSpan = TimeSpan.FromHours(4);\n    });\n    \n    services.AddSession(options =>\n    {\n        options.Cookie.HttpOnly = true;\n        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;\n        options.Cookie.SameSite = SameSiteMode.Strict;\n        options.IdleTimeout = TimeSpan.FromMinutes(30);\n    });\n}\n\n// ======================================\n// DJANGO FRAMEWORK CONFIGURATION\n// ======================================\n\n# settings.py\n\n# Session cookie security\nSESSION_COOKIE_SECURE = True          # HTTPS only\nSESSION_COOKIE_HTTPONLY = True        # Prevent JavaScript access\nSESSION_COOKIE_SAMESITE = 'Strict'    # CSRF protection\nSESSION_COOKIE_AGE = 14400            # 4 hours\n\n# CSRF cookie security\nCSRF_COOKIE_SECURE = True\nCSRF_COOKIE_HTTPONLY = True\nCSRF_COOKIE_SAMESITE = 'Strict'\n\n# ======================================\n// RUBY ON RAILS CONFIGURATION\n# ======================================\n\n# config/initializers/session_store.rb\nRails.application.config.session_store :cookie_store,\n  key: '_your_app_session',\n  secure: Rails.env.production?,\n  httponly: true,\n  same_site: :strict,\n  expire_after: 4.hours\n\n# config/application.rb\nconfig.force_ssl = true  # Enforces HTTPS\n\n# ======================================\n// TESTING AND VALIDATION\n# ======================================\n\n// PHP Cookie Validation Script\nfunction validateCookieSecurity($domain) {\n    $context = stream_context_create([\n        'http' => [\n            'method' => 'GET',\n            'header' => \"User-Agent: CookieValidator\\r\\n\"\n        ]\n    ]);\n    \n    $response = file_get_contents(\"https://$domain\", false, $context);\n    $headers = $http_response_header;\n    \n    echo \"=== Cookie Security Report for $domain ===\\n\\n\";\n    \n    foreach ($headers as $header) {\n        if (strpos(strtolower($header), 'set-cookie') === 0) {\n            echo \"Cookie Header: $header\\n\";\n            \n            // Check for HttpOnly\n            if (strpos($header, 'HttpOnly') !== false) {\n                echo \"✓ HttpOnly flag: PRESENT\\n\";\n            } else {\n                echo \"✗ HttpOnly flag: MISSING\\n\";\n            }\n            \n            // Check for Secure\n            if (strpos($header, 'Secure') !== false) {\n                echo \"✓ Secure flag: PRESENT\\n\";\n            } else {\n                echo \"✗ Secure flag: MISSING\\n\";\n            }\n            \n            // Check for SameSite\n            if (preg_match('/SameSite=([A-Za-z]+)/', $header, $matches)) {\n                echo \"✓ SameSite: {$matches[1]}\\n\";\n            } else {\n                echo \"✗ SameSite: MISSING\\n\";\n            }\n            \n            echo \"---\\n\";\n        }\n    }\n}\n\n// JavaScript Browser Testing\n// <script>\nfunction testHttpOnlyCookies() {\n    console.log('Testing HttpOnly cookies...');\n    \n    // Try to read document.cookie\n    const cookies = document.cookie;\n    \n    if (cookies) {\n        console.warn('⚠ WARNING: Cookies visible to JavaScript!');\n        console.log('Visible cookies:', cookies);\n        \n        const cookieArray = cookies.split(';');\n        cookieArray.forEach(cookie => {\n            const [name] = cookie.trim().split('=');\n            console.log(`- ${name} is accessible via JavaScript`);\n        });\n    } else {\n        console.log('✓ No cookies accessible to JavaScript (HttpOnly working)');\n    }\n}\n\n// Run the test\ntestHttpOnlyCookies();\n// </script>\n\n// ======================================\n// AUTOMATED SECURITY SCANNING\n// ======================================\n\n// OWASP ZAP Security Scan Configuration\n// Ensure ZAP is configured to check for:\n// - Cookie without HttpOnly Flag (10010)\n// - Cookie without Secure Flag (10011)\n// - Cookie without SameSite Attribute (10054)\n\n// Bash script for automated cookie security testing\n#!/bin/bash\n\ndomain=\"$1\"\necho \"Testing cookie security for $domain...\"\n\n# Get cookies from the domain\ncookies=$(curl -s -D - \"https://$domain\" | grep -i \"^Set-Cookie\")\n\nif [[ -z \"$cookies\" ]]; then\n    echo \"No cookies found.\"\n    exit 0\nfi\n\n# Analyze each cookie\necho \"$cookies\" | while IFS= read -r cookie; do\n    echo \"Analyzing: $cookie\"\n    \n    # Check HttpOnly\n    if [[ \"$cookie\" =~ [Hh]ttp[Oo]nly ]]; then\n        echo \"  ✓ HttpOnly: Yes\"\n    else\n        echo \"  ✗ HttpOnly: No (VULNERABILITY)\"\n    fi\n    \n    # Check Secure\n    if [[ \"$cookie\" =~ [Ss]ecure ]]; then\n        echo \"  ✓ Secure: Yes\"\n    else\n        echo \"  ✗ Secure: No (VULNERABILITY)\"\n    fi\n    \n    # Check SameSite\n    if [[ \"$cookie\" =~ [Ss]ame[Ss]ite=([A-Za-z]+) ]]; then\n        echo \"  ✓ SameSite: ${BASH_REMATCH[1]}\"\n    else\n        echo \"  ✗ SameSite: Not set (VULNERABILITY)\"\n    fi\n    \n    echo \"\"\ndone\n\n// ======================================\n// COOKIE SECURITY BEST PRACTICES\n# ======================================\n\n/*\nBEST PRACTICES FOR COOKIE SECURITY:\n\n1. ALWAYS set HttpOnly for cookies containing:\n   - Session IDs\n   - Authentication tokens\n   - CSRF tokens\n   - User preferences\n   - Any sensitive data\n\n2. Use Secure flag for production (HTTPS only)\n   - Never send sensitive cookies over HTTP\n   - Test thoroughly in development first\n\n3. Implement SameSite attribute:\n   - 'Strict' for maximum security\n   - 'Lax' for better UX with some security\n   - 'None' only when necessary (requires Secure)\n\n4. Set appropriate expiration times:\n   - Session cookies: expire when browser closes\n   - Remember me: longer but reasonable time\n   - Temporary data: short expiration\n\n5. Use appropriate cookie scope:\n   - Set path to specific directory if possible\n   - Limit to specific subdomains\n   - Avoid overly broad domain settings\n\n6. Regular monitoring:\n   - Audit cookies quarterly\n   - Use automated scanning tools\n   - Monitor for new cookie-related vulnerabilities\n\n7. Framework-specific considerations:\n   - Keep frameworks updated\n   - Review security changelogs\n   - Test after framework updates\n*/\n\n// ======================================\n// COOKIE SECURITY TESTING CHECKLIST\n# ======================================\n\n/*\nPOST-IMPLEMENTATION VERIFICATION CHECKLIST:\n\n□ Session cookies have HttpOnly flag\n□ Authentication cookies have HttpOnly flag\n□ CSRF tokens are HttpOnly (if applicable)\n□ All production cookies have Secure flag\n□ SameSite attribute is set appropriately\n□ Cookie paths are properly scoped\n□ Cookie domains are properly restricted\n□ Expiration times are reasonable\n□ No sensitive data in non-HttpOnly cookies\n□ JavaScript cannot access sensitive cookies\n□ Automated scanning shows no cookie vulnerabilities\n□ Manual testing confirms cookie security\n□ Cross-browser compatibility verified\n□ Mobile browsers tested\n□ Performance impact minimal\n□ User experience maintained\n□ Server logs show proper cookie handling\n□ Third-party integrations compatible\n□ API endpoints properly handle secure cookies\n□ AJAX requests work with secure cookies\n□ WebSocket connections compatible\n□ CDN/proxy configurations compatible\n□ Load balancer settings verified\n□ Container/kubernetes configurations updated\n□ Environment variables properly set\n□ Development/staging configurations appropriate\n□ Production deployment successful\n□ Rollback plan documented and tested\n□ Monitoring alerts configured\n□ Security team notified of changes\n□ Documentation updated\n□ Team training completed\n*/"
      }
    ]
  },
  {
    "pluginId": 10011,
    "title": "Cookie Without Secure Flag",
    "defaultRisk": "High",
    "cweid": 614,
    "description": "Cookies are being transmitted over unencrypted HTTP connections without the Secure flag, making them vulnerable to interception and theft through man-in-the-middle attacks. This allows attackers to capture sensitive cookies such as session tokens, authentication credentials, and user data on insecure networks.",
    "simplified_description": "Your website is sending cookies over unencrypted connections, like sending postcards through the mail where anyone can read them. Attackers on the same network (like public Wi-Fi) can easily intercept and steal these cookies, allowing them to hijack user sessions and access accounts without passwords.",
    "solution": "Configure all cookies to include the Secure flag to ensure they are only transmitted over HTTPS connections. This includes session cookies, authentication tokens, and any cookies containing sensitive information. Implement proper SSL/TLS termination and ensure all sensitive pages use HTTPS.",
    "simplified_solution": "Update your web application to mark all cookies as Secure, which tells browsers to only send them over encrypted HTTPS connections. This prevents cookie theft on unsecure networks. Start with session cookies first, then apply to all cookies containing sensitive data. Ensure your entire site properly supports HTTPS before implementing.",
    "references": [
      {
        "name": "OWASP Transport Layer Security Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html"
      },
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "NIST SP 800-52 Rev 1",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-52/rev-1/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Apache HTTP Server Configuration",
        "solution_description": "This solution provides comprehensive Apache configuration for secure cookie handling across multiple contexts including PHP, Java, and native Apache configurations. It includes SSL enforcement, secure session settings, and proper header configurations for various web technologies.",
        "affected_files": "/etc/apache2/sites-available/*.conf, /etc/httpd/conf.d/*.conf, .htaccess files, php.ini, application configuration files, web.xml for Java applications",
        "code": "# Apache HTTP Server - Secure Cookie Configuration\n\n# ======================================\n# SSL ENFORCEMENT (PREREQUISITE)\n# ======================================\n\n<VirtualHost *:80>\n    ServerName example.com\n    \n    # Redirect all HTTP traffic to HTTPS\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]\n    \n    # Alternative redirect method\n    # Redirect permanent / https://example.com/\n</VirtualHost>\n\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # SSL Configuration\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/example.com.crt\n    SSLCertificateKeyFile /etc/ssl/private/example.com.key\n    SSLCertificateChainFile /etc/ssl/certs/example.com-chain.crt\n    \n    # SSL Protocol Configuration\n    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1\n    SSLCipherSuite ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256\n    SSLHonorCipherOrder off\n    SSLSessionTickets off\n    \n    # HSTS Header\n    Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n    \n    # Your application configuration here\n</VirtualHost>\n\n# ======================================\n# PHP APPLICATION COOKIE SECURITY\n# ======================================\n\n# Method 1: php.ini Configuration\n# Add to your php.ini or create custom php.ini\n\n; Session cookie security settings\nsession.cookie_secure = 1              ; Only send cookies over HTTPS\nsession.cookie_httponly = 1            ; Prevent JavaScript access\nsession.cookie_samesite = \"Strict\"      ; CSRF protection\nsession.use_only_cookies = 1           ; Don't pass session ID in URL\nsession.use_strict_mode = 1             ; Prevent session fixation\n\n; General cookie settings\nsession.cookie_lifetime = 14400        ; 4 hours\nsession.gc_maxlifetime = 14400         ; 4 hours\nsession.name = \"SECURESESSID\"          ; Custom session name\n\n# Method 2: .htaccess Configuration\n# Add to your .htaccess file\n\n<IfModule mod_php7.c>\n    php_flag session.cookie_secure On\n    php_flag session.cookie_httponly On\n    php_value session.cookie_samesite \"Strict\"\n</IfModule>\n\n<IfModule mod_php8.c>\n    php_flag session.cookie_secure On\n    php_flag session.cookie_httponly On\n    php_value session.cookie_samesite \"Strict\"\n</IfModule>\n\n# ======================================\n# PHP RUNTIME CONFIGURATION\n# ======================================\n\n<?php\n// Application-level cookie security\n\n// Configure session before start\nini_set('session.cookie_secure', 1);\nini_set('session.cookie_httponly', 1);\nini_set('session.use_only_cookies', 1);\nini_set('session.use_strict_mode', 1);\n\n// Set SameSite cookie (PHP 7.3+)\nif (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n    ini_set('session.cookie_samesite', 'Strict');\n}\n\nsession_start();\n\n// Secure cookie creation function\nfunction setSecureCookie($name, $value, $expire = 0, $path = '/', $domain = '') {\n    $options = [\n        'expires' => $expire,\n        'path' => $path,\n        'domain' => $domain,\n        'secure' => true,        // HTTPS only\n        'httponly' => true,      // Prevent JavaScript access\n        'samesite' => 'Strict'   // CSRF protection\n    ];\n    \n    if (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n        setcookie($name, $value, $options);\n    } else {\n        // Legacy PHP compatibility\n        $headerString = sprintf(\n            '%s=%s; Expires=%s; Path=%s; Domain=%s; Secure; HttpOnly; SameSite=Strict',\n            $name,\n            urlencode($value),\n            gmdate('D, d-M-Y H:i:s T', $expire),\n            $path,\n            $domain\n        );\n        header('Set-Cookie: ' . $headerString, false);\n    }\n}\n\n// Example usage\nsetSecureCookie('auth_token', $jwtToken, time() + 3600);\nsetSecureCookie('user_preferences', json_encode($preferences), time() + (86400 * 30));\n\n// Login function with secure cookies\nfunction loginUser($userId, $remember = false) {\n    // Generate secure session\n    session_regenerate_id(true);  // Prevent session fixation\n    \n    $_SESSION['user_id'] = $userId;\n    $_SESSION['login_time'] = time();\n    $_SESSION['ip_address'] = $_SERVER['REMOTE_ADDR'];\n    \n    // Set remember me cookie if requested\n    if ($remember) {\n        $token = bin2hex(random_bytes(32));\n        setSecureCookie('remember_token', $token, time() + (86400 * 30)); // 30 days\n        \n        // Store token in database\n        storeRememberToken($userId, $token);\n    }\n}\n\n// ======================================\n# NODE.JS/EXPRESS COOKIE SECURITY\n# ======================================\n\nconst express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Force HTTPS in production\nif (process.env.NODE_ENV === 'production') {\n    app.use((req, res, next) => {\n        if (req.header('x-forwarded-proto') !== 'https') {\n            res.redirect(`https://${req.header('host')}${req.url}`);\n        } else {\n            next();\n        }\n    });\n}\n\n// Session middleware with secure cookies\napp.use(session({\n    name: 'secure.sid',\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n        secure: true,           // HTTPS only\n        httpOnly: true,         // Prevent JavaScript access\n        sameSite: 'strict',     // CSRF protection\n        maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n        path: '/'               // Cookie path\n    },\n    rolling: true,\n    store: new (require('connect-mongo')(session))({\n        url: process.env.MONGODB_URI,\n        mongoOptions: {\n            useNewUrlParser: true,\n            useUnifiedTopology: true\n        }\n    })\n}));\n\n// Additional security headers\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", \"data:\"],\n            connectSrc: [\"'self'\"],\n            fontSrc: [\"'self'\"],\n            objectSrc: [\"'none'\"],\n            mediaSrc: [\"'self'\"],\n            frameSrc: [\"'none'\"],\n        },\n    },\n    hsts: {\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true\n    }\n}));\n\n// Custom secure cookie setting\napp.post('/login', (req, res) => {\n    // Authentication logic here\n    const authToken = generateAuthToken();\n    \n    // Set secure cookie\n    res.cookie('auth_token', authToken, {\n        secure: true,           // HTTPS only\n        httpOnly: true,         // Prevent JavaScript access\n        sameSite: 'strict',     // CSRF protection\n        maxAge: 3600000,        // 1 hour\n        path: '/'\n    });\n    \n    res.json({ success: true });\n});\n\n// ======================================\n# ASP.NET CORE COOKIE SECURITY\n# ======================================\n\n// Program.cs (ASP.NET Core 6+)\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure cookie policy\nbuilder.Services.Configure<CookiePolicyOptions>(options =>\n{\n    options.MinimumSameSitePolicy = SameSiteMode.Strict;\n    options.Secure = CookieSecurePolicy.Always;  // HTTPS only\n    options.OnAppendCookie = cookieContext =>\n    {\n        cookieContext.CookieOptions.Secure = true;\n        cookieContext.CookieOptions.HttpOnly = true;\n        cookieContext.CookieOptions.SameSite = SameSiteMode.Strict;\n    };\n    options.OnDeleteCookie = cookieContext =>\n    {\n        cookieContext.CookieOptions.Secure = true;\n        cookieContext.CookieOptions.HttpOnly = true;\n        cookieContext.CookieOptions.SameSite = SameSiteMode.Strict;\n    };\n});\n\n// Configure application cookies\nbuilder.Services.ConfigureApplicationCookie(options =>\n{\n    options.Cookie.HttpOnly = true;           // Prevent JavaScript access\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;  // HTTPS only\n    options.Cookie.SameSite = SameSiteMode.Strict;           // CSRF protection\n    options.Cookie.Name = \"SecureAppCookie\";\n    options.ExpireTimeSpan = TimeSpan.FromHours(4);\n    options.SlidingExpiration = true;\n    options.LoginPath = \"/Account/Login\";\n    options.LogoutPath = \"/Account/Logout\";\n    options.AccessDeniedPath = \"/Account/AccessDenied\";\n});\n\n// Configure session\nbuilder.Services.AddSession(options =>\n{\n    options.Cookie.HttpOnly = true;           // Prevent JavaScript access\n    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;  // HTTPS only\n    options.Cookie.SameSite = SameSiteMode.Strict;           // CSRF protection\n    options.IdleTimeout = TimeSpan.FromMinutes(30);\n    options.Cookie.IsEssential = true;\n});\n\nvar app = builder.Build();\n\n// Force HTTPS\napp.UseHttpsRedirection();\napp.UseHsts();\n\n// Use cookie policy\napp.UseCookiePolicy();\n\n// Use session\napp.UseSession();\n\n// ======================================\n# DJANGO COOKIE SECURITY\n# ======================================\n\n# settings.py\n\n# SSL/HTTPS Settings\nSECURE_SSL_REDIRECT = True                    # Force HTTPS\nSECURE_HSTS_SECONDS = 31536000               # 1 year\nSECURE_HSTS_INCLUDE_SUBDOMAINS = True\nSECURE_HSTS_PRELOAD = True\n\n# Session Cookie Security\nSESSION_COOKIE_SECURE = True                 # HTTPS only\nSESSION_COOKIE_HTTPONLY = True               # Prevent JavaScript access\nSESSION_COOKIE_SAMESITE = 'Strict'           # CSRF protection\nSESSION_COOKIE_AGE = 14400                   # 4 hours\nSESSION_COOKIE_NAME = 'secure_session_id'    # Custom name\n\n# CSRF Cookie Security\nCSRF_COOKIE_SECURE = True                    # HTTPS only\nCSRF_COOKIE_HTTPONLY = True                  # Prevent JavaScript access\nCSRF_COOKIE_SAMESITE = 'Strict'              # CSRF protection\nCSRF_TRUSTED_ORIGINS = ['https://yourdomain.com']\n\n# General Security\nSECURE_CONTENT_TYPE_NOSNIFF = True\nSECURE_BROWSER_XSS_FILTER = True\nX_FRAME_OPTIONS = 'DENY'\n\n# ======================================\n# RUBY ON RAILS COOKIE SECURITY\n# ======================================\n\n# config/environments/production.rb\nRails.application.configure do\n  # Force all access over SSL\n  config.force_ssl = true\n  \n  # Use strictSameSite cookies\n  config.session_store :cookie_store,\n    key: '_secure_app_session',\n    secure: true,            # HTTPS only\n    httponly: true,          # Prevent JavaScript access\n    same_site: :strict,      # CSRF protection\n    expire_after: 4.hours\nend\n\n# config/initializers/session_store.rb\nRails.application.config.session_store :cookie_store,\n  key: Rails.application.secrets.secret_key_base,\n  secure: Rails.env.production?,\n  httponly: true,\n  same_site: :strict,\n  expire_after: 4.hours\n\n# ======================================\n# TESTING AND VALIDATION\n# ======================================\n\n# Bash script to test cookie security\n#!/bin/bash\n\ntest_cookie_security() {\n    local domain=\"$1\"\n    echo \"=== Testing Cookie Security for $domain ===\"\n    \n    # Test HTTPS connection\n    echo \"\\n1. Testing HTTPS connection...\"\n    https_response=$(curl -s -I \"https://$domain\" 2>/dev/null)\n    if [[ $? -eq 0 ]]; then\n        echo \"✓ HTTPS connection successful\"\n    else\n        echo \"✗ HTTPS connection failed\"\n        return 1\n    fi\n    \n    # Test HTTP to HTTPS redirect\n    echo \"\\n2. Testing HTTP to HTTPS redirect...\"\n    http_status=$(curl -s -o /dev/null -w \"%{http_code}\" \"http://$domain\")\n    if [[ \"$http_status\" == \"301\" ]] || [[ \"$http_status\" == \"302\" ]]; then\n        echo \"✓ HTTP to HTTPS redirect working (Status: $http_status)\"\n    else\n        echo \"✗ HTTP to HTTPS redirect not working (Status: $http_status)\"\n    fi\n    \n    # Test cookies over HTTPS\n    echo \"\\n3. Testing secure cookies over HTTPS...\"\n    cookies=$(curl -s -D - \"https://$domain\" 2>/dev/null | grep -i \"^Set-Cookie\")\n    \n    if [[ -z \"$cookies\" ]]; then\n        echo \"ℹ No cookies set by the server\"\n        return 0\n    fi\n    \n    echo \"$cookies\" | while IFS= read -r cookie; do\n        echo \"\\nAnalyzing cookie: $cookie\"\n        \n        # Check Secure flag\n        if [[ \"$cookie\" =~ [Ss]ecure ]]; then\n            echo \"  ✓ Secure flag: PRESENT\"\n        else\n            echo \"  ✗ Secure flag: MISSING (VULNERABILITY)\"\n        fi\n        \n        # Check HttpOnly flag\n        if [[ \"$cookie\" =~ [Hh]ttp[Oo]nly ]]; then\n            echo \"  ✓ HttpOnly flag: PRESENT\"\n        else\n            echo \"  ✗ HttpOnly flag: MISSING (VULNERABILITY)\"\n        fi\n        \n        # Check SameSite\n        if [[ \"$cookie\" =~ [Ss]ame[Ss]ite=([A-Za-z]+) ]]; then\n            echo \"  ✓ SameSite: ${BASH_REMATCH[1]}\"\n        else\n            echo \"  ✗ SameSite: MISSING (VULNERABILITY)\"\n        fi\n    done\n    \n    # Test that cookies aren't sent over HTTP\n    echo \"\\n4. Testing cookie leakage over HTTP...\"\n    # This is a simplified test - in practice, you'd need to set a cookie first\n    http_cookie_response=$(curl -s -H \"Cookie: test=value\" \"http://$domain\" 2>/dev/null)\n    if [[ -n \"$http_cookie_response\" ]]; then\n        echo \"⚠ HTTP connection responds (ensure cookies aren't sensitive)\"\n    else\n        echo \"✓ HTTP connection properly blocked or redirected\"\n    fi\n}\n\n# JavaScript Browser Testing\n/*\n<script>\nfunction testSecureCookies() {\n    console.log('Testing secure cookie behavior...');\n    \n    // Test if site is HTTPS\n    if (location.protocol !== 'https:') {\n        console.warn('⚠ WARNING: Site not loaded over HTTPS');\n        console.warn('Secure cookies will not be sent!');\n    } else {\n        console.log('✓ Site loaded over HTTPS');\n    }\n    \n    // Check existing cookies\n    const cookies = document.cookie;\n    if (cookies) {\n        console.log('Cookies visible to JavaScript:');\n        cookies.split(';').forEach(cookie => {\n            const [name] = cookie.trim().split('=');\n            console.log(`- ${name}`);\n        });\n        \n        if (cookies.includes('session') || cookies.includes('auth')) {\n            console.warn('⚠ WARNING: Authentication/session cookies visible to JavaScript!');\n            console.warn('These should be HttpOnly!');\n        }\n    } else {\n        console.log('✓ No cookies accessible to JavaScript (HttpOnly working)');\n    }\n    \n    // Test if you can set a non-secure cookie\n    document.cookie = 'test=insecure; path=/';\n    if (document.cookie.includes('test=insecure')) {\n        console.warn('⚠ WARNING: Able to set insecure cookie');\n        // Clean up\n        document.cookie = 'test=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';\n    } else {\n        console.log('✓ Secure cookie configuration working');\n    }\n}\n\n// Run test\ntestSecureCookies();\n</script>\n*/\n\n# ======================================\n# AUTOMATED MONITORING\n# ======================================\n\n# Python script for continuous monitoring\nimport requests\nimport re\nfrom urllib.parse import urlparse\n\ndef check_cookie_security(domain):\n    \"\"\"Check cookie security configuration for a domain\"\"\"\n    results = {\n        'domain': domain,\n        'https_available': False,\n        'cookies_found': 0,\n        'secure_cookies': 0,\n        'httponly_cookies': 0,\n        'samesite_cookies': 0,\n        'vulnerabilities': []\n    }\n    \n    try:\n        # Test HTTPS availability\n        response = requests.get(f'https://{domain}', timeout=10, verify=True)\n        results['https_available'] = True\n        \n        # Analyze cookies\n        for cookie in response.cookies:\n            results['cookies_found'] += 1\n            \n            if cookie.secure:\n                results['secure_cookies'] += 1\n            else:\n                results['vulnerabilities'].append(\n                    f'Cookie {cookie.name} missing Secure flag'\n                )\n            \n            # Note: httponly and samesite not visible in requests.cookies\n            # Would need to parse Set-Cookie headers directly\n    \n    except requests.exceptions.SSLError:\n        results['vulnerabilities'].append('HTTPS/SSL configuration error')\n    except requests.exceptions.RequestException as e:\n        results['vulnerabilities'].append(f'Connection error: {str(e)}')\n    \n    return results\n\n# Usage\nif __name__ == '__main__':\n    domains = ['example.com', 'test.example.com']\n    for domain in domains:\n        result = check_cookie_security(domain)\n        print(f\"\\n=== Security Report for {result['domain']} ===\")\n        print(f\"HTTPS Available: {result['https_available']}\")\n        print(f\"Cookies Found: {result['cookies_found']}\")\n        print(f\"Secure Cookies: {result['secure_cookies']}\")\n        if result['vulnerabilities']:\n            print(\"Vulnerabilities:\")\n            for vuln in result['vulnerabilities']:\n                print(f\"  - {vuln}\")"
      }
    ]
  },
  {
    "pluginId": 10020,
    "title": "Anti-clickjacking Header",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "The application is missing anti-clickjacking headers, making it vulnerable to clickjacking attacks where malicious websites can embed your site in invisible iframes and trick users into clicking on hidden elements.",
    "simplified_description": "Your website is vulnerable to 'clickjacking' attacks where attackers can place your site in an invisible frame and trick users into clicking on buttons or links they can't see. This is like someone putting a clear sheet over a painting and tricking you into pressing buttons underneath without knowing what you're actually clicking.",
    "solution": "Implement X-Frame-Options and Content Security Policy frame-ancestors headers to prevent your website from being embedded in iframes on unauthorized domains.",
    "simplified_solution": "Add security headers that tell browsers not to display your website in iframes on other sites. Use X-Frame-Options: DENY or SAMEORIGIN, and implement CSP frame-ancestors directive for modern browsers.",
    "references": [
      {
        "name": "OWASP Clickjacking Defense Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html"
      },
      {
        "name": "CWE-693: Protection Mechanism Failure",
        "url": "https://cwe.mitre.org/data/definitions/693.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Anti-Clickjacking Header Implementation",
        "solution_description": "This solution demonstrates how to implement comprehensive clickjacking protection using X-Frame-Options headers, Content Security Policy frame-ancestors directives, and JavaScript frame-busting techniques across various web frameworks and server configurations.",
        "affected_files": "Web server configuration files (nginx.conf, httpd.conf), security middleware, express.js applications, Spring Boot configurations, cloud platform settings",
        "code": "# ========================================\n# NGINX CONFIGURATION\n# ========================================\n\n# Add anti-clickjacking headers to all responses\nadd_header X-Frame-Options \"SAMEORIGIN\" always;\nadd_header Content-Security-Policy \"frame-ancestors 'self'\" always;\nadd_header X-Content-Type-Options \"nosniff\" always;\n\n# For specific locations that should never be framed\nlocation /admin {\n    add_header X-Frame-Options \"DENY\" always;\n    add_header Content-Security-Policy \"frame-ancestors 'none'\" always;\n}\n\n# For applications that need to be framed by trusted domains\nlocation /embedded {\n    add_header X-Frame-Options \"ALLOW-FROM https://trusted-partner.com\" always;\n    add_header Content-Security-Policy \"frame-ancestors https://trusted-partner.com\" always;\n}\n\n# ========================================\n# APACHE HTTPD CONFIGURATION\n# ========================================\n\n# Enable headers module\nLoadModule headers_module modules/mod_headers.so\n\n# Set anti-clickjacking headers globally\nHeader always set X-Frame-Options \"SAMEORIGIN\"\nHeader always set Content-Security-Policy \"frame-ancestors 'self'\"\nHeader always set X-Content-Type-Options \"nosniff\"\n\n# For admin section - deny framing completely\n<Location \"/admin\">\n    Header always set X-Frame-Options \"DENY\"\n    Header always set Content-Security-Policy \"frame-ancestors 'none'\"\n</Location>\n\n# ========================================\n# EXPRESS.JS MIDDLEWARE\n# ========================================\n\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Basic clickjacking protection\napp.use(helmet.frameguard({ \n    action: 'sameorigin' // 'deny', 'sameorigin', or 'allow-from'\n}));\n\n// Advanced CSP-based protection\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            ...helmet.contentSecurityPolicy.getDefaultDirectives(),\n            \"frame-ancestors\": [\"'self'\"] // Restrict to same origin only\n        }\n    }\n}));\n\n// Custom middleware for specific routes\nconst clickjackingProtection = (options = {}) => {\n    return (req, res, next) => {\n        const { \n            mode = 'sameorigin', // 'deny', 'sameorigin', 'allow-from'\n            allowedOrigins = [] \n        } = options;\n        \n        switch (mode) {\n            case 'deny':\n                res.setHeader('X-Frame-Options', 'DENY');\n                res.setHeader('Content-Security-Policy', \"frame-ancestors 'none'\");\n                break;\n                \n            case 'sameorigin':\n                res.setHeader('X-Frame-Options', 'SAMEORIGIN');\n                res.setHeader('Content-Security-Policy', \"frame-ancestors 'self'\");\n                break;\n                \n            case 'allow-from':\n                if (allowedOrigins.length > 0) {\n                    const origins = allowedOrigins.join(' ');\n                    res.setHeader('X-Frame-Options', `ALLOW-FROM ${allowedOrigins[0]}`);\n                    res.setHeader('Content-Security-Policy', `frame-ancestors ${origins}`);\n                }\n                break;\n        }\n        \n        next();\n    };\n};\n\n// Apply different protection levels to different routes\napp.use('/admin', clickjackingProtection({ mode: 'deny' }));\napp.use('/public', clickjackingProtection({ mode: 'sameorigin' }));\napp.use('/embedded', clickjackingProtection({ \n    mode: 'allow-from', \n    allowedOrigins: ['https://trusted-partner.com', 'https://api-partner.com'] \n}));\n\n// ========================================\n# SPRING BOOT SECURITY CONFIGURATION (Java)\n# ========================================\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            // Basic frame protection\n            .headers().frameOptions().sameOrigin()\n            .and()\n            \n            // Advanced CSP-based frame protection\n            .headers().contentSecurityPolicy(\"frame-ancestors 'self'\")\n            .and()\n            \n            // Custom headers for different endpoints\n            .requestMatchers(\"/admin/**\").authorizeRequests()\n                .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n                .and()\n                .headers().frameOptions().deny()\n                .contentSecurityPolicy(\"frame-ancestors 'none'\")\n            .and()\n            \n            // Embedded endpoints for trusted partners\n            .requestMatchers(\"/embedded/**\").authorizeRequests()\n                .antMatchers(\"/embedded/**\").permitAll()\n                .and()\n                .headers().frameOptions().allowFrom(\"https://trusted-partner.com\")\n                .contentSecurityPolicy(\"frame-ancestors https://trusted-partner.com\");\n    }\n}\n\n// Custom response filter for advanced protection\n@Component\npublic class ClickjackingProtectionFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                  HttpServletResponse response, \n                                  FilterChain filterChain) throws ServletException, IOException {\n        \n        String requestURI = request.getRequestURI();\n        \n        if (requestURI.startsWith(\"/admin\")) {\n            // Admin pages - no framing allowed\n            response.setHeader(\"X-Frame-Options\", \"DENY\");\n            response.setHeader(\"Content-Security-Policy\", \"frame-ancestors 'none'\");\n            \n        } else if (requestURI.startsWith(\"/embedded\")) {\n            // Embedded content - only trusted domains\n            response.setHeader(\"X-Frame-Options\", \"ALLOW-FROM https://trusted-partner.com\");\n            response.setHeader(\"Content-Security-Policy\", \"frame-ancestors https://trusted-partner.com\");\n            \n        } else {\n            // Default - same origin only\n            response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n            response.setHeader(\"Content-Security-Policy\", \"frame-ancestors 'self'\");\n        }\n        \n        // Additional security headers\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        response.setHeader(\"Referrer-Policy\", \"strict-origin-when-cross-origin\");\n        \n        filterChain.doFilter(request, response);\n    }\n}\n\n// ========================================\n# CLOUD PLATFORM CONFIGURATIONS\n# ========================================\n\n# AWS CloudFront Distribution Configuration\n{\n  \"DistributionConfig\": {\n    \"DefaultCacheBehavior\": {\n      \"ViewerProtocolPolicy\": \"redirect-to-https\",\n      \"TrustedSigners\": {\n        \"Enabled\": false,\n        \"Quantity\": 0\n      },\n      \"ForwardedValues\": {\n        \"Headers\": {\n          \"Quantity\": 1,\n          \"Items\": [\"Origin\"]\n        }\n      },\n      \"ResponseHeadersPolicyId\": \"your-response-headers-policy-id\"\n    }\n  }\n}\n\n# Response Headers Policy for CloudFront\n{\n  \"ResponseHeadersPolicyConfig\": {\n    \"Name\": \"ClickjackingProtectionPolicy\",\n    \"Comment\": \"Policy to prevent clickjacking attacks\",\n    \"SecurityHeadersConfig\": {\n      \"FrameOptions\": {\n        \"Override\": true,\n        \"FrameOption\": \"SAMEORIGIN\"\n      },\n      \"ContentSecurityPolicy\": {\n        \"Override\": true,\n        \"ContentSecurityPolicy\": \"frame-ancestors 'self'; default-src 'self'\"\n      },\n      \"ContentTypeOptions\": {\n        \"Override\": true\n      },\n      \"ReferrerPolicy\": {\n        \"Override\": true,\n        \"ReferrerPolicy\": \"strict-origin-when-cross-origin\"\n      }\n    }\n  }\n}\n\n# ========================================\n# JAVASCRIPT FRAME-BUSTING (Fallback)\n# ========================================\n\n// Modern frame-busting script\n(function() {\n    'use strict';\n    \n    // Check if page is framed\n    if (window.top !== window.self) {\n        // Method 1: Try to break out of frame\n        try {\n            window.top.location = window.self.location;\n        } catch (e) {\n            // Method 2: If blocked, hide page content\n            document.body.innerHTML = '<div style=\"padding:20px;color:red;font-size:18px;\">This page cannot be displayed in a frame due to security restrictions.</div>';\n            \n            // Method 3: Log security event\n            console.warn('Frame-busting attempt detected:', {\n                referrer: document.referrer,\n                userAgent: navigator.userAgent,\n                timestamp: new Date().toISOString()\n            });\n            \n            // Method 4: Send security event to server\n            if (typeof fetch === 'function') {\n                fetch('/api/security/frame-bust-detected', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-CSRF-Token': document.querySelector('meta[name=\"csrf-token\"]')?.content\n                    },\n                    body: JSON.stringify({\n                        referrer: document.referrer,\n                        userAgent: navigator.userAgent,\n                        timestamp: Date.now()\n                    })\n                }).catch(() => {}); // Ignore errors\n            }\n        }\n    }\n})();\n\n// Enhanced frame-busting with additional protections\nclass FrameBuster {\n    constructor() {\n        this.checkInterval = 1000; // Check every second\n        this.maxAttempts = 10;\n        this.attempts = 0;\n        \n        this.init();\n    }\n    \n    init() {\n        // Immediate check\n        this.checkAndBust();\n        \n        // Periodic checks\n        this.intervalId = setInterval(() => {\n            this.checkAndBust();\n        }, this.checkInterval);\n        \n        // Listen for visibility changes\n        document.addEventListener('visibilitychange', () => {\n            if (!document.hidden) {\n                this.checkAndBust();\n            }\n        });\n    }\n    \n    checkAndBust() {\n        try {\n            if (window.top !== window.self) {\n                this.bust();\n            } else {\n                this.attempts = 0; // Reset counter when not framed\n            }\n        } catch (e) {\n            this.bust();\n        }\n    }\n    \n    bust() {\n        if (this.attempts >= this.maxAttempts) {\n            this.protectPage();\n            return;\n        }\n        \n        try {\n            window.top.location = window.self.location;\n            this.attempts++;\n        } catch (e) {\n            this.protectPage();\n        }\n    }\n    \n    protectPage() {\n        // Hide sensitive content\n        document.body.style.display = 'none';\n        \n        // Show warning message\n        const warning = document.createElement('div');\n        warning.innerHTML = `\n            <div style=\"\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: white;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: 999999;\n                font-family: Arial, sans-serif;\n                text-align: center;\n            \">\n                <div>\n                    <h2 style=\"color: #d32f2f;\">Security Warning</h2>\n                    <p>This page cannot be displayed in a frame for security reasons.</p>\n                    <p>Please open it directly in a new tab.</p>\n                    <button onclick=\"window.open(window.location.href, '_blank')\">\n                        Open in New Tab\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        document.documentElement.appendChild(warning);\n        \n        // Log the incident\n        this.logFrameBustAttempt();\n        \n        // Clear interval\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    \n    logFrameBustAttempt() {\n        try {\n            const logData = {\n                timestamp: Date.now(),\n                referrer: document.referrer,\n                userAgent: navigator.userAgent,\n                url: window.location.href,\n                attempts: this.attempts\n            };\n            \n            // Send to server\n            fetch('/api/security/log-frame-bust', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(logData)\n            }).catch(() => {});\n            \n        } catch (error) {\n            console.error('Failed to log frame bust attempt:', error);\n        }\n    }\n}\n\n// Initialize frame buster\nnew FrameBuster();\n\n// ========================================\n# TESTING AND VALIDATION\n# ========================================\n\n/*\nTESTING PROCEDURES:\n\n1. Basic Testing:\n   - Create test HTML page with iframe pointing to your application\n   - Verify page loads in same-origin iframe\n   - Verify page doesn't load in cross-origin iframe\n   - Test with X-Frame-Options header inspection\n\n2. Testing HTML:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Clickjacking Test</title>\n</head>\n<body>\n    <h2>Clickjacking Test</h2>\n    \n    <h3>Same Origin Test (Should Work)</h3>\n    <iframe src=\"/dashboard\" width=\"800\" height=\"600\"></iframe>\n    \n    <h3>Cross Origin Test (Should Not Work)</h3>\n    <iframe src=\"https://yourdomain.com/dashboard\" width=\"800\" height=\"600\"></iframe>\n    \n    <h3>Hidden Frame Test</h3>\n    <iframe src=\"https://yourdomain.com/transfer-money\" \n            width=\"0\" height=\"0\" style=\"opacity:0.1;\"></iframe>\n</body>\n</html>\n```\n\n3. Browser DevTools Testing:\n```javascript\n// Check if page is framed\nconsole.log('Is framed:', window.top !== window.self);\n\n// Check frame ancestors policy\nconst cspMeta = document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]');\nconsole.log('CSP:', cspMeta?.content);\n\n// Check response headers\nfetch(window.location.href).then(response => {\n    console.log('X-Frame-Options:', response.headers.get('X-Frame-Options'));\n    console.log('CSP:', response.headers.get('Content-Security-Policy'));\n});\n```\n\n4. Security Testing:\n   - Test with iframe buster prevention techniques\n   - Verify fallback JavaScript protections work\n   - Test with various CSP frame-ancestors configurations\n   - Ensure proper logging of framing attempts\n\n5. Browser Compatibility:\n   - Test in Chrome, Firefox, Safari, Edge\n   - Verify IE11 compatibility (if needed)\n   - Test mobile browser behavior\n   - Check with different iframe attributes\n\n6. Automated Testing:\n```javascript\ndescribe('Clickjacking Protection', () => {\n    test('should set correct security headers', async () => {\n        const response = await fetch('/protected-page');\n        expect(response.headers.get('X-Frame-Options')).toBe('SAMEORIGIN');\n        expect(response.headers.get('Content-Security-Policy')).toContain(\"frame-ancestors 'self'\");\n    });\n    \n    test('should deny framing for admin pages', async () => {\n        const response = await fetch('/admin/dashboard');\n        expect(response.headers.get('X-Frame-Options')).toBe('DENY');\n        expect(response.headers.get('Content-Security-Policy')).toContain(\"frame-ancestors 'none'\");\n    });\n});\n```\n\nMONITORING:\n- Log framing attempts for security analysis\n- Monitor for unusual iframe embedding patterns\n- Alert on multiple frame-busting attempts\n- Track successful and blocked framing attempts\n- Maintain statistics on framing-related security events\n*/"
      }
    ]
  },
  {
    "pluginId": 10021,
    "title": "X-Content-Type-Options Header Missing",
    "defaultRisk": "Low",
    "cweid": "16",
    "description": "The application is missing the X-Content-Type-Options header, which allows browsers to perform MIME-type sniffing. This can lead to security vulnerabilities where files are interpreted differently than intended, potentially allowing XSS attacks through file uploads or content manipulation.",
    "simplified_description": "Your website is missing a security header that tells browsers not to guess the type of content they're receiving. Without this protection, browsers might incorrectly interpret uploaded files, allowing attackers to upload malicious files that get executed as scripts instead of being treated as harmless data.",
    "solution": "Add the X-Content-Type-Options: nosniff header to all HTTP responses to prevent MIME-type sniffing attacks.",
    "simplified_solution": "Add the 'X-Content-Type-Options: nosniff' header to your web server configuration or application middleware. This tells browsers to strictly follow the declared content type and not try to guess or sniff the file type.",
    "references": [
      {
        "name": "OWASP Secure Headers",
        "url": "https://owasp.org/www-project-secure-headers/"
      },
      {
        "name": "CWE-16: Configuration",
        "url": "https://cwe.mitre.org/data/definitions/16.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "X-Content-Type-Options Header Implementation",
        "solution_description": "This solution demonstrates how to implement the X-Content-Type-Options: nosniff header across various web servers, application frameworks, and cloud platforms to prevent MIME-type sniffing attacks.",
        "affected_files": "Web server configuration (nginx.conf, httpd.conf), application middleware, cloud platform settings, response filters",
        "code": "# ========================================\n# NGINX CONFIGURATION\n# ========================================\n\n# Add X-Content-Type-Options header globally\nadd_header X-Content-Type-Options \"nosniff\" always;\n\n# Combine with other security headers\nadd_header X-Frame-Options \"SAMEORIGIN\" always;\nadd_header X-XSS-Protection \"1; mode=block\" always;\nadd_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\nadd_header Content-Security-Policy \"default-src 'self'\" always;\n\n# ========================================\n# APACHE HTTPD CONFIGURATION\n# ========================================\n\n# Enable headers module if not already enabled\nLoadModule headers_module modules/mod_headers.so\n\n# Set X-Content-Type-Options header globally\nHeader always set X-Content-Type-Options \"nosniff\"\n\n# ========================================\n# EXPRESS.JS MIDDLEWARE\n# ========================================\n\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Using Helmet for comprehensive security headers\napp.use(helmet());\n\n// Or specifically for X-Content-Type-Options\napp.use(helmet.noSniff());\n\n// Custom middleware implementation\nconst noSniffMiddleware = (req, res, next) => {\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    next();\n};\n\napp.use(noSniffMiddleware);\n\n// ========================================\n# SPRING BOOT CONFIGURATION (Java)\n# ========================================\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            // Add security headers\n            .headers()\n                .contentTypeOptions().and()\n                .frameOptions().sameOrigin().and()\n                .httpStrictTransportSecurity()\n                .maxAgeInSeconds(31536000)\n                .includeSubDomains(true).and()\n                .and()\n            // ... other security configuration\n    }\n}\n\n// Custom response filter\n@Component\npublic class SecurityHeadersFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                  HttpServletResponse response, \n                                  FilterChain filterChain) throws ServletException, IOException {\n        \n        // Add X-Content-Type-Options header\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        \n        // Add other security headers\n        response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"Referrer-Policy\", \"strict-origin-when-cross-origin\");\n        \n        filterChain.doFilter(request, response);\n    }\n}\n\n// ========================================\n# DJANGO CONFIGURATION (Python)\n# ========================================\n\n# settings.py\nSECURE_BROWSER_XSS_FILTER = True\nSECURE_CONTENT_TYPE_NOSNIFF = True\n\n# Custom middleware\nclass SecurityHeadersMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        response = self.get_response(request)\n        response['X-Content-Type-Options'] = 'nosniff'\n        response['X-Frame-Options'] = 'SAMEORIGIN'\n        response['X-XSS-Protection'] = '1; mode=block'\n        return response\n\n# MIDDLEWARE = [\n#     'django.middleware.security.SecurityMiddleware',\n#     'path.to.SecurityHeadersMiddleware',\n#     # ... other middleware\n# ]\n\n# ========================================\n# FLASK CONFIGURATION (Python)\n# ========================================\n\nfrom flask import Flask\nfrom flask_talisman import Talisman\n\napp = Flask(__name__)\n\n# Using Flask-Talisman for security headers\nTalisman(app, force_https=True)\n\n# Or custom implementation\n@app.after_request\ndef add_security_headers(response):\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    response.headers['X-XSS-Protection'] = '1; mode=block'\n    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'\n    return response\n\n# ========================================\n# RUBY ON RAILS CONFIGURATION\n# ========================================\n\n# config/application.rb\nconfig.action_dispatch.default_headers = {\n  'X-Frame-Options' => 'SAMEORIGIN',\n  'X-Content-Type-Options' => 'nosniff',\n  'X-XSS-Protection' => '1; mode=block'\n}\n\n# Or using secure_headers gem\n# Gemfile\ngem 'secure_headers'\n\n# config/initializers/secure_headers.rb\nSecureHeaders::Configuration.default do |config|\n  config.x_content_type_options = \"nosniff\"\n  config.x_frame_options = \"SAMEORIGIN\"\n  config.x_xss_protection = \"1; mode=block\"\nend\n\n# ========================================\n# CLOUD PLATFORM CONFIGURATIONS\n# ========================================\n\n# AWS S3 - CORS configuration with security headers\n{\n    \"Version\": \"2012-10-17\",\n    \"Id\": \"http://acs.amazonaws.com/groups/global/AllUsers\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowPublicRead\",\n            \"Effect\": \"Allow\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::your-bucket/*\"\n        }\n    ]\n}\n\n# AWS CloudFront - Response Headers Policy\n{\n  \"ResponseHeadersPolicyConfig\": {\n    \"Name\": \"SecurityHeadersPolicy\",\n    \"Comment\": \"Comprehensive security headers\",\n    \"SecurityHeadersConfig\": {\n      \"ContentTypeOptions\": {\n        \"Override\": true\n      },\n      \"FrameOptions\": {\n        \"Override\": true,\n        \"FrameOption\": \"SAMEORIGIN\"\n      },\n      \"XSSProtection\": {\n        \"Override\": true,\n        \"Mode\": \"block\",\n        \"Protection\": true,\n        \"ReportUri\": \"https://your-csp-report-endpoint.com\"\n      }\n    }\n  }\n}\n\n# Firebase Hosting - firebase.json\n{\n  \"hosting\": {\n    \"headers\": [\n      {\n        \"source\": \"**\",\n        \"headers\": [\n          {\n            \"key\": \"X-Content-Type-Options\",\n            \"value\": \"nosniff\"\n          },\n          {\n            \"key\": \"X-Frame-Options\",\n            \"value\": \"SAMEORIGIN\"\n          },\n          {\n            \"key\": \"X-XSS-Protection\",\n            \"value\": \"1; mode=block\"\n          }\n        ]\n      }\n    ]\n  }\n}\n\n# ========================================\n# SECURE FILE UPLOAD HANDLING\n# ========================================\n\n// Express.js with Multer - Secure file upload\nconst multer = require('multer');\nconst path = require('path');\n\nconst storage = multer.diskStorage({\n    destination: (req, file, cb) => {\n        cb(null, 'uploads/');\n    },\n    filename: (req, file, cb) => {\n        // Generate safe filename\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n        const safeName = uniqueSuffix + path.extname(file.originalname);\n        cb(null, safeName);\n    }\n});\n\nconst fileFilter = (req, file, cb) => {\n    // Define allowed file types\n    const allowedTypes = [\n        'image/jpeg',\n        'image/png', \n        'image/gif',\n        'application/pdf',\n        'text/plain'\n    ];\n    \n    if (allowedTypes.includes(file.mimetype)) {\n        cb(null, true);\n    } else {\n        cb(new Error('Invalid file type'), false);\n    }\n};\n\nconst upload = multer({ \n    storage, \n    fileFilter,\n    limits: {\n        fileSize: 5 * 1024 * 1024 // 5MB limit\n    }\n});\n\n// Serve uploaded files with correct MIME types and security headers\napp.use('/uploads', express.static('uploads', {\n    setHeaders: (res, path, stat) => {\n        res.setHeader('X-Content-Type-Options', 'nosniff');\n        \n        // Set correct MIME type based on file extension\n        const ext = path.split('.').pop();\n        const mimeTypes = {\n            'jpg': 'image/jpeg',\n            'jpeg': 'image/jpeg',\n            'png': 'image/png',\n            'gif': 'image/gif',\n            'pdf': 'application/pdf',\n            'txt': 'text/plain'\n        };\n        \n        if (mimeTypes[ext]) {\n            res.setHeader('Content-Type', mimeTypes[ext]);\n        }\n    }\n}));\n\n// ========================================\n# TESTING AND VALIDATION\n# ========================================\n\n/*\nTESTING PROCEDURES:\n\n1. Header Validation:\n```bash\n# Test with curl\ncurl -I https://yourdomain.com\n# Should show: X-Content-Type-Options: nosniff\n\n# Test with browser DevTools\n# Network tab -> Check response headers\n```\n\n2. MIME-Type Testing:\n- Upload files with different extensions\n- Verify correct MIME types are served\n- Test with renamed file extensions\n- Ensure dangerous files aren't executed\n\n3. File Upload Security:\n```javascript\n// Test file upload with renamed malicious file\nconst formData = new FormData();\nconst maliciousFile = new File(['<script>alert(1)</script>'], 'image.jpg', {\n    type: 'image/jpeg'\n});\nformData.append('file', maliciousFile);\n\nfetch('/upload', {\n    method: 'POST',\n    body: formData\n}).then(response => {\n    console.log('Upload response:', response.status);\n});\n```\n\n4. Cross-browser Testing:\n- Test in Chrome, Firefox, Safari, Edge\n- Verify IE11 compatibility if needed\n- Test mobile browser behavior\n- Check with different content types\n\n5. Automated Testing:\n```javascript\ndescribe('Security Headers', () => {\n    test('should include X-Content-Type-Options: nosniff', async () => {\n        const response = await fetch('/');\n        expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');\n    });\n    \n    test('should serve files with correct MIME type', async () => {\n        const response = await fetch('/uploads/test.jpg');\n        expect(response.headers.get('Content-Type')).toBe('image/jpeg');\n        expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');\n    });\n});\n```\n\nSECURITY BENEFITS:\n\n1. Prevents MIME-type sniffing attacks\n2. Stops execution of uploaded malicious files\n3. Reduces XSS attack surface\n4. Ensures consistent content handling\n5. Complements other security headers\n6. Improves overall security posture\n\nMONITORING:\n- Log missing security headers\n- Monitor for MIME-type mismatches\n- Track file upload security incidents\n- Alert on suspicious file uploads\n- Maintain security header compliance metrics\n*/"
      }
    ]
  },
  {
    "pluginId": 10023,
    "title": "Information Disclosure - Debug Error Messages",
    "defaultRisk": "Medium",
    "cweid": 200,
    "description": "The application is revealing sensitive information through debug error messages, including stack traces, database queries, file paths, and internal system details. This information exposure provides attackers with valuable intelligence about the application architecture, database schema, and potential vulnerabilities.",
    "simplified_description": "Your website is showing detailed error messages that reveal internal system information, like leaving your blueprint and server room keys on the front desk. Attackers can use this information to understand your application's structure, find security weaknesses, and plan targeted attacks against your system.",
    "solution": "Configure error handling to display generic error messages to users while logging detailed information securely on the server. Implement proper exception handling, custom error pages, and ensure debug modes are disabled in production environments. Secure log files with proper access controls.",
    "simplified_solution": "Update your application to hide detailed error messages from users and show friendly, generic error pages instead. Log the detailed technical information to secure server files that only administrators can access. Turn off all debug modes in production and test your error handling thoroughly.",
    "references": [
      {
        "name": "OWASP Error Handling Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html"
      },
      {
        "name": "CWE-209: Generation of Error Message Containing Sensitive Information",
        "url": "https://cwe.mitre.org/data/definitions/209.html"
      },
      {
        "name": "NIST SP 800-53 Rev 4",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP Error Handling Configuration",
        "solution_description": "This comprehensive solution provides secure error handling for PHP applications across different frameworks and environments. It includes PHP configuration, custom error handlers, logging mechanisms, framework-specific implementations, and production deployment considerations. The solution ensures that users see generic error messages while detailed technical information is securely logged.",
        "affected_files": "php.ini, .htaccess files, error handling classes, custom error pages, logging configuration files, framework configuration files (WordPress wp-config.php, Laravel .env, Symfony config)",
        "code": "<?php\n// PHP Secure Error Handling Solution\n\n// ======================================\n# PHP.INI CONFIGURATION\n# ======================================\n\n/*\nProduction php.ini settings:\n\n; Hide PHP errors from users\ndisplay_errors = Off\n\n; Log errors to file\nlog_errors = On\nerror_log = /var/log/php_errors.log\n\n; Set error reporting level\nerror_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT\n\n; Maximum log file size\nlog_errors_max_len = 1024\n\n; Disable HTML errors\nhtml_errors = Off\n\n; Set default timezone (prevents warnings)\ndate.timezone = \"UTC\"\n\n; File upload settings\nupload_max_filesize = 10M\npost_max_size = 10M\n\n; Execution limits\nmax_execution_time = 30\nmax_input_time = 60\n\n; Memory limit\nmemory_limit = 128M\n\n; Disable dangerous functions (optional)\ndisable_functions = exec,passthru,shell_exec,system,proc_open,popen\n\nDevelopment php.ini settings:\n\ndisplay_errors = On\nerror_reporting = E_ALL\nlog_errors = On\nerror_log = /var/log/php_errors_dev.log\nhtml_errors = On\n*/\n\n// ======================================\n# CUSTOM ERROR HANDLER CLASS\n# ======================================\n\nclass SecureErrorHandler {\n    private static $instance = null;\n    private $logFile;\n    private $environment;\n    \n    public static function getInstance($environment = 'production', $logFile = null) {\n        if (self::$instance === null) {\n            self::$instance = new self($environment, $logFile);\n        }\n        return self::$instance;\n    }\n    \n    private function __construct($environment, $logFile) {\n        $this->environment = $environment;\n        $this->logFile = $logFile ?: ($environment === 'production' \n            ? '/var/log/php_errors.log' \n            : '/var/log/php_errors_dev.log');\n        \n        $this->initializeErrorHandler();\n    }\n    \n    private function initializeErrorHandler() {\n        // Set error and exception handlers\n        set_error_handler([$this, 'handleError']);\n        set_exception_handler([$this, 'handleException']);\n        register_shutdown_function([$this, 'handleShutdown']);\n    }\n    \n    public function handleError($errno, $errstr, $errfile, $errline) {\n        $errorData = [\n            'type' => 'error',\n            'errno' => $errno,\n            'message' => $errstr,\n            'file' => $errfile,\n            'line' => $errline,\n            'timestamp' => date('Y-m-d H:i:s'),\n            'request_uri' => $_SERVER['REQUEST_URI'] ?? 'unknown',\n            'remote_addr' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',\n            'request_method' => $_SERVER['REQUEST_METHOD'] ?? 'unknown',\n            'post_data' => $this->sanitizePostData($_POST),\n            'session_data' => $this->sanitizeSessionData($_SESSION ?? []),\n            'stack_trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)\n        ];\n        \n        $this->logError($errorData);\n        \n        if ($this->environment === 'development') {\n            $this->displayDevelopmentError($errorData);\n        } else {\n            $this->displayProductionError();\n        }\n        \n        // Prevent default PHP error handler\n        return true;\n    }\n    \n    public function handleException($exception) {\n        $errorData = [\n            'type' => 'exception',\n            'class' => get_class($exception),\n            'message' => $exception->getMessage(),\n            'file' => $exception->getFile(),\n            'line' => $exception->getLine(),\n            'code' => $exception->getCode(),\n            'timestamp' => date('Y-m-d H:i:s'),\n            'request_uri' => $_SERVER['REQUEST_URI'] ?? 'unknown',\n            'remote_addr' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',\n            'request_method' => $_SERVER['REQUEST_METHOD'] ?? 'unknown',\n            'post_data' => $this->sanitizePostData($_POST),\n            'session_data' => $this->sanitizeSessionData($_SESSION ?? []),\n            'stack_trace' => $exception->getTraceAsString()\n        ];\n        \n        $this->logError($errorData);\n        \n        if ($this->environment === 'development') {\n            $this->displayDevelopmentError($errorData, $exception);\n        } else {\n            $this->displayProductionError();\n        }\n    }\n    \n    public function handleShutdown() {\n        $error = error_get_last();\n        if ($error && in_array($error['type'], [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR])) {\n            $this->handleError(\n                $error['type'],\n                $error['message'],\n                $error['file'],\n                $error['line']\n            );\n        }\n    }\n    \n    private function logError($errorData) {\n        $logEntry = json_encode($errorData) . \"\\n\";\n        \n        // Write to log file with proper permissions\n        file_put_contents($this->logFile, $logEntry, FILE_APPEND | LOCK_EX);\n        \n        // Optional: Send to external logging service\n        $this->sendToExternalService($errorData);\n    }\n    \n    private function sanitizePostData($postData) {\n        $sanitized = [];\n        $sensitiveKeys = ['password', 'credit_card', 'ssn', 'token', 'secret', 'key'];\n        \n        foreach ($postData as $key => $value) {\n            $keyLower = strtolower($key);\n            $isSensitive = false;\n            \n            foreach ($sensitiveKeys as $sensitive) {\n                if (strpos($keyLower, $sensitive) !== false) {\n                    $isSensitive = true;\n                    break;\n                }\n            }\n            \n            $sanitized[$key] = $isSensitive ? '[REDACTED]' : $value;\n        }\n        \n        return $sanitized;\n    }\n    \n    private function sanitizeSessionData($sessionData) {\n        $sanitized = [];\n        $sensitiveKeys = ['password', 'credit_card', 'ssn', 'token', 'secret', 'key'];\n        \n        foreach ($sessionData as $key => $value) {\n            $keyLower = strtolower($key);\n            $isSensitive = false;\n            \n            foreach ($sensitiveKeys as $sensitive) {\n                if (strpos($keyLower, $sensitive) !== false) {\n                    $isSensitive = true;\n                    break;\n                }\n            }\n            \n            $sanitized[$key] = $isSensitive ? '[REDACTED]' : $value;\n        }\n        \n        return $sanitized;\n    }\n    \n    private function displayProductionError() {\n        http_response_code(500);\n        \n        // Check if request expects JSON\n        if ($this->isAjaxRequest()) {\n            header('Content-Type: application/json');\n            echo json_encode([\n                'error' => 'An internal server error occurred',\n                'message' => 'Please try again later or contact support',\n                'timestamp' => time()\n            ]);\n        } else {\n            include 'error_pages/500.html';\n        }\n    }\n    \n    private function displayDevelopmentError($errorData, $exception = null) {\n        http_response_code(500);\n        \n        if ($this->isAjaxRequest()) {\n            header('Content-Type: application/json');\n            echo json_encode([\n                'error' => $errorData['message'],\n                'type' => $errorData['type'],\n                'file' => $errorData['file'],\n                'line' => $errorData['line'],\n                'stack_trace' => $errorData['stack_trace']\n            ]);\n        } else {\n            echo '<div style=\"font-family: monospace; padding: 20px; background: #f5f5f5;\">';\n            echo '<h1>Development Error</h1>';\n            echo '<p><strong>Type:</strong> ' . htmlspecialchars($errorData['type']) . '</p>';\n            echo '<p><strong>Message:</strong> ' . htmlspecialchars($errorData['message']) . '</p>';\n            echo '<p><strong>File:</strong> ' . htmlspecialchars($errorData['file']) . '</p>';\n            echo '<p><strong>Line:</strong> ' . htmlspecialchars($errorData['line']) . '</p>';\n            echo '<h3>Stack Trace:</h3>';\n            echo '<pre>' . htmlspecialchars($errorData['stack_trace']) . '</pre>';\n            echo '</div>';\n        }\n    }\n    \n    private function isAjaxRequest() {\n        return !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && \n               strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest';\n    }\n    \n    private function sendToExternalService($errorData) {\n        // Optional: Send errors to external logging service\n        // Example: Sentry, Loggly, Papertrail, etc.\n        \n        if (function_exists('sentry_capture_message')) {\n            sentry_capture_message($errorData['message'], [\n                'extra' => $errorData\n            ]);\n        }\n    }\n}\n\n// Initialize error handler\n$environment = $_ENV['APP_ENV'] ?? 'production';\n$errorHandler = SecureErrorHandler::getInstance($environment);\n\n// ======================================\n# APACHE CONFIGURATION\n# ======================================\n\n/*\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # PHP configuration\n    php_admin_flag display_errors Off\n    php_admin_flag log_errors On\n    php_admin_value error_log /var/log/php_errors.log\n    php_admin_flag expose_php Off\n    \n    # Custom error pages\n    ErrorDocument 400 /error_pages/400.html\n    ErrorDocument 401 /error_pages/401.html\n    ErrorDocument 403 /error_pages/403.html\n    ErrorDocument 404 /error_pages/404.html\n    ErrorDocument 500 /error_pages/500.html\n    ErrorDocument 502 /error_pages/502.html\n    ErrorDocument 503 /error_pages/503.html\n</VirtualHost>\n\n# .htaccess for specific directories\n<FilesMatch \"\\.(php|phtml)$\">\n    php_flag display_errors Off\n    php_flag log_errors On\n    php_value error_log /var/log/php_errors.log\n</FilesMatch>\n*/\n\n// ======================================\n# NGINX CONFIGURATION\n# ======================================\n\n/*\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    root /var/www/html;\n    \n    # Custom error pages\n    error_page 400 /error_pages/400.html;\n    error_page 401 /error_pages/401.html;\n    error_page 403 /error_pages/403.html;\n    error_page 404 /error_pages/404.html;\n    error_page 500 /error_pages/500.html;\n    error_page 502 /error_pages/502.html;\n    error_page 503 /error_pages/503.html;\n    \n    # Prevent error pages from being accessed directly\n    location ~ ^/error_pages/ {\n        internal;\n    }\n    \n    # PHP-FPM configuration with error handling\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;\n        \n        # PHP configuration\n        fastcgi_param PHP_FLAG \"display_errors=Off\";\n        fastcgi_param PHP_VALUE \"error_log=/var/log/php_errors.log\\nlog_errors=On\";\n        \n        # Catch PHP errors\n        fastcgi_intercept_errors on;\n    }\n}\n*/\n\n// ======================================\n# LARAVEL FRAMEWORK CONFIGURATION\n# ======================================\n\n// .env file\nAPP_ENV=production\nAPP_DEBUG=false\nLOG_CHANNEL=daily\n\n// config/app.php\n'debug' => env('APP_DEBUG', false),\n\n// config/logging.php\n'default' => env('LOG_CHANNEL', 'daily'),\n\n'channels' => [\n    'daily' => [\n        'driver' => 'daily',\n        'path' => storage_path('logs/laravel.log'),\n        'level' => 'debug',\n        'days' => 14,\n    ],\n    \n    'error' => [\n        'driver' => 'single',\n        'path' => storage_path('logs/error.log'),\n        'level' => 'error',\n    ],\n],\n\n// app/Exceptions/Handler.php\nnamespace App\\Exceptions;\n\nuse Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;\nuse Illuminate\\Http\\Request;\nuse Throwable;\n\nclass Handler extends ExceptionHandler\n{\n    protected $dontReport = [\n        // Exception types that shouldn't be reported\n    ];\n    \n    protected $dontFlash = [\n        'password',\n        'password_confirmation',\n        'credit_card',\n        'ssn'\n    ];\n    \n    public function report(Throwable $exception)\n    {\n        // Custom error reporting\n        $this->logErrorDetails($exception);\n        \n        parent::report($exception);\n    }\n    \n    public function render($request, Throwable $exception)\n    {\n        if ($this->isApiRequest($request)) {\n            return $this->handleApiError($exception);\n        }\n        \n        return parent::render($request, $exception);\n    }\n    \n    private function isApiRequest($request): bool\n    {\n        return $request->expectsJson() || $request->is('api/*');\n    }\n    \n    private function handleApiError($exception)\n    {\n        return response()->json([\n            'error' => 'An error occurred',\n            'message' => 'Please try again later',\n            'timestamp' => now()->toISOString()\n        ], 500);\n    }\n    \n    private function logErrorDetails($exception)\n    {\n        $errorData = [\n            'exception' => get_class($exception),\n            'message' => $exception->getMessage(),\n            'file' => $exception->getFile(),\n            'line' => $exception->getLine(),\n            'request' => request()->all(),\n            'user_id' => auth()->id(),\n            'ip_address' => request()->ip(),\n            'user_agent' => request()->userAgent(),\n            'url' => request()->fullUrl()\n        ];\n        \n        logger()->error('Application error', $errorData);\n    }\n}\n\n// ======================================\n# WORDPRESS CONFIGURATION\n# ======================================\n\n// wp-config.php\n// Enable debug mode only in development\nif (!defined('WP_DEBUG')) {\n    define('WP_DEBUG', false); // Always false in production\n}\n\nif (!defined('WP_DEBUG_LOG')) {\n    define('WP_DEBUG_LOG', false); // Don't log to wp-content/debug.log\n}\n\nif (!defined('WP_DEBUG_DISPLAY')) {\n    define('WP_DEBUG_DISPLAY', false); // Don't display errors\n}\n\n@ini_set('display_errors', 0);\n@ini_set('log_errors', 1);\n@ini_set('error_log', '/var/log/wordpress_errors.log');\n\n// Custom error handler\nfunction custom_wordpress_error_handler($errno, $errstr, $errfile, $errline) {\n    $error_data = [\n        'error' => $errstr,\n        'file' => $errfile,\n        'line' => $errline,\n        'request_uri' => $_SERVER['REQUEST_URI'],\n        'user_agent' => $_SERVER['HTTP_USER_AGENT'],\n        'ip_address' => $_SERVER['REMOTE_ADDR']\n    ];\n    \n    error_log(json_encode($error_data));\n    \n    // Don't display errors to users\n    return true;\n}\n\n// Set custom error handler\nset_error_handler('custom_wordpress_error_handler');\n\n// ======================================\n# CUSTOM ERROR PAGES\n# ======================================\n\n<!-- error_pages/500.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Service Unavailable</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            text-align: center;\n            padding: 50px;\n            background-color: #f5f5f5;\n        }\n        .error-container {\n            max-width: 600px;\n            margin: 0 auto;\n            background: white;\n            padding: 40px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .error-code {\n            font-size: 4em;\n            color: #e74c3c;\n            margin: 0;\n        }\n        .error-message {\n            font-size: 1.5em;\n            color: #333;\n            margin: 20px 0;\n        }\n        .error-description {\n            color: #666;\n            line-height: 1.6;\n        }\n        .error-actions {\n            margin-top: 30px;\n        }\n        .btn {\n            display: inline-block;\n            padding: 12px 24px;\n            background: #3498db;\n            color: white;\n            text-decoration: none;\n            border-radius: 4px;\n            margin: 0 10px;\n        }\n        .btn:hover {\n            background: #2980b9;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"error-container\">\n        <div class=\"error-code\">500</div>\n        <h1 class=\"error-message\">Service Unavailable</h1>\n        <p class=\"error-description\">\n            We're sorry, but something went wrong while processing your request. \n            Our team has been notified and is working to resolve the issue.\n        </p>\n        <p class=\"error-description\">\n            Please try again in a few minutes, or contact our support team \n            if the problem persists.\n        </p>\n        <div class=\"error-actions\">\n            <a href=\"javascript:history.back()\" class=\"btn\">Go Back</a>\n            <a href=\"/\" class=\"btn\">Home Page</a>\n        </div>\n    </div>\n</body>\n</html>\n\n// ======================================\n# ERROR LOG MONITORING\n# ======================================\n\n// error_monitor.php\nclass ErrorMonitor {\n    private $logFile;\n    private $alertThreshold = 10; // Alert after 10 errors in 5 minutes\n    private $alertEmail = 'admin@example.com';\n    \n    public function __construct($logFile) {\n        $this->logFile = $logFile;\n    }\n    \n    public function checkForAlerts() {\n        $recentErrors = $this->getRecentErrors();\n        \n        if (count($recentErrors) >= $this->alertThreshold) {\n            $this->sendAlert($recentErrors);\n        }\n    }\n    \n    private function getRecentErrors() {\n        $fiveMinutesAgo = time() - 300;\n        $errors = [];\n        \n        if (file_exists($this->logFile)) {\n            $lines = file($this->logFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);\n            \n            foreach ($lines as $line) {\n                $errorData = json_decode($line, true);\n                \n                if ($errorData && strtotime($errorData['timestamp']) >= $fiveMinutesAgo) {\n                    $errors[] = $errorData;\n                }\n            }\n        }\n        \n        return $errors;\n    }\n    \n    private function sendAlert($errors) {\n        $subject = \"High Error Rate Alert - \" . count($errors) . \" errors in 5 minutes\";\n        $message = \"Recent error activity detected:\\n\\n\";\n        \n        foreach (array_slice($errors, 0, 5) as $error) {\n            $message .= \"Time: {$error['timestamp']}\\n\";\n            $message .= \"Error: {$error['message']}\\n\";\n            $message .= \"File: {$error['file']}\\n\";\n            $message .= \"Line: {$error['line']}\\n\\n\";\n        }\n        \n        mail($this->alertEmail, $subject, $message);\n    }\n}\n\n// Run error monitoring (can be scheduled via cron)\n$monitor = new ErrorMonitor('/var/log/php_errors.log');\n$monitor->checkForAlerts();"
      }
    ]
  },
  {
    "pluginId": 10028,
    "title": "Off-site Redirect",
    "defaultRisk": "Low",
    "cweid": "601",
    "description": "The application contains off-site redirect functionality that may not properly validate redirect targets. This can lead to security issues where users can be redirected to malicious websites, potentially enabling phishing attacks or malware distribution.",
    "simplified_description": "Your application has a feature that redirects users to other websites, but it may not properly check if those websites are safe. This is like giving visitors directions to any address they ask for - they could be directed to fake websites designed to steal their login information or install malware.",
    "solution": "Implement strict validation for all redirect targets using a whitelist approach and avoid using user-supplied input directly for redirection.",
    "simplified_solution": "Create a list of approved external websites, validate all redirect requests against this list, and use indirect references or tokens instead of direct URLs when possible.",
    "references": [
      {
        "name": "OWASP Top 10 - A01 Broken Access Control",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Broken_Access_Control"
      },
      {
        "name": "CWE-601: URL Redirection to Untrusted Site",
        "url": "https://cwe.mitre.org/data/definitions/601.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "External Redirect Security Implementation",
        "solution_description": "This solution demonstrates how to implement secure external redirects using URL validation, whitelisting, token-based redirects, and proper error handling to prevent redirect-based attacks.",
        "affected_files": "External link handlers, social login callbacks, payment redirect handlers, OAuth implementations, affiliate link systems",
        "code": "// BAD: Unvalidated external redirect\napp.get('/external-redirect', (req, res) => {\n    const targetUrl = req.query.url; // User-controlled\n    res.redirect(302, targetUrl); // Vulnerable: redirects anywhere\n});\n\n// GOOD: Secure external redirect implementation\napp.get('/external-redirect', (req, res) => {\n    const targetUrl = req.query.url;\n    \n    if (isValidExternalUrl(targetUrl)) {\n        res.redirect(302, targetUrl);\n    } else {\n        res.status(400).json({ error: 'Invalid redirect URL' });\n    }\n});\n\n// ========================================\n// SECURE EXTERNAL REDIRECT SERVICE\n// ========================================\n\nclass SecureExternalRedirectService {\n    // Whitelist of allowed external domains\n    private static readonly ALLOWED_DOMAINS = [\n        'trustedsite1.com',\n        'payments.trustedsite1.com',\n        'partners.yourdomain.com',\n        'auth.google.com',\n        'login.microsoftonline.com',\n        'github.com'\n    ];\n    \n    // Redirect token mapping (token -> URL)\n    private static readonly redirectTokens = new Map<string, string>();\n    \n    /**\n     * Validates external URL for safe redirection\n     */\n    static isValidExternalUrl(url: string): boolean {\n        if (!url || typeof url !== 'string') {\n            return false;\n        }\n        \n        try {\n            const parsedUrl = new URL(url);\n            \n            // Allow only HTTPS for external redirects\n            if (parsedUrl.protocol !== 'https:') {\n                return false;\n            }\n            \n            // Check if domain is in whitelist\n            const hostname = parsedUrl.hostname.toLowerCase();\n            if (!this.ALLOWED_DOMAINS.some(domain => \n                hostname === domain || hostname.endsWith('.' + domain))) {\n                return false;\n            }\n            \n            // Reject suspicious patterns\n            if (this.hasSuspiciousPatterns(url)) {\n                return false;\n            }\n            \n            return true;\n            \n        } catch (error) {\n            return false;\n        }\n    }\n    \n    /**\n     * Creates a redirect token for a valid URL\n     */\n    static createRedirectToken(url: string): string | null {\n        if (!this.isValidExternalUrl(url)) {\n            return null;\n        }\n        \n        // Generate secure token\n        const token = this.generateSecureToken();\n        \n        // Store with expiration (1 hour)\n        this.redirectTokens.set(token, url);\n        setTimeout(() => {\n            this.redirectTokens.delete(token);\n        }, 3600000); // 1 hour\n        \n        return token;\n    }\n    \n    /**\n     * Gets URL from redirect token\n     */\n    static getUrlFromToken(token: string): string | null {\n        const url = this.redirectTokens.get(token);\n        if (url) {\n            // Remove token after use (single use)\n            this.redirectTokens.delete(token);\n            return url;\n        }\n        return null;\n    }\n    \n    /**\n     * Generates secure random token\n     */\n    private static generateSecureToken(): string {\n        const crypto = require('crypto');\n        return crypto.randomBytes(32).toString('hex');\n    }\n    \n    /**\n     * Checks for suspicious URL patterns\n     */\n    private static hasSuspiciousPatterns(url: string): boolean {\n        const suspiciousPatterns = [\n            /javascript:/i,\n            /data:/i,\n            /vbscript:/i,\n            /\\0/,      // Null bytes\n            /[<>\"']/,  // HTML injection chars\n            /\\s/,      // Spaces in URLs\n        ];\n        \n        return suspiciousPatterns.some(pattern => pattern.test(url));\n    }\n}\n\n// ========================================\n// CONTROLLER IMPLEMENTATION\n// ========================================\n\nconst express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// External redirect with URL validation\napp.get('/external-redirect', (req, res) => {\n    const { url } = req.query;\n    \n    if (!url) {\n        return res.status(400).json({ error: 'URL parameter required' });\n    }\n    \n    // Validate external URL\n    if (SecureExternalRedirectService.isValidExternalUrl(url)) {\n        // Log the redirect for security monitoring\n        console.log(`External redirect: ${req.ip} -> ${url}`);\n        \n        res.status(302).redirect(url);\n    } else {\n        // Log invalid redirect attempts\n        console.warn(`Invalid external redirect attempt: ${req.ip} -> ${url}`);\n        \n        res.status(400).json({ \n            error: 'Invalid or unauthorized external URL' \n        });\n    }\n});\n\n// Token-based redirect (more secure)\napp.get('/token-redirect/:token', (req, res) => {\n    const { token } = req.params;\n    \n    if (!token || !/^[a-f0-9]{64}$/.test(token)) {\n        return res.status(400).json({ error: 'Invalid token format' });\n    }\n    \n    // Get URL from token\n    const url = SecureExternalRedirectService.getUrlFromToken(token);\n    \n    if (url) {\n        console.log(`Token-based redirect: ${req.ip} -> ${url}`);\n        res.status(302).redirect(url);\n    } else {\n        res.status(404).json({ error: 'Redirect not found or expired' });\n    }\n});\n\n// Create redirect token\napp.post('/create-redirect-token', (req, res) => {\n    const { url } = req.body;\n    \n    if (!url) {\n        return res.status(400).json({ error: 'URL required' });\n    }\n    \n    const token = SecureExternalRedirectService.createRedirectToken(url);\n    \n    if (token) {\n        res.json({ \n            token,\n            redirectUrl: `/token-redirect/${token}`\n        });\n    } else {\n        res.status(400).json({ \n            error: 'Invalid or unauthorized external URL' \n        });\n    }\n});\n\n// ========================================\n// SPRING BOOT IMPLEMENTATION\n// ========================================\n\n@Service\npublic class ExternalRedirectService {\n    \n    private final Map<String, RedirectToken> redirectTokens = new ConcurrentHashMap<>();\n    \n    private static final List<String> ALLOWED_DOMAINS = Arrays.asList(\n        \"trustedsite1.com\",\n        \"payments.trustedsite1.com\",\n        \"auth.google.com\"\n    );\n    \n    public boolean isValidExternalUrl(String url) {\n        if (StringUtils.isEmpty(url)) {\n            return false;\n        }\n        \n        try {\n            URI uri = new URI(url);\n            \n            // Allow only HTTPS\n            if (!\"https\".equals(uri.getScheme())) {\n                return false;\n            }\n            \n            // Check domain whitelist\n            String host = uri.getHost();\n            if (host != null && !isAllowedDomain(host)) {\n                return false;\n            }\n            \n            return true;\n            \n        } catch (URISyntaxException e) {\n            return false;\n        }\n    }\n    \n    public String createRedirectToken(String url) {\n        if (!isValidExternalUrl(url)) {\n            return null;\n        }\n        \n        String token = generateSecureToken();\n        RedirectToken redirectToken = new RedirectToken(url, Instant.now().plusHours(1));\n        redirectTokens.put(token, redirectToken);\n        \n        return token;\n    }\n    \n    public Optional<String> getUrlFromToken(String token) {\n        RedirectToken redirectToken = redirectTokens.remove(token);\n        \n        if (redirectToken != null && redirectToken.getExpiry().isAfter(Instant.now())) {\n            return Optional.of(redirectToken.getUrl());\n        }\n        \n        return Optional.empty();\n    }\n    \n    private boolean isAllowedDomain(String host) {\n        return ALLOWED_DOMAINS.stream()\n            .anyMatch(allowed -> host.equals(allowed) || host.endsWith(\".\" + allowed));\n    }\n    \n    private String generateSecureToken() {\n        return UUID.randomUUID().toString().replace(\"-\", \"\");\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/redirect\")\npublic class RedirectController {\n    \n    private final ExternalRedirectService redirectService;\n    \n    @PostMapping(\"/token\")\n    public ResponseEntity<RedirectTokenResponse> createRedirectToken(\n            @RequestBody CreateTokenRequest request) {\n        \n        String token = redirectService.createRedirectToken(request.getUrl());\n        \n        if (token != null) {\n            return ResponseEntity.ok(new RedirectTokenResponse(token));\n        } else {\n            return ResponseEntity.badRequest()\n                .body(new RedirectTokenResponse(null, \"Invalid URL\"));\n        }\n    }\n    \n    @GetMapping(\"/external\")\n    public ResponseEntity<Void> externalRedirect(\n            @RequestParam String url,\n            HttpServletRequest request) {\n        \n        if (redirectService.isValidExternalUrl(url)) {\n            // Log for security monitoring\n            logSecurityEvent(request.getRemoteAddr(), \"EXTERNAL_REDIRECT\", url);\n            \n            return ResponseEntity.status(HttpStatus.FOUND)\n                .location(URI.create(url))\n                .build();\n        } else {\n            logSecurityEvent(request.getRemoteAddr(), \"INVALID_REDIRECT_ATTEMPT\", url);\n            return ResponseEntity.badRequest().build();\n        }\n    }\n    \n    @GetMapping(\"/token/{token}\")\n    public ResponseEntity<Void> tokenRedirect(\n            @PathVariable String token,\n            HttpServletRequest request) {\n        \n        Optional<String> urlOpt = redirectService.getUrlFromToken(token);\n        \n        if (urlOpt.isPresent()) {\n            String url = urlOpt.get();\n            logSecurityEvent(request.getRemoteAddr(), \"TOKEN_REDIRECT\", url);\n            \n            return ResponseEntity.status(HttpStatus.FOUND)\n                .location(URI.create(url))\n                .build();\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n    \n    private void logSecurityEvent(String ip, String action, String details) {\n        // Implement security logging\n        System.out.printf(\"Security Event: %s - %s - %s%n\", ip, action, details);\n    }\n}\n\n// ========================================\n// FRONTEND IMPLEMENTATION\n// ========================================\n\nimport React, { useState } from 'react';\n\nconst SecureExternalRedirect = () => {\n    const [url, setUrl] = useState('');\n    const [redirectToken, setRedirectToken] = useState('');\n    const [error, setError] = useState('');\n    \n    const handleCreateToken = async () => {\n        try {\n            setError('');\n            \n            const response = await fetch('/api/redirect/token', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ url })\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok && data.token) {\n                setRedirectToken(data.token);\n            } else {\n                setError(data.error || 'Failed to create redirect token');\n            }\n        } catch (error) {\n            setError('Network error occurred');\n        }\n    };\n    \n    const handleRedirect = () => {\n        if (redirectToken) {\n            window.location.href = `/api/redirect/token/${redirectToken}`;\n        }\n    };\n    \n    return (\n        <div className=\"redirect-container\">\n            <h3>Secure External Redirect</h3>\n            \n            <div className=\"form-group\">\n                <label>External URL:</label>\n                <input\n                    type=\"url\"\n                    value={url}\n                    onChange={(e) => setUrl(e.target.value)}\n                    placeholder=\"https://trustedsite.com/path\"\n                />\n            </div>\n            \n            <button onClick={handleCreateToken}>\n                Create Redirect Token\n            </button>\n            \n            {redirectToken && (\n                <div className=\"redirect-section\">\n                    <p>Redirect token created successfully!</p>\n                    <button onClick={handleRedirect}>\n                        Proceed to Redirect\n                    </button>\n                </div>\n            )}\n            \n            {error && (\n                <div className=\"error-message\">\n                    {error}\n                </div>\n            )}\n        </div>\n    );\n};\n\nexport default SecureExternalRedirect;\n\n// ========================================\n// SECURITY TESTING\n// ========================================\n\n/*\nSECURITY TESTING EXAMPLES:\n\n1. Test Malicious URLs:\n   - javascript:alert('XSS')\n   - data:text/html,<script>alert('XSS')</script>\n   - http://evil.com/phishing\n   - https://malicious.site.com\n   - //evil.com (protocol-relative)\n\n2. Test Encoding Bypass:\n   - %68%74%74%70%3a%2f%2fevil.com (URL encoded)\n   - &amp;#104;&#116;&#116;&#112;&#58;&#47;&#47;evil.com (HTML encoded)\n   - %c0%af%c0%af (Unicode bypass attempts)\n\n3. Test Token Security:\n   - Invalid tokens\n   - Expired tokens\n   - Token replay attacks\n   - Token prediction\n\n4. Test Domain Validation:\n   - Subdomain attacks\n   - Domain spoofing\n   - IDN homograph attacks\n   - Typosquatting attempts\n\nAUTOMATED TESTS:\n```javascript\ndescribe('External Redirect Security', () => {\n    test('blocks javascript URLs', () => {\n        expect(SecureExternalRedirectService.isValidExternalUrl('javascript:alert(1)'))\n            .toBe(false);\n    });\n    \n    test('allows trusted HTTPS domains', () => {\n        expect(SecureExternalRedirectService.isValidExternalUrl('https://trustedsite1.com/path'))\n            .toBe(true);\n    });\n    \n    test('blocks HTTP URLs', () => {\n        expect(SecureExternalRedirectService.isValidExternalUrl('http://trustedsite1.com/path'))\n            .toBe(false);\n    });\n    \n    test('creates valid redirect tokens', () => {\n        const token = SecureExternalRedirectService.createRedirectToken('https://trustedsite1.com');\n        expect(token).toBeTruthy();\n        \n        const url = SecureExternalRedirectService.getUrlFromToken(token);\n        expect(url).toBe('https://trustedsite1.com');\n    });\n});\n```\n\nMONITORING:\n- Log all redirect attempts\n- Alert on unusual patterns\n- Track failed attempts\n- Monitor for abuse\n- Rate limit redirect creation\n*/"
      }
    ]
  },
  {
    "pluginId": 10029,
    "title": "Cookie Poisoning",
    "defaultRisk": "Medium",
    "cweid": "565",
    "description": "Cookie poisoning vulnerabilities occur when applications accept and process cookie values without proper validation, allowing attackers to manipulate cookie data to bypass security controls, escalate privileges, or perform unauthorized actions.",
    "simplified_description": "Your application has a security weakness in how it handles cookies - it's like accepting a visitor's pass without checking if it's been forged. Attackers can modify cookie values to impersonate other users, bypass authentication, or gain unauthorized access to sensitive functionality by simply changing cookie values in their browser.",
    "solution": "Implement secure cookie handling with proper validation, encryption, and integrity checks to prevent cookie manipulation attacks.",
    "simplified_solution": "Add secure cookie configuration with HttpOnly, Secure, and SameSite attributes. Encrypt sensitive cookie data and implement integrity checks using digital signatures. Never trust cookie values without proper validation and never store sensitive information in cookies without encryption.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-565: Reliance on Cookies without Validation and Integrity Checking",
        "url": "https://cwe.mitre.org/data/definitions/565.html"
      },
      {
        "name": "OWASP Top Ten A05:2021 - Security Misconfiguration",
        "url": "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Cookie Management Implementation",
        "solution_description": "This solution demonstrates comprehensive secure cookie management including encrypted session cookies, integrity validation, secure configuration, and protection against cookie poisoning attacks using modern cryptographic techniques.",
        "affected_files": "Authentication middleware, session management controllers, cookie configuration, security filters, API endpoints",
        "code": "// ============================================\n// SECURE COOKIE MANAGEMENT MIDDLEWARE\n// ============================================\n\nconst crypto = require('crypto');\nconst cookie = require('cookie');\nconst { createHash, createHmac } = require('crypto');\n\nclass SecureCookieManager {\n    constructor(secretKey, encryptionKey) {\n        this.secretKey = secretKey; // For HMAC signing\n        this.encryptionKey = encryptionKey; // For cookie encryption\n        this.algorithm = 'aes-256-gcm';\n        this.hmacAlgorithm = 'sha256';\n    }\n    \n    // Secure cookie configuration\n    static getSecureCookieOptions() {\n        return {\n            httpOnly: true,          // Prevent JavaScript access\n            secure: process.env.NODE_ENV === 'production',  // HTTPS only in production\n            sameSite: 'strict',      // CSRF protection\n            maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n            path: '/',\n            domain: process.env.COOKIE_DOMAIN || undefined\n        };\n    }\n    \n    // Encrypt and sign cookie data\n    encryptAndSign(data) {\n        try {\n            // Convert data to JSON string\n            const dataString = JSON.stringify(data);\n            \n            // Generate random IV\n            const iv = crypto.randomBytes(16);\n            \n            // Create cipher\n            const cipher = crypto.createCipher(this.algorithm, this.encryptionKey);\n            cipher.setAAD(Buffer.from('cookie-data'));\n            \n            // Encrypt data\n            let encrypted = cipher.update(dataString, 'utf8', 'hex');\n            encrypted += cipher.final('hex');\n            \n            // Get authentication tag\n            const authTag = cipher.getAuthTag();\n            \n            // Create payload\n            const payload = {\n                iv: iv.toString('hex'),\n                authTag: authTag.toString('hex'),\n                data: encrypted,\n                timestamp: Date.now()\n            };\n            \n            // Sign the payload\n            const payloadString = JSON.stringify(payload);\n            const signature = crypto\n                .createHmac(this.hmacAlgorithm, this.secretKey)\n                .update(payloadString)\n                .digest('hex');\n            \n            // Return combined payload + signature\n            return Buffer.from(payloadString).toString('base64') + '.' + signature;\n            \n        } catch (error) {\n            console.error('Cookie encryption failed:', error);\n            throw new Error('Failed to secure cookie data');\n        }\n    }\n    \n    // Verify signature and decrypt cookie data\n    verifyAndDecrypt(signedCookie) {\n        try {\n            // Split payload and signature\n            const [payloadBase64, signature] = signedCookie.split('.');\n            \n            if (!payloadBase64 || !signature) {\n                throw new Error('Invalid cookie format');\n            }\n            \n            // Decode payload\n            const payloadString = Buffer.from(payloadBase64, 'base64').toString('utf8');\n            \n            // Verify signature\n            const expectedSignature = crypto\n                .createHmac(this.hmacAlgorithm, this.secretKey)\n                .update(payloadString)\n                .digest('hex');\n            \n            if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {\n                throw new Error('Invalid cookie signature');\n            }\n            \n            // Parse payload\n            const payload = JSON.parse(payloadString);\n            \n            // Check timestamp (prevent replay attacks)\n            const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n            if (Date.now() - payload.timestamp > maxAge) {\n                throw new Error('Cookie has expired');\n            }\n            \n            // Decrypt data\n            const decipher = crypto.createDecipher(this.algorithm, this.encryptionKey);\n            decipher.setAAD(Buffer.from('cookie-data'));\n            decipher.setAuthTag(Buffer.from(payload.authTag, 'hex'));\n            \n            let decrypted = decipher.update(payload.data, 'hex', 'utf8');\n            decrypted += decipher.final('utf8');\n            \n            return JSON.parse(decrypted);\n            \n        } catch (error) {\n            console.error('Cookie decryption failed:', error);\n            throw new Error('Failed to verify or decrypt cookie data');\n        }\n    }\n    \n    // Set secure cookie\n    setSecureCookie(res, name, data, options = {}) {\n        try {\n            const secureOptions = { ...SecureCookieManager.getSecureCookieOptions(), ...options };\n            const signedValue = this.encryptAndSign(data);\n            const cookieValue = cookie.serialize(name, signedValue, secureOptions);\n            \n            // Set additional security headers\n            res.setHeader('Set-Cookie', cookieValue);\n            res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n            res.setHeader('Pragma', 'no-cache');\n            \n        } catch (error) {\n            console.error('Failed to set secure cookie:', error);\n            throw error;\n        }\n    }\n    \n    // Get and verify secure cookie\n    getSecureCookie(req, name) {\n        try {\n            const cookies = cookie.parse(req.headers.cookie || '');\n            const signedCookie = cookies[name];\n            \n            if (!signedCookie) {\n                return null;\n            }\n            \n            return this.verifyAndDecrypt(signedCookie);\n            \n        } catch (error) {\n            console.error('Failed to get secure cookie:', error);\n            return null;\n        }\n    }\n    \n    // Clear cookie\n    clearCookie(res, name) {\n        const options = {\n            ...SecureCookieManager.getSecureCookieOptions(),\n            maxAge: -1,  // Immediately expire\n            expires: new Date(0)\n        };\n        \n        const cookieValue = cookie.serialize(name, '', options);\n        res.setHeader('Set-Cookie', cookieValue);\n    }\n}\n\n// ============================================\n// SESSION MANAGEMENT WITH SECURE COOKIES\n// ============================================\n\nclass SecureSessionManager {\n    constructor() {\n        this.cookieManager = new SecureCookieManager(\n            process.env.COOKIE_SECRET_KEY,\n            process.env.COOKIE_ENCRYPTION_KEY\n        );\n        this.sessions = new Map(); // In production, use Redis or database\n    }\n    \n    // Create secure session\n    createSession(userId, userData = {}) {\n        const sessionId = crypto.randomBytes(32).toString('hex');\n        const sessionData = {\n            id: sessionId,\n            userId,\n            data: userData,\n            createdAt: Date.now(),\n            lastAccessedAt: Date.now(),\n            userAgent: userData.userAgent,\n            ipAddress: userData.ipAddress\n        };\n        \n        // Store session\n        this.sessions.set(sessionId, sessionData);\n        \n        return sessionId;\n    }\n    \n    // Set session cookie\n    setSessionCookie(res, sessionId) {\n        const cookieData = {\n            sessionId,\n            // Include additional validation data\n            userId: this.sessions.get(sessionId)?.userId,\n            timestamp: Date.now()\n        };\n        \n        this.cookieManager.setSecureCookie(res, 'sessionId', cookieData);\n    }\n    \n    // Validate session from cookie\n    validateSession(req) {\n        try {\n            const cookieData = this.cookieManager.getSecureCookie(req, 'sessionId');\n            \n            if (!cookieData || !cookieData.sessionId) {\n                return null;\n            }\n            \n            const session = this.sessions.get(cookieData.sessionId);\n            \n            if (!session) {\n                return null;\n            }\n            \n            // Validate session data matches cookie data\n            if (session.userId !== cookieData.userId) {\n                console.warn('Session user ID mismatch - possible cookie tampering');\n                return null;\n            }\n            \n            // Check session age\n            const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n            if (Date.now() - session.lastAccessedAt > maxAge) {\n                this.sessions.delete(cookieData.sessionId);\n                return null;\n            }\n            \n            // Update last accessed time\n            session.lastAccessedAt = Date.now();\n            \n            return session;\n            \n        } catch (error) {\n            console.error('Session validation failed:', error);\n            return null;\n        }\n    }\n    \n    // Destroy session\n    destroySession(req, res) {\n        const cookieData = this.cookieManager.getSecureCookie(req, 'sessionId');\n        \n        if (cookieData && cookieData.sessionId) {\n            this.sessions.delete(cookieData.sessionId);\n            this.cookieManager.clearCookie(res, 'sessionId');\n        }\n    }\n}\n\n// ============================================\n// EXPRESS MIDDLEWARE FOR SECURE COOKIES\n// ============================================\n\nconst sessionManager = new SecureSessionManager();\n\n// Authentication middleware\nconst authenticateSession = (req, res, next) => {\n    try {\n        const session = sessionManager.validateSession(req);\n        \n        if (!session) {\n            // Clear any invalid cookies\n            sessionManager.cookieManager.clearCookie(res, 'sessionId');\n            return res.status(401).json({ error: 'Invalid or expired session' });\n        }\n        \n        // Attach session to request\n        req.session = session;\n        req.user = { id: session.userId, ...session.data };\n        \n        next();\n        \n    } catch (error) {\n        console.error('Authentication middleware error:', error);\n        res.status(500).json({ error: 'Authentication error' });\n    }\n};\n\n// Cookie security middleware\nconst cookieSecurityMiddleware = (req, res, next) => {\n    // Set security headers\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    res.setHeader('X-Frame-Options', 'DENY');\n    res.setHeader('X-XSS-Protection', '1; mode=block');\n    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n    \n    // Remove any suspicious cookies\n    const suspiciousCookies = ['admin', 'role', 'user', 'auth'];\n    const cookies = cookie.parse(req.headers.cookie || '');\n    \n    for (const suspiciousName of suspiciousCookies) {\n        if (cookies[suspiciousName] && !req.path.startsWith('/api/')) {\n            console.warn(`Suspicious cookie detected: ${suspiciousName}`);\n            // Clear suspicious cookies\n            sessionManager.cookieManager.clearCookie(res, suspiciousName);\n        }\n    }\n    \n    next();\n};\n\n// ============================================\n// SECURE AUTHENTICATION ROUTES\n// ============================================\n\nconst express = require('express');\nconst router = express.Router();\n\n// Apply security middleware to all routes\nrouter.use(cookieSecurityMiddleware);\n\n// Login route\nrouter.post('/login', async (req, res) => {\n    try {\n        const { email, password } = req.body;\n        \n        // Validate input\n        if (!email || !password) {\n            return res.status(400).json({ error: 'Email and password required' });\n        }\n        \n        // Authenticate user (implementation depends on your user service)\n        const user = await authenticateUser(email, password);\n        \n        if (!user) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n        \n        // Create secure session\n        const sessionId = sessionManager.createSession(user.id, {\n            email: user.email,\n            role: user.role,\n            userAgent: req.headers['user-agent'],\n            ipAddress: req.ip\n        });\n        \n        // Set secure session cookie\n        sessionManager.setSessionCookie(res, sessionId);\n        \n        // Return user data (without sensitive information)\n        res.json({\n            success: true,\n            user: {\n                id: user.id,\n                email: user.email,\n                role: user.role\n            }\n        });\n        \n    } catch (error) {\n        console.error('Login error:', error);\n        res.status(500).json({ error: 'Login failed' });\n    }\n});\n\n// Logout route\nrouter.post('/logout', (req, res) => {\n    try {\n        sessionManager.destroySession(req, res);\n        res.json({ success: true, message: 'Logged out successfully' });\n    } catch (error) {\n        console.error('Logout error:', error);\n        res.status(500).json({ error: 'Logout failed' });\n    }\n});\n\n// Protected route example\nrouter.get('/profile', authenticateSession, (req, res) => {\n    res.json({\n        user: req.user,\n        sessionInfo: {\n            id: req.session.id,\n            createdAt: req.session.createdAt,\n            lastAccessedAt: req.session.lastAccessedAt\n        }\n    });\n});\n\n// Admin-only route\nrouter.get('/admin', authenticateSession, (req, res) => {\n    if (req.user.role !== 'admin') {\n        return res.status(403).json({ error: 'Admin access required' });\n    }\n    \n    res.json({ message: 'Admin area access granted' });\n});\n\n// ============================================\n// COOKIE VALIDATION UTILITIES\n// ============================================\n\n// Validate cookie format and integrity\nfunction validateCookieIntegrity(cookieValue, expectedStructure) {\n    try {\n        // Check for suspicious patterns\n        const suspiciousPatterns = [\n            /admin\\s*=/i,\n            /role\\s*=/i,\n            /user\\s*=/i,\n            /auth\\s*=/i,\n            /javascript:/i,\n            /<script/i,\n            /data:/i\n        ];\n        \n        for (const pattern of suspiciousPatterns) {\n            if (pattern.test(cookieValue)) {\n                console.warn('Suspicious cookie pattern detected:', cookieValue);\n                return false;\n            }\n        }\n        \n        // Validate expected structure\n        if (expectedStructure && typeof cookieValue === 'object') {\n            for (const [key, type] of Object.entries(expectedStructure)) {\n                if (!(key in cookieValue) || typeof cookieValue[key] !== type) {\n                    console.warn(`Invalid cookie structure for key: ${key}`);\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n        \n    } catch (error) {\n        console.error('Cookie validation error:', error);\n        return false;\n    }\n}\n\n// Detect cookie tampering attempts\nfunction detectCookieTampering(req, originalCookies, currentCookies) {\n    const tamperingIndicators = [];\n    \n    for (const [name, originalValue] of Object.entries(originalCookies)) {\n        const currentValue = currentCookies[name];\n        \n        if (originalValue !== currentValue) {\n            // Check if it's a suspicious change\n            const suspiciousChanges = [\n                /admin/i.test(currentValue),\n                /true/i.test(currentValue) && !/true/i.test(originalValue),\n                /\\d+/.test(currentValue) && !/\\d+/.test(originalValue)\n            ];\n            \n            if (suspiciousChanges.some(Boolean)) {\n                tamperingIndicators.push({\n                    cookieName: name,\n                    originalValue,\n                    currentValue,\n                    suspicious: true\n                });\n            }\n        }\n    }\n    \n    return tamperingIndicators;\n}\n\n// ============================================\n// SECURITY TESTING AND MONITORING\n// ============================================\n\n/*\nCookie Security Testing Checklist:\n\n1. Cookie Configuration Tests:\n   - Verify HttpOnly flag is set\n   - Check Secure flag in production\n   - Validate SameSite=strict attribute\n   - Test cookie expiration handling\n\n2. Encryption and Integrity Tests:\n   - Test cookie encryption/decryption\n   - Verify HMAC signature validation\n   - Test tampering detection\n   - Check replay attack prevention\n\n3. Session Management Tests:\n   - Verify session creation and validation\n   - Test session invalidation on logout\n   - Check session timeout enforcement\n   - Verify session fixation prevention\n\n4. Attack Simulation Tests:\n   - Attempt cookie poisoning attacks\n   - Test privilege escalation via cookie manipulation\n   - Verify session hijacking prevention\n   - Test CSRF protection with SameSite cookies\n\n5. Security Headers Verification:\n   - X-Content-Type-Options: nosniff\n   - X-Frame-Options: DENY\n   - X-XSS-Protection: 1; mode=block\n   - Referrer-Policy: strict-origin-when-cross-origin\n\nAutomated Testing Commands:\n# Test cookie security\ncurl -v -X POST http://localhost:3000/api/login \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"email\":\"admin@example.com\",\"password\":\"password\"}' \\\n     --cookie-jar cookies.txt\n\n# Attempt cookie poisoning\ncurl -v -X GET http://localhost:3000/api/profile \\\n     --cookie \"sessionId=admin=true;role=admin\" \\\n     --cookie cookies.txt\n\n# Security scanning\nnpm audit\nnpx zaproxy -cmd -quickurl http://localhost:3000\n\nExpected Results:\n- All cookies should have HttpOnly, Secure, and SameSite attributes\n- Cookie data should be encrypted and signed\n- Tampering attempts should be detected and blocked\n- Session management should be secure and reliable\n- Suspicious cookie changes should trigger security alerts\n*/"
      }
    ]
  },
  {
    "pluginId": 10033,
    "title": "Directory Browsing",
    "defaultRisk": "Medium",
    "cweid": "548",
    "description": "Directory browsing is enabled, allowing users to view a listing of files and directories when no default document (index.html, index.php, etc.) is present. This can expose sensitive files, reveal application structure, and provide attackers with valuable reconnaissance information.",
    "simplified_description": "Your website allows visitors to browse through your server's file directories, like letting strangers walk through your office building and read the names on all the doors and filing cabinets. Attackers can see what files exist, find sensitive information, and learn your application's structure.",
    "solution": "Disable directory browsing in web server configuration, ensure all directories have default index files, implement proper access controls, and use security headers to prevent information disclosure.",
    "simplified_solution": "Turn off directory browsing in your web server configuration, add index.html or index.php files to all directories, and set up proper access controls to prevent unauthorized directory access.",
    "references": [
      {
        "name": "OWASP Information Disclosure Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Information_Leakage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-548: Exposure of Information Through Directory Listing",
        "url": "https://cwe.mitre.org/data/definitions/548.html"
      },
      {
        "name": "Apache Directory Browsing Documentation",
        "url": "https://httpd.apache.org/docs/2.4/mod/core.html#options"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Comprehensive Directory Browsing Prevention",
        "solution_description": "This solution provides comprehensive prevention of directory browsing by configuring web servers, implementing proper directory structures, adding security measures, and setting up monitoring to ensure directory listings cannot be accessed by unauthorized users.",
        "affected_files": "Web server configuration (.htaccess, httpd.conf, nginx.conf), directory index files, security configuration, application routing",
        "code": "# ==================================================\n# APACHE CONFIGURATION (.htaccess or httpd.conf)\n# ==================================================\n\n# Disable directory browsing globally\nOptions -Indexes\n\n# Alternative: Disable only for specific directories\n<Directory \"/var/www/html/uploads\">\n    Options -Indexes\n    AllowOverride None\n    Require all granted\n</Directory>\n\n<Directory \"/var/www/html/assets\">\n    Options -Indexes\n</Directory>\n\n# Enable only specific options\nOptions FollowSymLinks MultiViews\n\n# Prevent access to backup and hidden files\n<FilesMatch \"\\\\.(bak|backup|old|tmp|log|sql|~)$\">\n    Require all denied\n</FilesMatch>\n\n<FilesMatch \"^\\\\.\">\n    Require all denied\n</FilesMatch>\n\n# Custom error pages for better security\nErrorDocument 403 /error/403.html\nErrorDocument 404 /error/404.html\nErrorDocument 500 /error/500.html\n\n# ==================================================\n# NGINX CONFIGURATION\n# ==================================================\n\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n    root /var/www/html;\n    index index.php index.html index.htm;\n    \n    # Disable directory browsing\n    autoindex off;\n    \n    # Alternative: Disable for specific locations only\n    location /uploads/ {\n        autoindex off;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n    \n    location /assets/ {\n        autoindex off;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n    \n    location /temp/ {\n        autoindex off;\n        deny all;  # Completely block access\n    }\n    \n    # Block access to hidden files\n    location ~ /\\\\.(?!well-known).* {\n        deny all;\n        return 404;\n    }\n    \n    # Block access to backup files\n    location ~ ~$ {\n        deny all;\n        return 404;\n    }\n    \n    location ~ \\\\.(bak|backup|old|tmp|log|sql)$ {\n        deny all;\n        return 404;\n    }\n    \n    # Security headers\n    add_header X-Content-Type-Options nosniff;\n    add_header X-Frame-Options DENY;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains\";\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\";\n    \n    # PHP handling\n    location ~ \\\\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;\n    }\n    \n    # Default location handler\n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n}\n\n# ==================================================\n# SECURE DIRECTORY STRUCTURE WITH INDEX FILES\n# ==================================================\n\n# Create index files for all directories\n# Each directory should have an appropriate index file\n\n# public/index.html - Main application entry\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Application</title>\n    <meta http-equiv=\"X-Content-Type-Options\" content=\"nosniff\">\n    <meta http-equiv=\"X-Frame-Options\" content=\"DENY\">\n</head>\n<body>\n    <h1>Application Loading...</h1>\n    <script>\n        // Redirect to main application or show loading state\n        window.location.href = '/app';\n    </script>\n</body>\n</html>\n\n# assets/index.html - Block directory listing\n<!DOCTYPE html>\n<html>\n<head><title>403 Forbidden</title></head>\n<body><h1>Access Denied</h1></body>\n</html>\n\n# uploads/index.html - Block directory listing\n<!DOCTYPE html>\n<html>\n<head><title>403 Forbidden</title></head>\n<body><h1>Access Denied</h1></body>\n</html>\n\n# OR use PHP index files for better control\n# assets/index.php\n<?php\nhttp_response_code(403);\nheader('Content-Type: text/html');\necho '<!DOCTYPE html><html><head><title>403 Forbidden</title></head>';\necho '<body><h1>403 - Access Forbidden</h1><p>You don\\\\'t have permission to access this directory.</p></body></html>';\nexit;\n?>\n\n# ==================================================\n# PHP APPLICATION SECURITY CONFIGURATION\n# ==================================================\n\n<?php\n// config/security.php - Directory security configuration\nclass DirectorySecurityManager {\n    private $protectedDirectories;\n    private $allowedExtensions;\n    \n    public function __construct() {\n        $this->protectedDirectories = [\n            'uploads', 'temp', 'cache', 'logs', 'config', 'storage', 'backup'\n        ];\n        \n        $this->allowedExtensions = [\n            'jpg', 'jpeg', 'png', 'gif', 'css', 'js', 'ico', 'svg', 'woff', 'woff2'\n        ];\n    }\n    \n    /**\n     * Check if directory access should be allowed\n     */\n    public function isDirectoryAccessAllowed(string $path): bool {\n        $pathParts = explode('/', trim($path, '/'));\n        \n        foreach ($this->protectedDirectories as $protected) {\n            if (in_array($protected, $pathParts)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Validate file access in protected directories\n     */\n    public function isFileAccessAllowed(string $path): bool {\n        $pathParts = explode('/', trim($path, '/'));\n        $fileName = end($pathParts);\n        $extension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));\n        \n        // Check if file is in protected directory\n        foreach ($this->protectedDirectories as $protected) {\n            if (in_array($protected, $pathParts)) {\n                // Allow only specific file types in uploads directory\n                if ($protected === 'uploads') {\n                    return in_array($extension, $this->allowedExtensions);\n                }\n                // Deny access to other protected directories\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Generate directory index or deny access\n     */\n    public function handleDirectoryRequest(string $path): void {\n        if (!$this->isDirectoryAccessAllowed($path)) {\n            $this->denyAccess();\n            return;\n        }\n        \n        // Check if index file exists\n        $indexPath = rtrim($path, '/') . '/index.php';\n        if (file_exists($indexPath)) {\n            include $indexPath;\n            return;\n        }\n        \n        $indexPath = rtrim($path, '/') . '/index.html';\n        if (file_exists($indexPath)) {\n            include $indexPath;\n            return;\n        }\n        \n        // No index file found, deny directory listing\n        $this->denyAccess();\n    }\n    \n    private function denyAccess(): void {\n        http_response_code(403);\n        header('Content-Type: text/html');\n        echo '<!DOCTYPE html>\n<html>\n<head>\n    <title>403 Forbidden</title>\n    <meta name=\"robots\" content=\"noindex, nofollow\">\n</head>\n<body>\n    <h1>403 - Access Forbidden</h1>\n    <p>You don\\\\'t have permission to access this directory.</p>\n</body>\n</html>';\n        exit;\n    }\n}\n\n# ==================================================\n# LARAVEL/MODERN FRAMEWORK CONFIGURATION\n# ==================================================\n\n<?php\n// routes/web.php - Secure routing\nRoute::get('/', function () {\n    return view('welcome');\n});\n\n# Block direct access to sensitive directories\nRoute::any('/uploads/{path?}', function ($path = null) {\n    abort(403);\n})->where('path', '.*');\n\nRoute::any('/storage/{path?}', function ($path = null) {\n    abort(403);\n})->where('path', '.*');\n\n# Secure file access through controller\nRoute::get('/file/{filename}', 'FileController@show');\n\n<?php\n// app/Http/Controllers/FileController.php\nnamespace App\\\\Http\\\\Controllers;\n\nclass FileController extends Controller {\n    private $allowedExtensions = ['pdf', 'jpg', 'jpeg', 'png', 'gif'];\n    private $storagePath = '/var/www/storage/uploads';\n    \n    public function show($filename) {\n        // Validate file extension\n        $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n        if (!in_array($extension, $this->allowedExtensions)) {\n            abort(404);\n        }\n        \n        // Sanitize filename to prevent directory traversal\n        $filename = basename($filename);\n        $filePath = $this->storagePath . '/' . $filename;\n        \n        // Check if file exists and is readable\n        if (!file_exists($filePath) || !is_readable($filePath)) {\n            abort(404);\n        }\n        \n        // Get file mime type\n        $mimeType = mime_content_type($filePath);\n        \n        // Return file with proper headers\n        return response()->file($filePath, [\n            'Content-Type' => $mimeType,\n            'Cache-Control' => 'public, max-age=31536000',\n            'X-Content-Type-Options' => 'nosniff'\n        ]);\n    }\n}\n\n# ==================================================\n# AUTOMATED SECURITY TESTING\n# ==================================================\n\n<?php\nclass DirectoryBrowsingTester {\n    private $baseUrl;\n    private $testDirectories;\n    \n    public function __construct(string $baseUrl) {\n        $this->baseUrl = rtrim($baseUrl, '/');\n        $this->testDirectories = [\n            '/',\n            '/uploads/',\n            '/assets/',\n            '/images/',\n            '/css/',\n            '/js/',\n            '/temp/',\n            '/cache/',\n            '/logs/',\n            '/storage/',\n            '/backup/',\n            '/admin/',\n            '/config/'\n        ];\n    }\n    \n    /**\n     * Test for directory browsing vulnerabilities\n     */\n    public function testDirectoryBrowsing(): array {\n        $vulnerabilities = [];\n        \n        foreach ($this->testDirectories as $directory) {\n            $url = $this->baseUrl . $directory;\n            $result = $this->testDirectory($url, $directory);\n            \n            if ($result['vulnerable']) {\n                $vulnerabilities[] = $result;\n            }\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testDirectory(string $url, string $directory): array {\n        $context = stream_context_create([\n            'http' => [\n                'method' => 'GET',\n                'timeout' => 10,\n                'user_agent' => 'Security-Scanner/1.0',\n                'ignore_errors' => true\n            ]\n        ]);\n        \n        $response = @file_get_contents($url, false, $context);\n        \n        if ($response === false) {\n            return ['vulnerable' => false, 'directory' => $directory, 'error' => 'Connection failed'];\n        }\n        \n        // Check for directory listing indicators\n        $listingIndicators = [\n            'Index of /',\n            'Directory Listing',\n            'Parent Directory',\n            '[DIR]',\n            '<title>Index of',\n            'Apache/2.4',\n            'nginx/1.',\n            '<h1>Index of',\n            '<pre>                      '  # Apache directory listing format\n        ];\n        \n        $isDirectoryListing = false;\n        foreach ($listingIndicators as $indicator) {\n            if (stripos($response, $indicator) !== false) {\n                $isDirectoryListing = true;\n                break;\n            }\n        }\n        \n        // Additional checks for directory listing patterns\n        $patterns = [\n            '/<a href=[\"\\\\']?\\.\\.[\"\\\\']?>/',  // Parent directory link\n            '/<a href=[\"\\\\']?\\/[^\"\\\\']+[\"\\\\']?>/',  // Directory links\n            '/\\\\[DIR\\\\]/',                       // Apache [DIR] indicator\n            '/<pre>\\\\s+\\\\d+\\\\.\\.?\\\\s+/',        # File size listing pattern\n        ];\n        \n        foreach ($patterns as $pattern) {\n            if (preg_match($pattern, $response)) {\n                $isDirectoryListing = true;\n                break;\n            }\n        }\n        \n        if ($isDirectoryListing) {\n            return [\n                'vulnerable' => true,\n                'directory' => $directory,\n                'url' => $url,\n                'type' => 'Directory Browsing Enabled',\n                'evidence' => $this->extractEvidence($response)\n            ];\n        }\n        \n        return ['vulnerable' => false, 'directory' => $directory];\n    }\n    \n    private function extractEvidence(string $response): array {\n        $evidence = [];\n        \n        // Look for parent directory links\n        if (preg_match('/<a[^>]*>Parent Directory<\\\\/a>/i', $response)) {\n            $evidence[] = 'Parent Directory link found';\n        }\n        \n        // Count directory/file links\n        if (preg_match_all('/<a[^>]*href=[\"\\\\']?\\/[^\"\\\\'] + [\"\\\\']?>/i', $response, $matches)) {\n            $evidence[] = count($matches[0]) . ' file/directory links found';\n        }\n        \n        // Look for [DIR] indicators\n        if (preg_match_all('/\\\\[DIR\\\\]/', $response, $matches)) {\n            $evidence[] = count($matches[0]) . ' [DIR] indicators found';\n        }\n        \n        return $evidence;\n    }\n    \n    /**\n     * Generate security report\n     */\n    public function generateReport(array $vulnerabilities): string {\n        $report = \"Directory Browsing Security Report\\n\";\n        $report .= \"Generated: \" . date('Y-m-d H:i:s') . \"\\n\";\n        $report .= \"Base URL: {$this->baseUrl}\\n\";\n        $report .= \"================================\\\\n\\\\n\";\n        \n        if (empty($vulnerabilities)) {\n            $report .= \"✓ No directory browsing vulnerabilities found.\\n\";\n        } else {\n            $report .= \"⚠ \" . count($vulnerabilities) . \" directories allow browsing:\\n\\n\";\n            \n            foreach ($vulnerabilities as $vuln) {\n                $report .= \"Directory: {$vuln['directory']}\\n\";\n                $report .= \"URL: {$vuln['url']}\\n\";\n                $report .= \"Evidence: \" . implode(', ', $vuln['evidence']) . \"\\n\\n\";\n            }\n        }\n        \n        return $report;\n    }\n}\n\n# ==================================================\n# MONITORING AND ALERTING\n# ==================================================\n\n<?php\nclass DirectoryBrowsingMonitor {\n    private $alertEmail;\n    private $baseUrl;\n    \n    public function __construct(string $alertEmail, string $baseUrl) {\n        $this->alertEmail = $alertEmail;\n        $this->baseUrl = $baseUrl;\n    }\n    \n    public function monitorDirectoryBrowsing(): void {\n        $tester = new DirectoryBrowsingTester($this->baseUrl);\n        $vulnerabilities = $tester->testDirectoryBrowsing();\n        \n        if (!empty($vulnerabilities)) {\n            $this->sendAlert('Directory Browsing Vulnerability Detected', $vulnerabilities);\n            \n            // Log to security monitoring\n            error_log('DIRECTORY_BROWSING: ' . json_encode($vulnerabilities));\n        }\n    }\n    \n    private function sendAlert(string $subject, array $vulnerabilities): void {\n        $message = \"Security Alert: Directory browsing vulnerabilities detected!\\n\\n\";\n        \n        foreach ($vulnerabilities as $vuln) {\n            $message .= \"Directory: {$vuln['directory']}\\n\";\n            $message .= \"URL: {$vuln['url']}\\n\";\n            $message .= \"Evidence: \" . implode(', ', $vuln['evidence']) . \"\\n\\n\";\n        }\n        \n        $message .= \"Immediate action required to disable directory browsing.\\n\";\n        \n        mail($this->alertEmail, $subject, $message);\n    }\n}\n\n# Add to cron job for continuous monitoring\n# 0 */12 * * * /usr/bin/php /var/www/app/scripts/monitor-directory-browsing.php\n\n# ==================================================\n# IMMEDIATE ACTION PLAN\n# ==================================================\n\n/*\nCRITICAL STEPS (Execute within 1 hour):\n\n1. Scan for directory browsing vulnerabilities:\n   php scripts/test-directory-browsing.php https://your-domain.com\n\n2. Update web server configuration:\n   - Apache: Add \"Options -Indexes\" to .htaccess or httpd.conf\n   - Nginx: Add \"autoindex off;\" to server block\n   - Restart web server\n\n3. Add index files to directories:\n   - Create index.html or index.php for each directory\n   - Or implement proper routing in your application\n\n4. Test the fixes:\n   - Access all directories without trailing slash\n   - Verify 403 or proper page is returned\n   - Check for any remaining directory listings\n\n5. Implement access controls:\n   - Restrict access to sensitive directories (uploads, temp, cache)\n   - Use .htaccess rules for additional protection\n   - Set proper file permissions\n\n6. Set up monitoring:\n   - Implement continuous monitoring script\n   - Configure alerts for any new vulnerabilities\n   - Schedule regular security scans\n\nTIMELINE:\n- Hour 1: Scan and update web server configuration\n- Hour 2: Add index files and test fixes\n- Hour 3: Implement access controls\n- Day 1: Set up monitoring and alerting\n- Ongoing: Regular security checks\n\nVERIFICATION CHECKLIST:\n[ ] Directory browsing disabled in web server config\n[ ] All directories have appropriate index files\n[ ] Sensitive directories properly secured\n[ ] No directory listings accessible via HTTP\n[ ] Monitoring and alerting configured\n[ ] Regular security scans scheduled\n[ ] Documentation updated\n\nTESTING COMMANDS:\n# Test various directories\ncurl -I https://your-domain.com/uploads/\ncurl -I https://your-domain.com/css/\ncurl -I https://your-domain.com/temp/\n\n# Should return 403 Forbidden or proper redirect\n# NOT 200 OK with directory listing\n*/"
      }
    ]
  },
  {
    "pluginId": 10034,
    "title": "Heartbleed OpenSSL Vulnerability (Indicative)",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "Indicative detection of potential Heartbleed vulnerability based on OpenSSL version information or server responses. This suggests the system may be running a vulnerable version of OpenSSL (1.0.1 through 1.0.1f) that contains the Heartbleed bug (CVE-2014-0160).",
    "simplified_description": "Your system appears to be running a version of OpenSSL that may be vulnerable to the Heartbleed attack. This is like having a potential security weakness that could allow attackers to read sensitive information from your server's memory, including passwords, private keys, and other confidential data.",
    "solution": "Verify the actual OpenSSL version and update to a secure version (1.0.1g or later) if vulnerable. Revoke and reissue certificates if confirmed vulnerable.",
    "simplified_solution": "Check your OpenSSL version immediately and upgrade to version 1.0.1g or later if you're running 1.0.1 through 1.0.1f. Replace SSL certificates and force password changes if vulnerability is confirmed.",
    "references": [
      {
        "name": "OpenSSL Security Advisories",
        "url": "https://www.openssl.org/news/secadv/"
      },
      {
        "name": "CVE-2014-0160 Details",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0160"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Heartbleed Detection and Verification",
        "solution_description": "This solution provides comprehensive tools for detecting and verifying Heartbleed vulnerability, including automated scanning scripts, version checking utilities, and remediation validation tools. It helps distinguish between false positives and actual vulnerabilities.",
        "affected_files": "System monitoring scripts, vulnerability scanning tools, configuration management files, deployment pipelines, security testing suites, CI/CD configurations",
        "code": "#!/bin/bash\n# HEARTBLEED VULNERABILITY DETECTION AND VERIFICATION SCRIPT\n# This script detects potential Heartbleed vulnerabilities and verifies them\n\nset -euo pipefail\n\n# Configuration\nTARGET_HOST=\"${1:-localhost}\"\nTARGET_PORT=\"${2:-443}\"\nTIMEOUT=10\nLOG_FILE=\"/var/log/heartbleed_detection.log\"\n\n# Vulnerable OpenSSL versions\nVULNERABLE_VERSIONS=(\n    \"1.0.1\"\n    \"1.0.1a\"\n    \"1.0.1b\"\n    \"1.0.1c\"\n    \"1.0.1d\"\n    \"1.0.1e\"\n    \"1.0.1f\"\n)\n\n# Logging function\nlog() {\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# Error handling\nerror_exit() {\n    log \"ERROR: $1\"\n    exit 1\n}\n\n# Check if OpenSSL version is vulnerable\nis_openssl_version_vulnerable() {\n    local version=\"$1\"\n    \n    for vuln_version in \"${VULNERABLE_VERSIONS[@]}\"; do\n        if [[ \"$version\" == \"$vuln_version\" ]]; then\n            return 0\n        fi\n    done\n    \n    return 1\n}\n\n# Get OpenSSL version from target\nget_openssl_version() {\n    local host=\"$1\"\n    local port=\"$2\"\n    \n    log \"Attempting to detect OpenSSL version for $host:$port...\"\n    \n    # Method 1: Check server banner\n    local banner=$(timeout \"$TIMEOUT\" openssl s_client -connect \"$host:$port\" -showcerts 2>/dev/null | \n                  grep -i \"servertempkey\\|protocol\\|cipher\" | head -5 || true)\n    \n    if [[ -n \"$banner\" ]]; then\n        log \"Server banner info: $banner\"\n    fi\n    \n    # Method 2: Use nmap to detect SSL/TLS info\n    if command -v nmap &> /dev/null; then\n        local ssl_info=$(timeout \"$TIMEOUT\" nmap -sV --script ssl-enum-ciphers -p \"$port\" \"$host\" 2>/dev/null || true)\n        if echo \"$ssl_info\" | grep -q -i \"openssl\"; then\n            log \"Nmap detected OpenSSL: $(echo \"$ssl_info\" | grep -i openssl)\"\n        fi\n    fi\n    \n    # Method 3: Use sslscan if available\n    if command -v sslscan &> /dev/null; then\n        local scan_result=$(timeout \"$TIMEOUT\" sslscan --no-fail \"$host:$port\" 2>/dev/null || true)\n        if echo \"$scan_result\" | grep -q -i \"openssl\"; then\n            log \"SSLScan detected OpenSSL information\"\n        fi\n    fi\n    \n    return 0\n}\n\n# Test for Heartbleed vulnerability using multiple methods\ntest_heartbleed_vulnerability() {\n    local host=\"$1\"\n    local port=\"$2\"\n    \n    log \"Testing $host:$port for Heartbleed vulnerability...\"\n    \n    local vulnerable=false\n    \n    # Method 1: Use nmap ssl-heartbleed script\n    if command -v nmap &> /dev/null; then\n        log \"Testing with nmap ssl-heartbleed script...\"\n        local nmap_result\n        nmap_result=$(timeout \"$TIMEOUT\" nmap --script ssl-heartbleed -p \"$port\" \"$host\" 2>/dev/null || true)\n        \n        if echo \"$nmap_result\" | grep -q -i \"vulnerable\"; then\n            log \"❌ VULNERABLE: Nmap detected Heartbleed vulnerability\"\n            log \"Details: $nmap_result\"\n            vulnerable=true\n        elif echo \"$nmap_result\" | grep -q -i \"not vulnerable\"; then\n            log \"✅ SECURE: Nmap reports not vulnerable\"\n        else\n            log \"⚠️  INCONCLUSIVE: Nmap test was inconclusive\"\n        fi\n    fi\n    \n    # Method 2: Use testssl.sh if available\n    if command -v testssl.sh &> /dev/null; then\n        log \"Testing with testssl.sh...\"\n        local testssl_result\n        testssl_result=$(timeout \"$TIMEOUT\" testssl.sh --quiet --heartbleed \"$host:$port\" 2>/dev/null || true)\n        \n        if echo \"$testssl_result\" | grep -q -i \"vulnerable\"; then\n            log \"❌ VULNERABLE: testssl.sh detected Heartbleed vulnerability\"\n            vulnerable=true\n        elif echo \"$testssl_result\" | grep -q -i \"ok\\|not vulnerable\"; then\n            log \"✅ SECURE: testssl.sh reports not vulnerable\"\n        fi\n    fi\n    \n    # Method 3: Manual heartbeat test (if we have the tool)\n    if command -v python3 &> /dev/null; then\n        log \"Testing with custom Python heartbeat test...\"\n        python3 << EOF\nimport socket\nimport ssl\nimport struct\nimport sys\n\ntry:\n    # Connect to server\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n    \n    with socket.create_connection((\"$host\", int($port)), timeout=$TIMEOUT) as sock:\n        with context.wrap_socket(sock, server_hostname=\"$host\") as ssock:\n            # Send heartbeat request\n            hb_type = b'\\x01'  # Heartbeat request\n            hb_payload = b'HEARTBLEED' * 16  # 16 bytes of payload\n            hb_length = struct.pack('>H', len(hb_payload) + 1024)  # Request 1024 extra bytes\n            \n            heartbeat_msg = hb_type + hb_length + hb_payload\n            \n            ssock.send(heartbeat_msg)\n            response = ssock.recv(4096)\n            \n            # Check response\n            if len(response) > len(hb_payload) + 3:\n                print(\"❌ VULNERABLE: Received more data than requested (Heartbleed confirmed)\")\n                print(f\"Expected: ~{len(hb_payload) + 3} bytes, Got: {len(response)} bytes\")\n                sys.exit(1)\n            else:\n                print(\"✅ SECURE: No data leakage detected\")\n                \nexcept Exception as e:\n    print(f\"⚠️  INCONCLUSIVE: Test failed with error: {e}\")\n    sys.exit(0)\nEOF\n        local python_result=$?\n        \n        if [[ $python_result -eq 1 ]]; then\n            vulnerable=true\n        fi\n    fi\n    \n    return $([[ \"$vulnerable\" == true ]] && echo 1 || echo 0)\n}\n\n# Generate comprehensive report\ngenerate_detection_report() {\n    local host=\"$1\"\n    local port=\"$2\"\n    local is_vulnerable=\"$3\"\n    local report_file=\"/tmp/heartbleed_detection_report_$(date +%Y%m%d_%H%M%S).txt\"\n    \n    cat > \"$report_file\" << EOF\nHeartbleed Vulnerability Detection Report\n=========================================\nDate: $(date)\nTarget: $host:$port\n\nDETECTION SUMMARY:\n==================\n\nHost Information:\n- Target: $host\n- Port: $port\n- Detection Method: Multi-tool verification\n- Status: $([ \"$is_vulnerable\" == true ] && echo \"VULNERABLE\" || echo \"SECURE/INCONCLUSIVE\")\n\nTools Used:\n- OpenSSL Version Detection\n- Nmap SSL Scripts\n- TestSSL.sh (if available)\n- Custom Heartbeat Test\n\nRECOMMENDATIONS:\n================\n\nEOF\n    \n    if [[ \"$is_vulnerable\" == true ]]; then\n        cat >> \"$report_file\" << EOF\nIMMEDIATE ACTIONS REQUIRED:\n\n1. UPGRADE OPENSSL (CRITICAL):\n   - Update to OpenSSL 1.0.1g or later\n   - Restart all affected services\n   - Verify upgrade was successful\n\n2. CERTIFICATE ROTATION:\n   - Generate new SSL certificates\n   - Revoke old certificates\n   - Update web server configurations\n\n3. SECURITY INCIDENT RESPONSE:\n   - Assume all data may be compromised\n   - Force all users to change passwords\n   - Monitor for suspicious activity\n   - Review access logs\n\n4. SYSTEM ASSESSMENT:\n   - Scan for other vulnerabilities\n   - Review security configurations\n   - Update all dependencies\n   - Implement security monitoring\n\nDETAILED REMEDIATION STEPS:\n- See comprehensive remediation script: heartbleed_remediation.sh\n- Follow vendor-specific update instructions\n- Test all services after patching\n- Monitor for performance issues\n\nEOF\n    else\n        cat >> \"$report_file\" << EOF\nSECURITY STATUS: No immediate Heartbleed vulnerability detected\n\nRECOMMENDED ACTIONS:\n1. Continue regular security monitoring\n2. Keep OpenSSL updated\n3. Schedule regular vulnerability scans\n4. Maintain security best practices\n\nONGOING MONITORING:\n- Implement automated security scanning\n- Monitor OpenSSL security advisories\n- Keep systems patched\n- Regular security audits\n\nEOF\n    fi\n    \n    cat >> \"$report_file\" << EOF\nTECHNICAL DETAILS:\n==================\n\nHeartbleed (CVE-2014-0160):\n- CWE: CWE-200 (Information Exposure)\n- CVSS Score: 7.5 (High)\n- Affected Versions: OpenSSL 1.0.1 through 1.0.1f\n- Fixed in: OpenSSL 1.0.1g and later\n\nDetection Methods Used:\n- Version fingerprinting\n- Active vulnerability testing\n- SSL/TLS analysis\n- Custom heartbeat verification\n\nCONTACT INFORMATION:\n- Security Team: security@company.com\n- System Administrator: admin@company.com\n- Incident Response: incident@company.com\n\nLOG FILE: $LOG_FILE\nReport Generated: $(date)\nEOF\n    \n    log \"Detection report generated: $report_file\"\n    echo \"Report available at: $report_file\"\n}\n\n# Continuous monitoring setup\nsetup_continuous_monitoring() {\n    local host=\"$1\"\n    local port=\"$2\"\n    \n    log \"Setting up continuous monitoring for $host:$port...\"\n    \n    # Create monitoring script\n    cat > \"/usr/local/bin/monitor_heartbleed_$host_$port.sh\" << EOF\n#!/bin/bash\n# Continuous Heartbleed monitoring for $host:$port\n\nLOG_FILE=\"/var/log/heartbleed_monitor_${host}_${port}.log\"\nDATE=$(date '+%Y-%m-%d %H:%M:%S')\nALERT_EMAIL=\"security@company.com\"\n\n# Function to send alert\nsend_alert() {\n    local message=\"\\$1\"\n    echo \"[\\$DATE] ALERT: \\$message\" >> \"\\$LOG_FILE\"\n    echo \"\\$message\" | mail -s \"Heartbleed Alert for $host:$port\" \"\\$ALERT_EMAIL\" || true\n}\n\n# Check if target is responsive\nif ! nc -z -w5 \"$host\" \"$port\" 2>/dev/null; then\n    echo \"[\\$DATE] INFO: Target $host:$port is not responsive\" >> \"\\$LOG_FILE\"\n    exit 0\nfi\n\n# Quick vulnerability check\nif command -v nmap &> /dev/null; then\n    nmap_result=\\$(timeout 30 nmap --script ssl-heartbleed -p \"$port\" \"$host\" 2>/dev/null || echo \"timeout\")\n    \n    if echo \"\\$nmap_result\" | grep -q -i \"vulnerable\"; then\n        send_alert \"Heartbleed vulnerability detected on $host:$port\"\n    elif echo \"\\$nmap_result\" | grep -q -i \"not vulnerable\"; then\n        echo \"[\\$DATE] INFO: No Heartbleed vulnerability detected\" >> \"\\$LOG_FILE\"\n    else\n        echo \"[\\$DATE] WARN: Inconclusive test result\" >> \"\\$LOG_FILE\"\n    fi\nelse\n    echo \"[\\$DATE] WARN: nmap not available for testing\" >> \"\\$LOG_FILE\"\nfi\nEOF\n    \n    chmod +x \"/usr/local/bin/monitor_heartbleed_$host_$port.sh\"\n    \n    # Add to crontab for every 4 hours\n    (crontab -l 2>/dev/null; echo \"0 */4 * * * /usr/local/bin/monitor_heartbleed_$host_$port.sh\") | crontab -\n    \n    log \"Continuous monitoring configured for $host:$port\"\n}\n\n# Main execution function\nmain() {\n    log \"Starting Heartbleed vulnerability detection for $TARGET_HOST:$TARGET_PORT...\"\n    \n    # Get OpenSSL version information\n    get_openssl_version \"$TARGET_HOST\" \"$TARGET_PORT\"\n    \n    # Test for actual vulnerability\n    log \"Beginning comprehensive vulnerability testing...\"\n    if test_heartbleed_vulnerability \"$TARGET_HOST\" \"$TARGET_PORT\"; then\n        log \"❌ HEARTBLEED VULNERABILITY CONFIRMED\"\n        \n        # Generate urgent report\n        generate_detection_report \"$TARGET_HOST\" \"$TARGET_PORT\" true\n        \n        # Set up immediate monitoring\n        setup_continuous_monitoring \"$TARGET_HOST\" \"$TARGET_PORT\"\n        \n        log \"CRITICAL: Take immediate remediation action!\"\n        log \"Run heartbleed_remediation.sh for comprehensive fix.\"\n        \n        exit 1\n    else\n        log \"✅ No Heartbleed vulnerability detected (or inconclusive)\"\n        generate_detection_report \"$TARGET_HOST\" \"$TARGET_PORT\" false\n        \n        # Still set up monitoring for ongoing vigilance\n        setup_continuous_monitoring \"$TARGET_HOST\" \"$TARGET_PORT\"\n        \n        exit 0\n    fi\n}\n\n# Execute main function if script is run directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n    main \"$@\"\nfi\n\n# =========================================================\n# PYTHON HEARTBLEED DETECTION MODULE\n# =========================================================\n\n# heartbleed_detector.py\n\"\"\"\nPython module for Heartbleed vulnerability detection\n\"\"\"\n\nimport socket\nimport ssl\nimport struct\nimport sys\nimport logging\nfrom typing import Optional, Tuple\n\nclass HeartbleedDetector:\n    def __init__(self, timeout: int = 10):\n        self.timeout = timeout\n        self.logger = logging.getLogger(__name__)\n        \n    def test_vulnerability(self, host: str, port: int = 443) -> Tuple[bool, str]:\n        \"\"\"\n        Test for Heartbleed vulnerability\n        \n        Args:\n            host: Target hostname or IP\n            port: Target port (default: 443)\n            \n        Returns:\n            Tuple[bool, str]: (is_vulnerable, details)\n        \"\"\"\n        try:\n            # Create SSL context\n            context = ssl.create_default_context()\n            context.check_hostname = False\n            context.verify_mode = ssl.CERT_NONE\n            \n            # Connect and test\n            with socket.create_connection((host, port), timeout=self.timeout) as sock:\n                with context.wrap_socket(sock, server_hostname=host) as ssock:\n                    return self._perform_heartbeat_test(ssock)\n                    \n        except Exception as e:\n            return False, f\"Test failed: {str(e)}\"\n    \n    def _perform_heartbeat_test(self, ssl_socket) -> Tuple[bool, str]:\n        \"\"\"\n        Perform the actual heartbeat test\n        \"\"\"\n        try:\n            # Construct malicious heartbeat request\n            hb_type = b'\\x01'  # Heartbeat request\n            hb_payload = b'HEARTBLEED_TEST' * 8  # 128 bytes of payload\n            # Request much more data than we actually send (malicious)\n            hb_length = struct.pack('>H', len(hb_payload) + 1024)\n            \n            heartbeat_msg = hb_type + hb_length + hb_payload\n            \n            # Send the malicious request\n            ssl_socket.send(heartbeat_msg)\n            \n            # Receive response\n            response = ssl_socket.recv(4096)\n            \n            # Analyze response\n            expected_length = len(hb_payload) + 3  # 1 byte type + 2 bytes length + payload\n            \n            if len(response) > expected_length:\n                extra_data = response[expected_length:]\n                # Check if extra data looks like memory contents\n                if self._looks_like_memory_leak(extra_data):\n                    return True, f\"Heartbleed confirmed! Got {len(response)} bytes (expected {expected_length})\"\n                else:\n                    return False, f\"Unexpected response size but no clear memory leak: {len(response)} bytes\"\n            else:\n                return False, \"No data leakage detected\"\n                \n        except Exception as e:\n            return False, f\"Heartbeat test failed: {str(e)}\"\n    \n    def _looks_like_memory_leak(self, data: bytes) -> bool:\n        \"\"\"\n        Check if the extra data looks like memory contents\n        \"\"\"\n        try:\n            # Try to decode as text\n            text_data = data.decode('utf-8', errors='ignore')\n            \n            # Look for common memory content patterns\n            suspicious_patterns = [\n                'pass', 'user', 'key', 'secret', 'token',\n                'GET ', 'POST ', 'HTTP/', 'Content-',\n                'Cookie:', 'Authorization:', 'Bearer '\n            ]\n            \n            for pattern in suspicious_patterns:\n                if pattern.lower() in text_data.lower():\n                    return True\n            \n            # Check for binary patterns that suggest memory\n            if len(set(data)) < len(data) * 0.1:  # Low entropy suggests structured data\n                return True\n                \n        except UnicodeDecodeError:\n            # Binary data with high entropy suggests memory\n            return len(set(data)) > len(data) * 0.5\n        \n        return False\n    \n    def scan_multiple_hosts(self, hosts: list) -> dict:\n        \"\"\"\n        Scan multiple hosts for Heartbleed vulnerability\n        \n        Args:\n            hosts: List of (host, port) tuples\n            \n        Returns:\n            Dict with scan results\n        \"\"\"\n        results = {}\n        \n        for host, port in hosts:\n            self.logger.info(f\"Testing {host}:{port}\")\n            is_vulnerable, details = self.test_vulnerability(host, port)\n            results[f\"{host}:{port}\"] = {\n                'vulnerable': is_vulnerable,\n                'details': details\n            }\n        \n        return results\n\n# Usage example\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    \n    detector = HeartbleedDetector()\n    \n    if len(sys.argv) < 2:\n        print(\"Usage: python heartbleed_detector.py <host> [port]\")\n        sys.exit(1)\n    \n    host = sys.argv[1]\n    port = int(sys.argv[2]) if len(sys.argv) > 2 else 443\n    \n    is_vulnerable, details = detector.test_vulnerability(host, port)\n    \n    if is_vulnerable:\n        print(f\"❌ VULNERABLE: {details}\")\n        sys.exit(1)\n    else:\n        print(f\"✅ SECURE: {details}\")\n        sys.exit(0)\n\n# =========================================================\n# INTEGRATION WITH SECURITY TOOLS\n# =========================================================\n\n# Jenkinsfile example for automated testing\n\"\"\"\npipeline {\n    agent any\n    \n    stages {\n        stage('Heartbleed Detection') {\n            steps {\n                script {\n                    sh './heartbleed_detector.sh production-server.com 443'\n                    sh './heartbleed_detector.sh staging-server.com 443'\n                    \n                    // Archive results\n                    archiveArtifacts artifacts: '*.txt', allowEmptyArchive: true\n                    \n                    // Fail build if vulnerability found\n                    script {\n                        def exitCode = sh(script: './heartbleed_detector.sh production-server.com 443', returnStatus: true)\n                        if (exitCode != 0) {\n                            error 'Heartbleed vulnerability detected! Build failed.'\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            // Send notifications\n            emailext (\n                subject: \"Heartbleed Scan Results - ${env.JOB_NAME} #${env.BUILD_NUMBER}\",\n                body: \"Heartbleed vulnerability scan completed. Check build logs for details.\",\n                to: \"security-team@company.com\"\n            )\n        }\n    }\n}\n\"\"\"\n\n# =========================================================\n# MONITORING DASHBOARD CONFIGURATION\n# =========================================================\n\n# Grafana dashboard JSON snippet for Heartbleed monitoring\n\"\"\"\n{\n  \"dashboard\": {\n    \"title\": \"Heartbleed Vulnerability Monitoring\",\n    \"panels\": [\n      {\n        \"title\": \"Vulnerability Status\",\n        \"type\": \"stat\",\n        \"targets\": [\n          {\n            \"expr\": \"heartbleed_vulnerable\",\n            \"legendFormat\": \"Vulnerable\"\n          }\n        ],\n        \"fieldConfig\": {\n          \"defaults\": {\n            \"thresholds\": {\n              \"steps\": [\n                {\"color\": \"green\", \"value\": null},\n                {\"color\": \"red\", \"value\": 1}\n              ]\n            }\n          }\n        }\n      },\n      {\n        \"title\": \"Scan Results Timeline\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(heartbleed_scans_total[5m])\",\n            \"legendFormat\": \"Scan Rate\"\n          }\n        ]\n      }\n    ]\n  }\n}\n\"\"\"\n"
      }
    ]
  },
  {
    "pluginId": 10035,
    "title": "Strict-Transport-Security Header",
    "defaultRisk": "Medium",
    "cweid": 523,
    "description": "The HTTP Strict Transport Security (HSTS) header is not set, which means the application does not enforce HTTPS connections. This allows man-in-the-middle attacks where attackers can downgrade connections to HTTP and intercept, modify, or steal sensitive data.",
    "simplified_description": "Your website is missing a critical security header that forces browsers to use secure HTTPS connections. Without this protection, attackers can trick browsers into using unencrypted HTTP connections, allowing them to eavesdrop on communications, steal passwords and credit card numbers, or inject malicious content into your pages.",
    "solution": "Implement the HTTP Strict Transport Security (HSTS) header to enforce HTTPS connections for all communication. Configure appropriate max-age values and include subdomains as needed. Consider preload inclusion for maximum security.",
    "simplified_solution": "Add a security header to your web server configuration that tells browsers to always use HTTPS connections. This ensures all user data remains encrypted and protected from interception. Start with a short duration (like 1 week) and gradually increase to longer periods (6 months to 1 year) once you've verified everything works correctly.",
    "references": [
      {
        "name": "OWASP HSTS Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html"
      },
      {
        "name": "RFC 6797 - HTTP Strict Transport Security",
        "url": "https://tools.ietf.org/html/rfc6797"
      },
      {
        "name": "HSTS Preload List",
        "url": "https://hstspreload.org/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Apache HTTP Server Configuration",
        "solution_description": "This solution configures HSTS for Apache HTTP Server using mod_headers. The configuration includes proper max-age values, includeSubDomains for comprehensive coverage, and preload for maximum security. The implementation supports both HTTP/2 and HTTP/1.1, with proper fallback mechanisms for older browsers.",
        "affected_files": "/etc/apache2/sites-available/*.conf, /etc/httpd/conf.d/*.conf, .htaccess files, Apache virtual host configurations",
        "code": "# Apache HTTP Server HSTS Configuration\n# Add to your site configuration or .htaccess\n\n# Enable headers module if not already enabled\nLoadModule headers_module modules/mod_headers.so\n\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # SSL Configuration\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/example.com.crt\n    SSLCertificateKeyFile /etc/ssl/private/example.com.key\n    \n    # HSTS Header Implementation\n    # max-age=31536000 = 1 year\n    # includeSubDomains = Apply to all subdomains\n    # preload = Include in browser preload list (optional)\n    Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n    \n    # Alternative: Conservative approach (6 months)\n    # Header always set Strict-Transport-Security \"max-age=15768000; includeSubDomains\"\n    \n    # Alternative: Development environment (1 hour)\n    # Header always set Strict-Transport-Security \"max-age=3600\"\n</VirtualHost>\n\n# HTTP to HTTPS Redirect (port 80)\n<VirtualHost *:80>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # Redirect all HTTP traffic to HTTPS\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]\n    \n    # Alternative redirect method\n    # Redirect permanent / https://example.com/\n</VirtualHost>\n\n# ======================================\n# NGINX CONFIGURATION\n# ======================================\n\n# Nginx HSTS Configuration\n# Add to your nginx.conf or site-specific config\n\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    \n    # Redirect all HTTP to HTTPS\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com www.example.com;\n    \n    # SSL Configuration\n    ssl_certificate /etc/ssl/certs/example.com.crt;\n    ssl_certificate_key /etc/ssl/private/example.com.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    \n    # HSTS Header Implementation\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\n    \n    # Alternative: Conservative approach\n    # add_header Strict-Transport-Security \"max-age=15768000; includeSubDomains\" always;\n    \n    # Alternative: Development environment\n    # add_header Strict-Transport-Security \"max-age=3600\" always;\n    \n    # Your other server configuration\n    root /var/www/html;\n    index index.html;\n}\n\n# ======================================\n# IIS CONFIGURATION\n# ======================================\n\n# IIS Web.config HSTS Configuration\n# Add this to your Web.config file\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <!-- HSTS Header Implementation -->\n        <add name=\"Strict-Transport-Security\" \n             value=\"max-age=31536000; includeSubDomains; preload\" />\n        \n        <!-- Alternative: Conservative approach -->\n        <!-- <add name=\"Strict-Transport-Security\" value=\"max-age=15768000; includeSubDomains\" /> -->\n        \n        <!-- Alternative: Development environment -->\n        <!-- <add name=\"Strict-Transport-Security\" value=\"max-age=3600\" /> -->\n      </customHeaders>\n    </httpProtocol>\n    \n    <!-- URL Rewrite for HTTP to HTTPS Redirect -->\n    <rewrite>\n      <rules>\n        <rule name=\"Redirect to HTTPS\" stopProcessing=\"true\">\n          <match url=\"(.*)\" />\n          <conditions>\n            <add input=\"{HTTPS}\" pattern=\"off\" ignoreCase=\"true\" />\n          </conditions>\n          <action type=\"Redirect\" url=\"https://{HTTP_HOST}/{R:1}\" \n                  redirectType=\"Permanent\" />\n        </rule>\n      </rules>\n    </rewrite>\n  </system.webServer>\n</configuration>\n\n# ======================================\n# NODE.JS/EXPRESS CONFIGURATION\n# ======================================\n\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Basic HSTS configuration\napp.use(helmet.hsts({\n    maxAge: 31536000,        // 1 year in seconds\n    includeSubDomains: true,  // Apply to subdomains\n    preload: true            // Include in preload list\n}));\n\n// Alternative: Manual header setting\napp.use((req, res, next) => {\n    res.setHeader(\n        'Strict-Transport-Security', \n        'max-age=31536000; includeSubDomains; preload'\n    );\n    next();\n});\n\n// Development environment configuration\nif (process.env.NODE_ENV === 'development') {\n    app.use(helmet.hsts({\n        maxAge: 3600,           // 1 hour for development\n        includeSubDomains: false\n    }));\n}\n\n// ======================================\n# CLOUD CONFIGURATION EXAMPLES\n# ======================================\n\n# AWS CloudFront Distribution HSTS\n# Add to your CloudFront distribution behavior\n\n{\n  \"DistributionConfig\": {\n    \"DefaultCacheBehavior\": {\n      \"ViewerProtocolPolicy\": \"redirect-to-https\",\n      \"TrustedSigners\": {\n        \"Enabled\": false,\n        \"Quantity\": 0\n      },\n      \"ForwardedValues\": {\n        \"QueryString\": false,\n        \"Cookies\": { \"Forward\": \"none\" }\n      },\n      \"MinTTL\": 0\n    },\n    \"CacheBehaviors\": {\n      \"Quantity\": 1,\n      \"Items\": [\n        {\n          \"PathPattern\": \"*\",\n          \"ViewerProtocolPolicy\": \"https-only\",\n          \"TrustedSigners\": { \"Enabled\": false, \"Quantity\": 0 },\n          \"ForwardedValues\": {\n            \"QueryString\": true,\n            \"Cookies\": { \"Forward\": \"none\" }\n          },\n          \"MinTTL\": 0,\n          \"Compress\": true,\n          \"Headers\": [\n            \"Strict-Transport-Security\"\n          ]\n        }\n      ]\n    }\n  }\n}\n\n# ======================================\n# TESTING AND VERIFICATION\n# ======================================\n\n# Test HSTS Implementation\ncurl -I https://example.com\n\n# Expected Response Header:\n# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload\n\n# Test HTTP to HTTPS Redirect\ncurl -I http://example.com\n\n# Expected Response:\n# HTTP/1.1 301 Moved Permanently\n# Location: https://example.com/\n\n# ======================================\n# BROWSER TESTING\n# ======================================\n\n# Chrome DevTools:\n# 1. Open Developer Tools\n# 2. Go to Network tab\n# 3. Refresh the page\n# 4. Check Response Headers for Strict-Transport-Security\n\n# Firefox Developer Tools:\n# 1. Open Developer Tools\n# 2. Go to Network tab\n# 3. Select the first request\n# 4. Check Response Headers\n\n# ======================================\n# HSTS PRELOAD SUBMISSION\n# ======================================\n\n# To submit your site to HSTS preload list:\n# 1. Visit https://hstspreload.org/\n# 2. Enter your domain name\n# 3. Check if your site meets requirements\n# 4. Submit for inclusion\n\n# Requirements for preload:\n# - Valid SSL certificate\n# - Redirect all HTTP to HTTPS\n# - Serve HSTS header on HTTPS\n# - includeSubDomains directive\n# - max-age must be at least 31536000 (1 year)\n\n# ======================================\n# MAINTENANCE AND MONITORING\n# ======================================\n\n# Regular monitoring script (Bash)\n#!/bin/bash\n\n# HSTS Compliance Checker\ncheck_hsts() {\n    local domain=\"$1\"\n    echo \"Checking HSTS for $domain...\"\n    \n    # Check HTTPS response\n    https_response=$(curl -s -I \"https://$domain\" 2>/dev/null | grep -i \"strict-transport-security\")\n    \n    if [[ -n \"$https_response\" ]]; then\n        echo \"✓ HSTS header found: $https_response\"\n        \n        # Check max-age\n        if [[ \"$https_response\" =~ max-age=([0-9]+) ]]; then\n            max_age=${BASH_REMATCH[1]}\n            if [[ $max_age -ge 31536000 ]]; then\n                echo \"✓ Max-age is sufficient: $max_age seconds\"\n            else\n                echo \"⚠ Max-age is low: $max_age seconds (recommend 31536000+)\"\n            fi\n        fi\n        \n        # Check includeSubDomains\n        if [[ \"$https_response\" =~ includeSubDomains ]]; then\n            echo \"✓ includeSubDomains directive found\"\n        else\n            echo \"ℹ includeSubDomains directive not found\"\n        fi\n        \n        # Check preload\n        if [[ \"$https_response\" =~ preload ]]; then\n            echo \"✓ preload directive found\"\n        else\n            echo \"ℹ preload directive not found\"\n        fi\n    else\n        echo \"✗ HSTS header NOT found\"\n    fi\n    \n    # Check HTTP to HTTPS redirect\n    http_status=$(curl -s -o /dev/null -w \"%{http_code}\" \"http://$domain\")\n    if [[ \"$http_status\" == \"301\" ]] || [[ \"$http_status\" == \"302\" ]]; then\n        echo \"✓ HTTP to HTTPS redirect working (Status: $http_status)\"\n    else\n        echo \"✗ HTTP to HTTPS redirect not working (Status: $http_status)\"\n    fi\n}\n\n# Usage\ncheck_hsts \"example.com\"\n\n# ======================================\n# COMMON PITFALLS AND SOLUTIONS\n# ======================================\n\n# 1. HSTS on HTTP responses (WRONG):\n#    HSTS should only be sent on HTTPS connections\n\n# 2. Short max-age values:\n#    Use at least 6 months (15768000) for production\n\n# 3. Missing HTTP to HTTPS redirect:\n#    Always redirect HTTP traffic to HTTPS\n\n# 4. SSL certificate issues:\n#    Ensure valid SSL certificate before enabling HSTS\n\n# 5. includeSubDomains without testing:\n#    Test all subdomains before enabling\n\n# 6. Setting max-age too high initially:\n#    Start with shorter duration, increase gradually\n\n# ======================================\n# ROLLBACK PROCEDURES\n# ======================================\n\n# If you encounter issues with HSTS:\n\n# 1. Reduce max-age immediately:\n#    Set max-age to 0 to disable HSTS\n#    Header always set Strict-Transport-Security \"max-age=0\"\n\n# 2. Remove preload submission:\n#    Contact browser vendors if already preloaded\n\n# 3. Monitor for issues:\n#    Check server logs for SSL/TLS errors\n#    Monitor user feedback and error rates\n\n# 4. Gradual re-implementation:\n#    Start with conservative settings\n#    Test thoroughly before full deployment"
      }
    ]
  },
  {
    "pluginId": 10036,
    "title": "HTTP Server Response Header",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The web server is revealing its identity through HTTP response headers such as Server, X-Powered-By, and similar headers. This information disclosure provides attackers with valuable intelligence about the server software, version, and underlying technology stack, facilitating targeted attacks against known vulnerabilities.",
    "simplified_description": "Your website is announcing what server software it uses, like putting a sign on your house saying what kind of locks you have. Attackers use this information to search for specific vulnerabilities in your server software and launch targeted attacks against your known weaknesses.",
    "solution": "Remove or obscure server identification headers to prevent information disclosure. Configure web servers and application frameworks to suppress version information and technology identification. Implement proper header filtering at the web server, application, and reverse proxy levels.",
    "simplified_solution": "Hide your server software information by configuring your web server and application to remove identifying headers. This makes it harder for attackers to identify specific vulnerabilities in your technology stack. Update your server configuration files and application settings to suppress server signatures.",
    "references": [
      {
        "name": "OWASP Information Exposure Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Information_Exposure_Cheat_Sheet.html"
      },
      {
        "name": "NIST SP 800-53 Rev 4",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Apache HTTP Server Configuration",
        "solution_description": "This comprehensive solution for Apache HTTP Server removes server identification headers at multiple levels. It includes Apache core configuration, module-based solutions for various technologies (PHP, ASP.NET, Java), reverse proxy configurations, and application-level header suppression. The implementation works across Apache 2.2 and 2.4 versions.",
        "affected_files": "/etc/apache2/apache2.conf, /etc/httpd/conf/httpd.conf, /etc/apache2/conf-available/security.conf, .htaccess files, php.ini, application configuration files",
        "code": "# Apache HTTP Server - Header Security Configuration\n\n# ======================================\n# APACHE CORE CONFIGURATION\n# ======================================\n\n# Method 1: Disable Server Tokens (Global)\n# Add to httpd.conf or apache2.conf\n\n# Suppress server information in headers and error pages\nServerTokens Prod\n# Options: Full | OS | Minimal | Minor | Major | Prod\n# Prod = Apache (no version, no OS)\n\n# Suppress server signature on error pages\nServerSignature Off\n\n# ======================================\n# APACHE 2.4 SECURITY MODULES\n# ======================================\n\n# Ensure required modules are loaded\nLoadModule headers_module modules/mod_headers.so\nLoadModule rewrite_module modules/mod_rewrite.so\n\n# Remove server headers\n<IfModule mod_headers.c>\n    # Remove Server header (Apache 2.4+ with mod_security)\n    Header unset Server\n    \n    # Remove X-Powered-By header (PHP, ASP.NET, etc.)\n    Header unset X-Powered-By\n    \n    # Remove X-AspNet-Version header\n    Header unset X-AspNet-Version\n    \n    # Remove X-AspNetMvc-Version header\n    Header unset X-AspNetMvc-Version\n    \n    # Remove X-Generator header (CMS, frameworks)\n    Header unset X-Generator\n    \n    # Remove X-Drupal-Cache header\n    Header unset X-Drupal-Cache\n    \n    # Remove X-Varnish header (if using Varnish cache)\n    Header unset X-Varnish\n    \n    # Remove X-Pingback header\n    Header unset X-Pingback\n    \n    # Remove X-Mod-Pagespeed header\n    Header unset X-Mod-Pagespeed\n    \n    # Remove X-Content-Digest header\n    Header unset X-Content-Digest\n    \n    # Remove other common headers that reveal technology\n    Header unset X-Mod-Pagespeed\n    Header unset X-Powered-By\n    Header unset X-Generator\n    Header unset X-Drupal-Cache\n    Header unset X-Varnish\n    Header unset X-Pingback\n    Header unset X-WP-Total\n    Header unset X-WP-TotalPages\n</IfModule>\n\n# ======================================\n# PHP CONFIGURATION\n# ======================================\n\n# Method 1: php.ini Configuration\n# Add to php.ini or custom php.ini\n\n; Expose PHP version\nexpose_php = Off\n\n; Disable PHP signature in headers\n; This removes the X-Powered-By: PHP/X.Y.Z header\n\n# Method 2: .htaccess Configuration\n# Add to .htaccess file\n\n<IfModule mod_php7.c>\n    php_flag expose_php off\n</IfModule>\n\n<IfModule mod_php8.c>\n    php_flag expose_php off\n</IfModule>\n\n# ======================================\n# ASP.NET CONFIGURATION\n# ======================================\n\n# Web.config file\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <system.web>\n    <!-- Remove ASP.NET version header -->\n    <httpRuntime enableVersionHeader=\"false\" />\n    \n    <!-- Custom error pages to prevent information disclosure -->\n    <customErrors mode=\"RemoteOnly\" defaultRedirect=\"Error.aspx\">\n      <error statusCode=\"404\" redirect=\"NotFound.aspx\" />\n      <error statusCode=\"500\" redirect=\"ServerError.aspx\" />\n    </customErrors>\n  </system.web>\n  \n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <!-- Remove ASP.NET headers -->\n        <remove name=\"X-Powered-By\" />\n        <remove name=\"X-AspNet-Version\" />\n        <remove name=\"X-AspNetMvc-Version\" />\n        \n        <!-- Optionally add fake headers for misdirection -->\n        <!-- <add name=\"X-Powered-By\" value=\"CustomServer/1.0\" /> -->\n      </customHeaders>\n    </httpProtocol>\n    \n    <!-- URL Rewrite to hide file extensions and paths -->\n    <rewrite>\n      <rules>\n        <rule name=\"Hide Server Headers\" stopProcessing=\"true\">\n          <match url=\".*\" />\n          <serverVariables>\n            <set name=\"RESPONSE_Server\" value=\"\" />\n            <set name=\"RESPONSE_X-Powered-By\" value=\"\" />\n          </serverVariables>\n          <action type=\"None\" />\n        </rule>\n      </rules>\n    </rewrite>\n  </system.webServer>\n</configuration>\n\n# ======================================\n# JAVA APPLICATION SERVERS\n# ======================================\n\n# Tomcat server.xml configuration\n<!-- Add to server.xml inside Connector element -->\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n           connectionTimeout=\"20000\"\n           redirectPort=\"8443\"\n           server=\"Apache-Coyote/1.1\"  <!-- Custom or empty -->\n           xpoweredBy=\"false\" />\n\n# Jetty embedded server configuration\n# Java code to remove headers\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.handler.ContextHandlerCollection;\nimport org.eclipse.jetty.servlet.ServletContextHandler;\nimport org.eclipse.jetty.servlets.HeaderFilter;\n\nServletContextHandler context = new ServletContextHandler();\ncontext.setContextPath(\"/\");\n\n// Add header filter\nHeaderFilter headerFilter = new HeaderFilter();\nheaderFilter.addInitParameter(\"Server\", \"\");\nheaderFilter.addInitParameter(\"X-Powered-By\", \"\");\nheaderFilter.addInitParameter(\"X-Content-Type-Options\", \"nosniff\");\n\ncontext.addFilter(HeaderFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n# ======================================\n# NGINX CONFIGURATION\n# ======================================\n\n# nginx.conf or site-specific config\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    \n    # Hide Nginx version\n    server_tokens off;\n    \n    # Remove headers\n    more_clear_headers Server;\n    more_clear_headers X-Powered-By;\n    more_clear_headers X-AspNet-Version;\n    more_clear_headers X-AspNetMvc-Version;\n    more_clear_headers X-Generator;\n    \n    # Alternative with headers module (nginx 1.9.13+)\n    proxy_hide_header X-Powered-By;\n    proxy_hide_header X-AspNet-Version;\n    proxy_hide_header X-AspNetMvc-Version;\n    proxy_hide_header Server;\n    \n    # Your site configuration\n    root /var/www/html;\n    index index.html;\n}\n\n# ======================================\n# NODE.JS/EXPRESS CONFIGURATION\n# ======================================\n\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Remove Express header and other identifying headers\napp.use(helmet.hidePoweredBy());  // Removes X-Powered-By\n\n// Custom middleware to remove Server header\napp.use((req, res, next) => {\n    res.removeHeader('Server');\n    res.removeHeader('X-Powered-By');\n    \n    // Set custom server header (optional)\n    // res.setHeader('Server', 'CustomServer');\n    \n    next();\n});\n\n// Alternative with express-secure-headers\nconst secureHeaders = require('express-secure-headers');\napp.use(secureHeaders({\n    server: {\n        info: null  // Remove server header\n    },\n    poweredBy: {\n        setTo: null  // Remove X-Powered-By\n    }\n}));\n\n# ======================================\n# REVERSE PROXY CONFIGURATION\n# ======================================\n\n# HAProxy Configuration\nglobal\n    daemon\n    maxconn 4096\n\ndefaults\n    mode http\n    timeout connect 5000ms\n    timeout client 50000ms\n    timeout server 50000ms\n\nfrontend http_frontend\n    bind *:80\n    redirect scheme https code 301\n\nfrontend https_frontend\n    bind *:443 ssl crt /etc/ssl/certs/example.com.pem\n    \n    # Remove server headers\n    http-response del-header Server\n    http-response del-header X-Powered-By\n    http-response del-header X-AspNet-Version\n    http-response del-header X-AspNetMvc-Version\n    http-response del-header X-Generator\n    \n    default_backend web_servers\n\nbackend web_servers\n    balance roundrobin\n    server web1 10.0.0.1:80 check\n    server web2 10.0.0.2:80 check\n\n# ======================================\n# MOD_SECURITY CONFIGURATION\n# ======================================\n\n# mod_security.conf\nSecRuleEngine On\n\n# Remove server headers\nSecRule RESPONSE_HEADERS:Server \"@streq .*\" \"phase:1,log,deny,id:1001,severity:4,msg:'Server header found'\"\nSecRule RESPONSE_HEADERS:X-Powered-By \"@streq .*\" \"phase:1,log,deny,id:1002,severity:4,msg:'X-Powered-By header found'\"\n\n# Alternative: Remove headers silently\nSecAction \"phase:1,nolog,pass,id:1003,t:none,setvar:tx.server_headers=0\"\nSecRule RESPONSE_HEADERS:Server \"@streq .*\" \"phase:1,pass,nolog,id:1004,t:none,ctl:removeResponseHeader=Server\"\nSecRule RESPONSE_HEADERS:X-Powered-By \"@streq .*\" \"phase:1,pass,nolog,id:1005,t:none,ctl:removeResponseHeader=X-Powered-By\"\n\n# ======================================\n# WORDPRESS CONFIGURATION\n# ======================================\n\n# functions.php (theme)\nremove_action('wp_head', 'wp_generator');\nremove_action('wp_head', 'wlwmanifest_link');\nremove_action('wp_head', 'rsd_link');\nremove_action('wp_head', 'wp_shortlink_wp_head');\nremove_action('wp_head', 'adjacent_posts_rel_link_wp_head');\nremove_action('wp_head', 'feed_links_extra', 3);\nremove_action('wp_head', 'feed_links', 2);\nremove_action('wp_head', 'index_rel_link');\nremove_action('wp_head', 'parent_post_rel_link', 10, 0);\nremove_action('wp_head', 'start_post_rel_link', 10, 0);\nremove_action('wp_head', 'rel_canonical');\nremove_action('wp_head', 'wp_oembed_add_discovery_links');\nremove_action('wp_head', 'wp_oembed_add_host_js');\nremove_action('wp_head', 'rest_output_link_wp_head');\n\n# Remove WordPress version from RSS feeds\nadd_filter('the_generator', '__return_false');\n\n# Custom headers in wp-config.php\ndefine('WP_HTTP_HEADER', 'CustomServer/1.0');\n\n# ======================================\n# DRUPAL CONFIGURATION\n# ======================================\n\n# settings.php\nini_set('expose_php', 0);\n\n# .htaccess\n<IfModule mod_headers.c>\n    Header unset X-Powered-By\n    Header unset X-Generator\n    Header unset X-Drupal-Cache\n    Header unset X-Drupal-Dynamic-Cache\n</IfModule>\n\n# ======================================\n# TESTING AND VALIDATION\n# ======================================\n\n# Bash script to test server headers\n#!/bin/bash\n\ntest_server_headers() {\n    local domain=\"$1\"\n    echo \"=== Testing Server Headers for $domain ===\"\n    \n    # Test HTTPS connection\n    echo \"\\n1. Testing HTTPS connection...\"\n    https_response=$(curl -s -I \"https://$domain\" 2>/dev/null)\n    if [[ $? -eq 0 ]]; then\n        echo \"✓ HTTPS connection successful\"\n        echo \"\\nResponse Headers:\"\n        echo \"$https_response\"\n    else\n        echo \"✗ HTTPS connection failed\"\n        return 1\n    fi\n    \n    # Check for server identification headers\n    echo \"\\n2. Checking for identifying headers...\"\n    \n    # Server header\n    if echo \"$https_response\" | grep -qi \"Server:\"; then\n        server_header=$(echo \"$https_response\" | grep -i \"Server:\" | cut -d: -f2 | xargs)\n        echo \"⚠ Server header found: $server_header\"\n        \n        if [[ \"$server_header\" =~ [0-9] ]]; then\n            echo \"  ✗ Version information exposed!\"\n        else\n            echo \"  ✓ No version information\"\n        fi\n    else\n        echo \"✓ Server header removed\"\n    fi\n    \n    # X-Powered-By header\n    if echo \"$https_response\" | grep -qi \"X-Powered-By\"; then\n        powered_by=$(echo \"$https_response\" | grep -i \"X-Powered-By:\" | cut -d: -f2 | xargs)\n        echo \"⚠ X-Powered-By header found: $powered_by\"\n        echo \"  ✗ Technology stack exposed!\"\n    else\n        echo \"✓ X-Powered-By header removed\"\n    fi\n    \n    # X-AspNet-Version header\n    if echo \"$https_response\" | grep -qi \"X-AspNet-Version\"; then\n        aspnet_version=$(echo \"$https_response\" | grep -i \"X-AspNet-Version:\" | cut -d: -f2 | xargs)\n        echo \"⚠ X-AspNet-Version header found: $aspnet_version\"\n        echo \"  ✗ ASP.NET version exposed!\"\n    else\n        echo \"✓ X-AspNet-Version header removed\"\n    fi\n    \n    # X-Generator header\n    if echo \"$https_response\" | grep -qi \"X-Generator\"; then\n        generator=$(echo \"$https_response\" | grep -i \"X-Generator:\" | cut -d: -f2 | xargs)\n        echo \"⚠ X-Generator header found: $generator\"\n        echo \"  ✗ CMS/Framework exposed!\"\n    else\n        echo \"✓ X-Generator header removed\"\n    fi\n    \n    # Check other revealing headers\n    echo \"\\n3. Checking other potentially revealing headers...\"\n    revealing_headers=(\n        \"X-AspNetMvc-Version\"\n        \"X-Drupal-Cache\"\n        \"X-Mod-Pagespeed\"\n        \"X-Varnish\"\n        \"X-Pingback\"\n        \"X-WP-Total\"\n        \"Link\"\n    )\n    \n    for header in \"${revealing_headers[@]}\"; do\n        if echo \"$https_response\" | grep -qi \"$header\"; then\n            echo \"⚠ $header header found\"\n        fi\n    done\n}\n\n# Python script for comprehensive header analysis\nimport requests\nimport re\nfrom urllib.parse import urlparse\n\ndef analyze_server_headers(domain):\n    \"\"\"Comprehensive analysis of server headers\"\"\"\n    results = {\n        'domain': domain,\n        'secure_headers': [],\n        'vulnerabilities': [],\n        'recommendations': []\n    }\n    \n    try:\n        response = requests.get(f'https://{domain}', timeout=10, verify=True)\n        headers = response.headers\n        \n        # Analyze headers\n        for header, value in headers.items():\n            header_lower = header.lower()\n            \n            # Check for server identification headers\n            if header_lower == 'server':\n                if re.search(r'\\d+\\.\\d+', value):\n                    results['vulnerabilities'].append(\n                        f'Server header exposes version: {value}'\n                    )\n                else:\n                    results['secure_headers'].append(\n                        f'Server header present but no version: {value}'\n                    )\n            \n            elif header_lower == 'x-powered-by':\n                results['vulnerabilities'].append(\n                    f'Technology stack exposed: {value}'\n                )\n            \n            elif header_lower == 'x-aspnet-version':\n                results['vulnerabilities'].append(\n                    f'ASP.NET version exposed: {value}'\n                )\n            \n            elif header_lower == 'x-generator':\n                results['vulnerabilities'].append(\n                    f'CMS/Framework exposed: {value}'\n                )\n            \n            # Check for other revealing headers\n            revealing_patterns = [\n                'x-drupal', 'x-mod-pagespeed', 'x-varnish',\n                'x-pingback', 'x-wp-', 'link: rel='https://api.w.org/'\n            ]\n            \n            for pattern in revealing_patterns:\n                if pattern in header_lower or pattern in value.lower():\n                    results['vulnerabilities'].append(\n                        f'Revealing header: {header}: {value}'\n                    )\n    \n    except requests.exceptions.RequestException as e:\n        results['vulnerabilities'].append(f'Connection error: {str(e)}')\n    \n    return results\n\n# Usage example\nif __name__ == '__main__':\n    result = analyze_server_headers('example.com')\n    print(f\"\\n=== Security Analysis for {result['domain']} ===\")\n    \n    if result['secure_headers']:\n        print(\"\\n✓ Secure Headers Found:\")\n        for header in result['secure_headers']:\n            print(f\"  - {header}\")\n    \n    if result['vulnerabilities']:\n        print(\"\\n⚠ Vulnerabilities Found:\")\n        for vuln in result['vulnerabilities']:\n            print(f\"  - {vuln}\")\n    \n    if result['recommendations']:\n        print(\"\\nRecommendations:\")\n        for rec in result['recommendations']:\n            print(f\"  - {rec}\")\n\n# ======================================\n# AUTOMATED MONITORING SETUP\n# ======================================\n\n# Crontab entry for daily monitoring\n# 0 2 * * * /usr/local/bin/check_server_headers.sh >> /var/log/server_headers.log\n\n# Daily monitoring script\n#!/bin/bash\n\nMONITOR_DOMAINS=(\"example.com\" \"api.example.com\" \"admin.example.com\")\nLOG_FILE=\"/var/log/server_headers.log\"\nDATE=$(date '+%Y-%m-%d %H:%M:%S')\n\necho \"=== Server Header Monitoring - $DATE ===\" >> $LOG_FILE\n\nfor domain in \"${MONITOR_DOMAINS[@]}\"; do\n    echo \"\\nChecking $domain...\" >> $LOG_FILE\n    test_server_headers \"$domain\" >> $LOG_FILE 2>&1\ndone\n\necho \"\\nMonitoring complete.\\n\" >> $LOG_FILE"
      }
    ]
  },
  {
    "pluginId": 10037,
    "title": "Server Leaks Information via \"X-Powered-By\" HTTP Response Header Field(s)",
    "defaultRisk": "Low",
    "cweid": 200,
    "description": "The application is disclosing technology stack information through the X-Powered-By header, revealing the underlying programming language, framework, or web server technology. This information exposure assists attackers in identifying specific vulnerabilities in the disclosed technologies and crafting targeted attacks.",
    "simplified_description": "Your website is telling attackers what programming language and frameworks it uses, like announcing on your front door what brand and model of security system you have. Attackers use this information to find specific vulnerabilities in your technology stack and launch targeted attacks.",
    "solution": "Remove the X-Powered-By header and other technology-identifying headers by configuring web servers, application servers, and programming language settings. This should be implemented at multiple levels including the language runtime, web server configuration, and application framework settings.",
    "simplified_solution": "Configure your web application to hide technology information by removing X-Powered-By headers. This involves settings in your programming language (PHP, ASP.NET, Node.js), web server (Apache, Nginx), and application framework. Test your application to ensure functionality isn't affected.",
    "references": [
      {
        "name": "OWASP Information Exposure Through an Error Message",
        "url": "https://owasp.org/www-project-top-ten/2017/A5_2017-Security_Misconfiguration"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "SANS Top 25 Software Errors",
        "url": "https://www.sans.org/top25-software-errors/#cat1"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP Application Security Configuration",
        "solution_description": "This comprehensive solution addresses X-Powered-By header removal for PHP applications across different hosting environments. It includes PHP configuration changes, Apache/Nginx server settings, framework-specific configurations (WordPress, Laravel, Symfony), and application-level header management. The solution covers shared hosting, dedicated servers, and cloud deployments.",
        "affected_files": "php.ini, .htaccess files, Apache/Nginx configuration files, WordPress wp-config.php, Laravel config/app.php, Symfony framework.yaml, application bootstrap files",
        "code": "<?php\n// PHP X-Powered-By Header Removal Solution\n\n// ======================================\n# PHP.INI CONFIGURATION\n# ======================================\n\n/*\nAdd to php.ini or create custom php.ini:\n\n; Disable PHP signature in HTTP headers\nexpose_php = Off\n\n; This removes: X-Powered-By: PHP/X.Y.Z\n; Also removes PHP information from error pages\n\n; Optional: Custom error messages\n; Hide PHP version from error pages\ndisplay_errors = Off\nlog_errors = On\nerror_log = /var/log/php_errors.log\n\n; Production settings\n; Prevent information disclosure\n; display_startup_errors = Off\n; html_errors = Off\n*/\n\n// ======================================\n# APACHE .HTACCESS CONFIGURATION\n# ======================================\n\n/*\nAdd to .htaccess file:\n\n# For PHP running as Apache module\n<IfModule mod_php7.c>\n    php_flag expose_php off\n</IfModule>\n\n<IfModule mod_php8.c>\n    php_flag expose_php off\n</IfModule>\n\n# Remove X-Powered-By header using mod_headers\n<IfModule mod_headers.c>\n    Header unset X-Powered-By\n</IfModule>\n\n# Alternative for all PHP versions\n<IfModule mod_php.c>\n    php_flag expose_php off\n</IfModule>\n\n# For PHP-FPM\n<IfModule mod_fastcgi.c>\n    FastCgiConfig -pass-header HTTP_AUTHORIZATION\n</IfModule>\n\n# Remove from CGI/FASTCGI\n<IfModule mod_fcgid.c>\n    FcgidPassHeader HTTP_AUTHORIZATION\n</IfModule>\n*/\n\n// ======================================\n# PHP RUNTIME CONFIGURATION\n# ======================================\n\n// Method 1: Using ini_set()\nini_set('expose_php', '0');\n\n// Method 2: Header removal in application\nheader_remove('X-Powered-By');\n\n// Method 3: Comprehensive header management\nclass SecureHeaders {\n    private static $headers = [\n        'X-Powered-By',\n        'Server',\n        'X-AspNet-Version',\n        'X-AspNetMvc-Version',\n        'X-Generator',\n        'X-Drupal-Cache',\n        'X-Varnish',\n        'X-Pingback'\n    ];\n    \n    public static function removeHeaders() {\n        foreach (self::$headers as $header) {\n            header_remove($header);\n        }\n    }\n    \n    public static function setSecureHeaders() {\n        // Remove all identifying headers\n        self::removeHeaders();\n        \n        // Set security headers\n        header('X-Content-Type-Options: nosniff');\n        header('X-Frame-Options: SAMEORIGIN');\n        header('X-XSS-Protection: 1; mode=block');\n        header('Referrer-Policy: strict-origin-when-cross-origin');\n        \n        // Remove PHP version from all responses\n        header_remove('X-Powered-By');\n    }\n}\n\n// Call at the beginning of your application\nSecureHeaders::setSecureHeaders();\n\n// ======================================\n# LARAVEL FRAMEWORK CONFIGURATION\n# ======================================\n\n// config/app.php\nreturn [\n    // ... other configuration\n    \n    // Remove Laravel identifying headers\n    'providers' => [\n        // Comment out or remove providers that add headers\n        // Illuminate\\Foundation\\Providers\\FoundationServiceProvider::class,\n    ],\n    \n    'middleware' => [\n        'web' => [\n            \\App\\Http\\Middleware\\EncryptCookies::class,\n            \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\n            \\Illuminate\\Session\\Middleware\\StartSession::class,\n            \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\n            \\App\\Http\\Middleware\\VerifyCsrfToken::class,\n            \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n            \\App\\Http\\Middleware\\SecureHeaders::class,  // Custom middleware\n        ],\n    ],\n];\n\n// app/Http/Middleware/SecureHeaders.php\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass SecureHeaders\n{\n    public function handle($request, Closure $next)\n    {\n        $response = $next($request);\n        \n        // Remove Laravel identifying headers\n        $response->headers->remove('X-Powered-By');\n        $response->headers->remove('X-Laravel');\n        $response->headers->remove('X-RateLimit-Limit');\n        $response->headers->remove('X-RateLimit-Remaining');\n        $response->headers->remove('Server');\n        \n        return $response;\n    }\n}\n\n// bootstrap/app.php - Remove debug bar in production\nif (app()->environment('production')) {\n    // Remove debug bar and profiler\n    $app->register(Barryvdh\\Debugbar\\ServiceProvider::class);\n}\n\n// ======================================\n# SYMFONY FRAMEWORK CONFIGURATION\n# ======================================\n\n// config/packages/framework.yaml\nframework:\n    secret: '%env(APP_SECRET)%'\n    #csrf_protection: true\n    http_method_override: false\n    trusted_hosts: ~\n    trusted_proxies: ~\n    \n    # Remove Symfony profiler headers in production\n    profiler:\n        only_exceptions: false\n        collect: false\n\n// Remove Symfony debug toolbar in production\n// config/packages/dev/framework.yaml\nif ($_ENV['APP_ENV'] === 'prod') {\n    // In production, ensure profiler is disabled\n    $container->loadFromExtension('framework', [\n        'profiler' => [\n            'enabled' => false,\n        ],\n    ]);\n}\n\n// Custom event listener to remove headers\n// src/EventSubscriber/SecureHeadersSubscriber.php\nnamespace App\\EventSubscriber;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\n\nclass SecureHeadersSubscriber implements EventSubscriberInterface\n{\n    public static function getSubscribedEvents(): array\n    {\n        return [\n            KernelEvents::RESPONSE => 'onKernelResponse',\n        ];\n    }\n    \n    public function onKernelResponse(ResponseEvent $event): void\n    {\n        $response = $event->getResponse();\n        \n        // Remove Symfony identifying headers\n        $response->headers->remove('X-Powered-By');\n        $response->headers->remove('X-Symfony-Profiler');\n        $response->headers->remove('X-Debug-Token');\n        $response->headers->remove('X-Debug-Token-Link');\n    }\n}\n\n// ======================================\n# WORDPRESS CONFIGURATION\n# ======================================\n\n// wp-config.php - Remove WordPress version and headers\ndefine('DISALLOW_FILE_EDIT', true);\ndefine('DISALLOW_FILE_MODS', true);\n\n// Remove WordPress version\nremove_action('wp_head', 'wp_generator');\nremove_action('wp_head', 'wlwmanifest_link');\nremove_action('wp_head', 'rsd_link');\n\n// functions.php - Remove WordPress headers\nfunction remove_wordpress_headers($headers) {\n    unset($headers['X-Pingback']);\n    unset($headers['X-Powered-By']);\n    unset($headers['Link']);  // Remove REST API link\n    return $headers;\n}\nadd_filter('wp_headers', 'remove_wordpress_headers');\n\n// Remove REST API headers\nremove_action('wp_head', 'rest_output_link_wp_head');\nremove_action('wp_head', 'wp_oembed_add_discovery_links');\nremove_action('wp_head', 'wp_oembed_add_host_js');\nremove_action('template_redirect', 'rest_output_link_header', 11);\n\n// Remove emoji script and styles\nremove_action('wp_head', 'print_emoji_detection_script', 7);\nremove_action('wp_print_styles', 'print_emoji_styles');\n\n// ======================================\n# CODEIGNITER CONFIGURATION\n# ======================================\n\n// application/config/config.php\n$config['global_xss_filtering'] = TRUE;\n$config['csrf_protection'] = TRUE;\n\n// application/core/MY_Controller.php\nclass MY_Controller extends CI_Controller {\n    public function __construct() {\n        parent::__construct();\n        \n        // Remove CodeIgniter headers\n        $this->output->set_header('X-Powered-By:');\n    }\n}\n\n// ======================================\n# CAKEPHP CONFIGURATION\n# ======================================\n\n// src/Application.php\npublic function bootstrap(): void\n{\n    parent::bootstrap();\n    \n    // Remove CakePHP headers\n    if (Configure::read('debug') === false) {\n        $this->getEventManager()->on(function (Event $event) {\n            if ($event->getName() === 'Controller.initialize') {\n                $response = $event->getData('response');\n                $response = $response->withoutHeader('X-Powered-By');\n            }\n        });\n    }\n}\n\n// ======================================\n# CUSTOM PHP APPLICATION\n# ======================================\n\n// Global header management class\nclass ApplicationSecurity {\n    private const HEADERS_TO_REMOVE = [\n        'X-Powered-By',\n        'Server',\n        'X-AspNet-Version',\n        'X-AspNetMvc-Version',\n        'X-Generator',\n        'X-Drupal-Cache',\n        'X-Varnish',\n        'X-Pingback',\n        'X-Runtime',\n        'X-Version'\n    ];\n    \n    public static function initialize() {\n        // PHP configuration\n        ini_set('expose_php', '0');\n        \n        // Remove headers\n        self::removeIdentifyingHeaders();\n        \n        // Set security headers\n        self::setSecurityHeaders();\n    }\n    \n    private static function removeIdentifyingHeaders(): void {\n        foreach (self::HEADERS_TO_REMOVE as $header) {\n            header_remove($header);\n        }\n    }\n    \n    private static function setSecurityHeaders(): void {\n        $securityHeaders = [\n            'X-Content-Type-Options' => 'nosniff',\n            'X-Frame-Options' => 'SAMEORIGIN',\n            'X-XSS-Protection' => '1; mode=block',\n            'Referrer-Policy' => 'strict-origin-when-cross-origin',\n            'Content-Security-Policy' => \"default-src 'self'\",\n            'Strict-Transport-Security' => 'max-age=31536000; includeSubDomains'\n        ];\n        \n        foreach ($securityHeaders as $header => $value) {\n            if (!headers_sent()) {\n                header(\"{$header}: {$value}\", true);\n            }\n        }\n    }\n}\n\n// Initialize at application startup\nApplicationSecurity::initialize();\n\n// ======================================\n# NGINX CONFIGURATION FOR PHP\n# ======================================\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    root /var/www/html;\n    \n    # Remove X-Powered-By headers\n    fastcgi_hide_header X-Powered-By;\n    \n    # Remove other PHP headers\n    fastcgi_hide_header Server;\n    fastcgi_hide_header X-Powered-By;\n    fastcgi_hide_header X-AspNet-Version;\n    fastcgi_hide_header X-AspNetMvc-Version;\n    \n    # PHP-FPM configuration\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;\n        \n        # Hide headers from FastCGI\n        fastcgi_hide_header X-Powered-By;\n        fastcgi_hide_header Server;\n    }\n    \n    # Additional security headers\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n}\n\n# ======================================\n# APACHE CONFIGURATION FOR PHP\n# ======================================\n\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # PHP configuration\n    php_admin_flag expose_php Off\n    \n    # Remove headers using mod_headers\n    <IfModule mod_headers.c>\n        Header unset X-Powered-By\n        Header unset Server\n        Header unset X-AspNet-Version\n        Header unset X-AspNetMvc-Version\n        \n        # Set security headers\n        Header always set X-Frame-Options \"SAMEORIGIN\"\n        Header always set X-Content-Type-Options \"nosniff\"\n        Header always set X-XSS-Protection \"1; mode=block\"\n        Header always set Referrer-Policy \"strict-origin-when-cross-origin\"\n    </IfModule>\n    \n    # PHP-FPM configuration\n    <Proxy \"unix:/run/php/php8.0-fpm.sock|fcgi://localhost/\">\n        ProxySet disablereuse=on\n    </Proxy>\n    \n    <FilesMatch \\.php$>\n        SetHandler \"proxy:fcgi://localhost/\"\n    </FilesMatch>\n</VirtualHost>\n\n// ======================================\n# TESTING AND VALIDATION\n# ======================================\n\n// PHP script to test header removal\ntest_php_headers();\n\nfunction test_php_headers() {\n    echo \"=== PHP Header Security Test ===\\n\\n\";\n    \n    // Test current headers\n    $headers = headers_list();\n    \n    echo \"Current Response Headers:\\n\";\n    foreach ($headers as $header) {\n        echo \"  $header\\n\";\n    }\n    \n    echo \"\\n=== Security Analysis ===\\n\";\n    \n    $vulnerabilities = [];\n    \n    foreach ($headers as $header) {\n        if (strpos(strtolower($header), 'x-powered-by') !== false) {\n            $vulnerabilities[] = \"X-Powered-By header found: $header\";\n        }\n        if (strpos(strtolower($header), 'server') !== false) {\n            $vulnerabilities[] = \"Server header found: $header\";\n        }\n    }\n    \n    if (empty($vulnerabilities)) {\n        echo \"✓ No identifying headers found\\n\";\n    } else {\n        echo \"⚠ Vulnerabilities found:\\n\";\n        foreach ($vulnerabilities as $vuln) {\n            echo \"  - $vuln\\n\";\n        }\n    }\n}\n\n// ======================================\n# AUTOMATED MONITORING\n# ======================================\n\n# Bash script for continuous monitoring\n#!/bin/bash\n\nmonitor_php_headers() {\n    local domain=\"$1\"\n    echo \"Monitoring PHP headers for $domain...\"\n    \n    # Check for X-Powered-By header\n    response=$(curl -s -I \"https://$domain\" 2>/dev/null)\n    \n    if echo \"$response\" | grep -qi \"X-Powered-By\"; then\n        powered_by=$(echo \"$response\" | grep -i \"X-Powered-By:\" | cut -d: -f2 | xargs)\n        echo \"⚠ VULNERABILITY: X-Powered-By header found: $powered_by\"\n        \n        # Send alert (example)\n        # echo \"X-Powered-By header exposed on $domain\" | mail -s \"Security Alert\" admin@example.com\n    else\n        echo \"✓ X-Powered-By header properly removed\"\n    fi\n}\n\n# Usage\nmonitor_php_headers \"example.com\""
      }
    ]
  },
  {
    "pluginId": 10038,
    "title": "Content Security Policy (CSP) Header Not Set",
    "defaultRisk": "Medium",
    "cweid": "693",
    "description": "The application is missing a Content Security Policy (CSP) header, which is a critical defense mechanism against various attacks including Cross-Site Scripting (XSS), data injection attacks, and clickjacking. Without CSP, browsers have no clear instructions about which resources are safe to load.",
    "simplified_description": "Your website is missing a critical security header that acts like a security guard for your content. Without it, attackers can inject malicious scripts, steal user data, and perform other attacks by tricking browsers into loading harmful content from unauthorized sources.",
    "solution": "Implement a comprehensive Content Security Policy that defines allowed sources for scripts, styles, images, and other resources. Start with a restrictive policy and gradually whitelist necessary resources.",
    "simplified_solution": "Add a Content-Security-Policy header that tells browsers which domains are allowed to provide content. Start with a strict policy and add specific rules for each type of content (scripts, styles, images, fonts, etc.).",
    "references": [
      {
        "name": "OWASP Content Security Policy Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Content_Security_Policy_Cheat_Sheet.html"
      },
      {
        "name": "MDN CSP Documentation",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Content Security Policy Implementation",
        "solution_description": "This solution demonstrates how to implement comprehensive Content Security Policies across different environments, from basic restrictive policies to advanced implementations with nonce and hash-based CSP, monitoring, and gradual deployment strategies.",
        "affected_files": "Web server configurations, application middleware, security headers, HTML templates, build configurations",
        "code": "# ========================================\n# NGINX CONFIGURATION\n# ========================================\n\n# Basic restrictive CSP\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';\" always;\n\n# Advanced CSP with specific domains\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' https://cdn.trusted.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://api.trusted.com; frame-ancestors 'none'; upgrade-insecure-requests;\" always;\n\n# CSP with nonce for inline scripts\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'nonce-$csp_nonce'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';\" always;\n\n# ========================================\n# APACHE HTTPD CONFIGURATION\n# ========================================\n\n# Basic CSP\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'\"\n\n# CSP with report-uri for monitoring\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; report-uri /csp-report-endpoint\"\n\n# ========================================\n# EXPRESS.JS MIDDLEWARE\n# ========================================\n\nconst express = require('express');\nconst helmet = require('helmet');\nconst crypto = require('crypto');\n\nconst app = express();\n\n// Basic CSP with Helmet\napp.use(helmet.contentSecurityPolicy({\n    directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\n        fontSrc: [\"'self'\"],\n        connectSrc: [\"'self'\"],\n        frameAncestors: [\"'none'\"],\n        upgradeInsecureRequests: []\n    }\n}));\n\n// Advanced CSP with nonce generation\nconst cspMiddleware = (req, res, next) => {\n    const nonce = crypto.randomBytes(16).toString('base64');\n    \n    res.locals.cspNonce = nonce;\n    \n    res.setHeader('Content-Security-Policy', `\n        default-src 'self';\n        script-src 'self' 'nonce-${nonce}';\n        style-src 'self' 'unsafe-inline';\n        img-src 'self' data: https:;\n        font-src 'self';\n        connect-src 'self';\n        frame-ancestors 'none';\n        report-uri /api/csp-report\n    `.replace(/\\s+/g, ' ').trim());\n    \n    next();\n};\n\napp.use(cspMiddleware);\n\n// ========================================\n# SPRING BOOT CONFIGURATION (Java)\n# ========================================\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .headers()\n                .contentSecurityPolicy(\"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'\")\n                .and()\n                .frameOptions().deny()\n                .and()\n            // ... other security configuration\n    }\n}\n\n// Custom CSP filter with nonce support\n@Component\npublic class CSPFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                  HttpServletResponse response, \n                                  FilterChain filterChain) throws ServletException, IOException {\n        \n        // Generate nonce for inline scripts\n        String nonce = generateNonce();\n        request.setAttribute(\"cspNonce\", nonce);\n        \n        // Build CSP policy\n        StringBuilder cspPolicy = new StringBuilder();\n        cspPolicy.append(\"default-src 'self'; \");\n        cspPolicy.append(\"script-src 'self' '\").append(nonce).append(\"'; \");\n        cspPolicy.append(\"style-src 'self' 'unsafe-inline'; \");\n        cspPolicy.append(\"img-src 'self' data: https:; \");\n        cspPolicy.append(\"font-src 'self'; \");\n        cspPolicy.append(\"connect-src 'self'; \");\n        cspPolicy.append(\"frame-ancestors 'none'; \");\n        cspPolicy.append(\"report-uri /api/csp-report\");\n        \n        response.setHeader(\"Content-Security-Policy\", cspPolicy.toString());\n        \n        filterChain.doFilter(request, response);\n    }\n    \n    private String generateNonce() {\n        byte[] nonceBytes = new byte[16];\n        new SecureRandom().nextBytes(nonceBytes);\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(nonceBytes);\n    }\n}\n\n// ========================================\n# CSP IMPLEMENTATION EXAMPLES\n# ========================================\n\n# Level 1: Basic Restrictive Policy\n\"\"\"\nContent-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'\n\"\"\"\n\n# Level 2: With Trusted External Domains\n\"\"\"\nContent-Security-Policy: default-src 'self'; script-src 'self' https://cdn.trusted.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://api.trusted.com; frame-ancestors 'none'\n\"\"\"\n\n# Level 3: With Nonce for Inline Scripts\n\"\"\"\nContent-Security-Policy: default-src 'self'; script-src 'self' 'nonce-aBcDeFgHiJkLmNoPqRsT'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; report-uri /csp-report\n\"\"\"\n\n# Level 4: Production-Ready Policy\n\"\"\"\nContent-Security-Policy: default-src 'self'; script-src 'self' https://cdn.jsdelivr.net 'nonce-${nonce}'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://api.payment.com wss://api.realtime.com; media-src 'self' https://media.cdn.com; object-src 'none'; base-uri 'self'; frame-ancestors 'none'; upgrade-insecure-requests; report-uri /api/csp-violation-report-endpoint\n\"\"\"\n\n# ========================================\n# HTML TEMPLATE WITH NONCE\n# ========================================\n\n<!-- Express.js/EJS Template -->\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Secure App</title>\n    <link rel=\"stylesheet\" href=\"/styles/main.css\">\n</head>\n<body>\n    <div id=\"app\"></div>\n    \n    <!-- Inline script with nonce -->\n    <script nonce=\"<%= cspNonce %>\">\n        // Initialize application\n        window.appConfig = {\n            apiEndpoint: '<%= apiEndpoint %>',\n            version: '<%= version %>'\n        };\n    </script>\n    \n    <!-- External scripts -->\n    <script src=\"/scripts/app.js\"></script>\n</body>\n</html>\n\n<!-- Thymeleaf Template (Spring Boot) -->\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Secure App</title>\n    <link rel=\"stylesheet\" th:href=\"@{/styles/main.css}\">\n</head>\n<body>\n    <div id=\"app\"></div>\n    \n    <!-- Inline script with nonce -->\n    <script th:nonce=\"${cspNonce}\">\n        window.appConfig = {\n            apiEndpoint: '/*[[${apiEndpoint}]]*/',\n            version: '/*[[${version}]]*/'\n        };\n    </script>\n    \n    <script th:src=\"@{/scripts/app.js}\"></script>\n</body>\n</html>\n\n<!-- React Template -->\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n// Get nonce from server-rendered data\nconst nonce = document.querySelector('meta[name=\"csp-nonce\"]')?.getAttribute('content');\n\n// Create inline script with nonce\nif (nonce) {\n    const script = document.createElement('script');\n    script.nonce = nonce;\n    script.textContent = `\n        window.APP_CONFIG = ${JSON.stringify(window.__INITIAL_DATA__)};\n    `;\n    document.head.appendChild(script);\n}\n\nReactDOM.render(<App />, document.getElementById('app'));\n\n<!-- Add nonce meta tag for React access -->\n<meta name=\"csp-nonce\" th:content=\"${cspNonce}\">\n\n# ========================================\n# CSP VIOLATION REPORTING\n# ========================================\n\n# Express.js CSP Report Endpoint\napp.post('/api/csp-report', express.json({ type: 'application/csp-report' }), (req, res) => {\n    const report = req.body;\n    \n    console.warn('CSP Violation Report:', {\n        timestamp: new Date().toISOString(),\n        blockedUri: report['csp-report']['blocked-uri'],\n        documentUri: report['csp-report']['document-uri'],\n        originalPolicy: report['csp-report']['original-policy'],\n        referrer: report['csp-report']['referrer'],\n        sourceFile: report['csp-report']['source-file'],\n        lineNumber: report['csp-report']['line-number'],\n        columnNumber: report['csp-report']['column-number'],\n        violatedDirective: report['csp-report']['violated-directive']\n    });\n    \n    // Send to monitoring service\n    sendToMonitoringService('csp-violation', report);\n    \n    res.status(204).send();\n});\n\n# Spring Boot CSP Report Controller\n@RestController\n@RequestMapping(\"/api\")\npublic class CSPReportController {\n    \n    private static final Logger logger = LoggerFactory.getLogger(CSPReportController.class);\n    \n    @PostMapping(value = \"/csp-report\", consumes = \"application/csp-report\")\n    public ResponseEntity<Void> handleCSPReport(@RequestBody CSPViolationReport report) {\n        \n        logger.warn(\"CSP Violation detected: {}\", report.getCspReport());\n        \n        // Send to security monitoring\n        securityMonitoringService.logCSPViolation(report);\n        \n        return ResponseEntity.noContent().build();\n    }\n}\n\n# Data class for CSP reports\n@Data\npublic class CSPViolationReport {\n    private CSPReport cspReport;\n}\n\n@Data\npublic class CSPReport {\n    private String blockedUri;\n    private String documentUri;\n    private String originalPolicy;\n    private String referrer;\n    private String sourceFile;\n    private Integer lineNumber;\n    private Integer columnNumber;\n    private String violatedDirective;\n}\n\n# ========================================\n# GRADUAL CSP DEPLOYMENT STRATEGY\n# ========================================\n\n# Phase 1: Report-Only Mode\nContent-Security-Policy-Report-Only: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; report-uri /api/csp-report\n\n# Phase 2: Partial Enforcement\nContent-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; report-uri /api/csp-report\n\n# Phase 3: Full Enforcement\nContent-Security-Policy: default-src 'self'; script-src 'self' 'nonce-${nonce}'; style-src 'self' 'nonce-${nonce}'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; report-uri /api/csp-report\n\n# ========================================\n# TESTING AND VALIDATION\n# ========================================\n\n/*\nTESTING PROCEDURES:\n\n1. CSP Header Testing:\n```bash\n# Verify CSP header is present\ncurl -I https://yourdomain.com | grep -i \"content-security-policy\"\n\n# Test different endpoints\ncurl -I https://yourdomain.com/api/test\n```\n\n2. Violation Testing:\n- Inject inline scripts and verify they're blocked\n- Load external resources from unauthorized domains\n- Test with various CSP directives\n- Verify CSP reports are generated correctly\n\n3. Browser DevTools Testing:\n- Check Console tab for CSP violations\n- Monitor Network tab for blocked resources\n- Verify CSP headers in response headers\n- Test with browser extensions\n\n4. Automated Testing:\n```javascript\ndescribe('CSP Implementation', () => {\n    test('should set CSP header', async () => {\n        const response = await fetch('/');\n        const cspHeader = response.headers.get('Content-Security-Policy');\n        expect(cspHeader).toBeTruthy();\n        expect(cspHeader).toContain(\"default-src 'self'\");\n    });\n    \n    test('should block inline scripts', async () => {\n        document.body.innerHTML = '<script>alert(\"test\")</script>';\n        // Script should be blocked and not execute\n    });\n});\n```\n\n5. Performance Impact:\n- Monitor page load times with CSP\n- Check for any resource loading issues\n- Verify CSP doesn't affect legitimate functionality\n- Test across different browsers\n\nSECURITY BENEFITS:\n\n1. Prevents XSS attacks\n2. Stops data injection\n3. Controls resource loading\n4. Prevents clickjacking\n5. Reduces attack surface\n6. Provides security monitoring\n\nMONITORING:\n- Track CSP violations\n- Monitor blocked resources\n- Analyze attack patterns\n- Adjust policy based on reports\n- Maintain compliance metrics\n\nCSP DIRECTIVES REFERENCE:\n- default-src: Fallback for all directives\n- script-src: Allowed script sources\n- style-src: Allowed stylesheet sources\n- img-src: Allowed image sources\n- font-src: Allowed font sources\n- connect-src: Allowed fetch/websocket sources\n- frame-ancestors: Allowed embedding parents\n- object-src: Allowed plugin sources\n- media-src: Allowed media sources\n- manifest-src: Allowed manifest sources\n- report-uri: Violation reporting endpoint\n- upgrade-insecure-requests: Auto-upgrade HTTP to HTTPS\n*/"
      }
    ]
  },
  {
    "pluginId": 10045,
    "title": "Source Code Disclosure - /WEB-INF Folder",
    "defaultRisk": "High",
    "cweid": "541",
    "description": "Source code disclosure through the /WEB-INF directory occurs when Java web applications incorrectly configure access controls, allowing attackers to directly access sensitive files including source code, configuration files, and compiled classes that should be protected.",
    "simplified_description": "Your web application has a security vulnerability that exposes sensitive source code and configuration files to attackers. This is like leaving the blueprints and master keys to your building publicly available - attackers can examine your application's inner workings, find security weaknesses, extract sensitive information like database credentials, and develop targeted attacks against your system.",
    "solution": "Properly configure web application security constraints and servlet mappings to prevent direct access to WEB-INF directory contents.",
    "simplified_solution": "Configure your web server and application to block all direct access to /WEB-INF/ and its subdirectories. Implement proper security constraints in web.xml, ensure servlet mappings don't expose sensitive paths, use URL rewriting to block WEB-INF access, and place all sensitive files under WEB-INF protection. Regularly test for directory traversal and access control bypass vulnerabilities.",
    "references": [
      {
        "name": "OWASP Source Code Disclosure",
        "url": "https://owasp.org/www-community/vulnerabilities/Source_code_disclosure"
      },
      {
        "name": "CWE-541: Information Exposure Through Source Code",
        "url": "https://cwe.mitre.org/data/definitions/541.html"
      },
      {
        "name": "Oracle Java EE Security Guide",
        "url": "https://docs.oracle.com/javaee/7/security-tutorial/security.htm"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Web Application Security Configuration",
        "solution_description": "This solution demonstrates comprehensive security configuration for Java web applications to prevent /WEB-INF directory access and source code disclosure. Includes proper web.xml security constraints, servlet filter implementation, Apache/Nginx configuration, and secure deployment practices for Java EE applications.",
        "affected_files": "WEB-INF/web.xml, application server configuration, security filter classes, web server configuration files (httpd.conf, nginx.conf), servlet mapping configurations",
        "code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee \n         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!-- ============================================ -->\n    <!-- SECURITY CONSTRAINTS - BLOCK WEB-INF ACCESS -->\n    <!-- ============================================ -->\n    \n    <!-- Block direct access to WEB-INF directory -->\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>WEB-INF Protected Resources</web-resource-name>\n            <url-pattern>/WEB-INF/*</url-pattern>\n            <url-pattern>/WEB-INF/**</url-pattern>\n            <http-method>GET</http-method>\n            <http-method>POST</http-method>\n            <http-method>PUT</http-method>\n            <http-method>DELETE</http-method>\n            <http-method>HEAD</http-method>\n            <http-method>OPTIONS</http-method>\n        </web-resource-collection>\n        <auth-constraint>\n            <!-- Empty auth-constraint means no access allowed -->\n        </auth-constraint>\n        <user-data-constraint>\n            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n        </user-data-constraint>\n    </security-constraint>\n\n    <!-- Block META-INF directory access -->\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>META-INF Protected Resources</web-resource-name>\n            <url-pattern>/META-INF/*</url-pattern>\n            <url-pattern>/META-INF/**</url-pattern>\n            <http-method>GET</http-method>\n            <http-method>POST</http-method>\n            <http-method>PUT</http-method>\n            <http-method>DELETE</http-method>\n        </web-resource-collection>\n        <auth-constraint>\n            <!-- No access allowed -->\n        </auth-constraint>\n        <user-data-constraint>\n            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n        </user-data-constraint>\n    </security-constraint>\n\n    <!-- Block class file access -->\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>Class Files Protected</web-resource-name>\n            <url-pattern>*.class</url-pattern>\n            <url-pattern>**/*.class</url-pattern>\n            <http-method>GET</http-method>\n        </web-resource-collection>\n        <auth-constraint>\n            <!-- No access allowed -->\n        </auth-constraint>\n    </security-constraint>\n\n    <!-- Block configuration file access -->\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>Configuration Files Protected</web-resource-name>\n            <url-pattern>*.xml</url-pattern>\n            <url-pattern>*.properties</url-pattern>\n            <url-pattern>*.config</url-pattern>\n            <url-pattern>*.yml</url-pattern>\n            <url-pattern>*.yaml</url-pattern>\n            <url-pattern>*.ini</url-pattern>\n            <http-method>GET</http-method>\n        </web-resource-collection>\n        <auth-constraint>\n            <!-- No access allowed -->\n        </auth-constraint>\n    </security-constraint>\n\n    <!-- ============================================ -->\n    <!-- SECURITY FILTERS -->\n    <!-- ============================================ -->\n    \n    <!-- Security filter for path validation -->\n    <filter>\n        <filter-name>SecurityFilter</filter-name>\n        <filter-class>com.example.security.WebInfSecurityFilter</filter-class>\n        <init-param>\n            <param-name>blockedPaths</param-name>\n            <param-value>/WEB-INF/,/META-INF/,/classes/,/lib/</param-value>\n        </init-param>\n    </filter>\n    \n    <filter-mapping>\n        <filter-name>SecurityFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n        <dispatcher>REQUEST</dispatcher>\n        <dispatcher>FORWARD</dispatcher>\n        <dispatcher>INCLUDE</dispatcher>\n        <dispatcher>ERROR</dispatcher>\n    </filter-mapping>\n\n    <!-- ============================================ -->\n    <!-- ERROR PAGES - PREVENT INFORMATION DISCLOSURE -->\n    <!-- ============================================ -->\n    \n    <error-page>\n        <error-code>404</error-code>\n        <location>/error/404.html</location>\n    </error-page>\n    \n    <error-page>\n        <error-code>403</error-code>\n        <location>/error/403.html</location>\n    </error-page>\n    \n    <error-page>\n        <error-code>500</error-code>\n        <location>/error/500.html</location>\n    </error-page>\n    \n    <!-- Prevent stack trace disclosure -->\n    <error-page>\n        <exception-type>java.lang.Exception</exception-type>\n        <location>/error/generic-error.html</location>\n    </error-page>\n\n</web-app>"
      }
    ]
  },
  {
    "pluginId": 10054,
    "title": "Absence of Anti-CSRF Tokens",
    "defaultRisk": "High",
    "cweid": "352",
    "description": "Cross-Site Request Forgery (CSRF) vulnerabilities occur when a web application does not properly verify that a request originated from an authenticated user, allowing attackers to execute unauthorized actions on behalf of the victim.",
    "simplified_description": "Your website has a critical security flaw that allows attackers to trick authenticated users into performing actions they didn't intend to make. This is like someone forging your signature on important documents - attackers can make your users change passwords, transfer money, or delete data without their knowledge by simply visiting a malicious website while logged into your application.",
    "solution": "Implement CSRF protection tokens on all state-changing requests and validate them server-side.",
    "simplified_solution": "Add unique, unpredictable tokens to all forms and AJAX requests that change data. These tokens should be generated by the server, tied to user sessions, and validated before processing any sensitive operations. Never trust that requests from authenticated users are legitimate without proper CSRF protection.",
    "references": [
      {
        "name": "OWASP CSRF Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-352: Cross-Site Request Forgery (CSRF)",
        "url": "https://cwe.mitre.org/data/definitions/352.html"
      },
      {
        "name": "OWASP Top Ten A01:2021 - Broken Access Control",
        "url": "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Spring Boot CSRF Protection Implementation",
        "solution_description": "This solution demonstrates how to implement comprehensive CSRF protection in a Spring Boot application using built-in security features. It includes configuration, form protection, and AJAX request handling with proper token management and validation.",
        "affected_files": "Security configuration classes, form templates, JavaScript files, REST controllers, HTML views",
        "code": "// ============================================\n// SPRING SECURITY CONFIGURATION\n// ============================================\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            // Enable CSRF protection\n            .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n            .and()\n            // Configure authentication and authorization\n            .authorizeRequests()\n                .antMatchers(\"/api/public/**\").permitAll()\n                .antMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            .and()\n            // Form login configuration\n            .formLogin()\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/dashboard\")\n                .permitAll()\n            .and()\n            // Logout configuration\n            .logout()\n                .logoutUrl(\"/logout\")\n                .logoutSuccessUrl(\"/login?logout\")\n                .invalidateHttpSession(true)\n                .deleteCookies(\"JSESSIONID\")\n                .permitAll();\n    }\n    \n    @Bean\n    public CsrfTokenRepository csrfTokenRepository() {\n        CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();\n        repository.setCookieName(\"XSRF-TOKEN\");\n        repository.setHeaderName(\"X-XSRF-TOKEN\");\n        return repository;\n    }\n}\n\n// ============================================\n// CONTROLLER WITH CSRF PROTECTED ENDPOINTS\n// ============================================\n\n@RestController\n@RequestMapping(\"/api\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    // POST endpoints are automatically protected by CSRF\n    @PostMapping(\"/users/{userId}/profile\")\n    public ResponseEntity<?> updateUserProfile(\n            @PathVariable Long userId,\n            @Valid @RequestBody UserProfileUpdateRequest request,\n            Authentication authentication) {\n        \n        // Additional authorization check\n        if (!isUserAuthorized(userId, authentication)) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .body(\"Unauthorized to update this profile\");\n        }\n        \n        try {\n            userService.updateUserProfile(userId, request);\n            return ResponseEntity.ok().body(\"Profile updated successfully\");\n        } catch (Exception e) {\n            return ResponseEntity.badRequest().body(\"Failed to update profile\");\n        }\n    }\n    \n    @PostMapping(\"/users/{userId}/delete\")\n    public ResponseEntity<?> deleteUserAccount(\n            @PathVariable Long userId,\n            Authentication authentication) {\n        \n        if (!isUserAuthorized(userId, authentication)) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .body(\"Unauthorized to delete this account\");\n        }\n        \n        userService.deleteUser(userId);\n        return ResponseEntity.ok().body(\"Account deleted successfully\");\n    }\n    \n    private boolean isUserAuthorized(Long userId, Authentication authentication) {\n        String currentUsername = authentication.getName();\n        User currentUser = userService.findByUsername(currentUsername);\n        return currentUser != null && currentUser.getId().equals(userId);\n    }\n}\n\n// ============================================\n// HTML TEMPLATE WITH CSRF TOKEN\n// ============================================\n\n<!-- profile.html -->\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>User Profile</title>\n    <!-- Include CSRF token in meta tag for JavaScript access -->\n    <meta name=\"_csrf\" th:content=\"${_csrf.token}\"/>\n    <meta name=\"_csrf_header\" th:content=\"${_csrf.headerName}\"/>\n</head>\n<body>\n    <div class=\"container\">\n        <h2>Update Profile</h2>\n        \n        <!-- Form with CSRF token automatically included -->\n        <form th:action=\"@{/api/users/{userId}/profile(userId=${currentUser.id})}\" \n              method=\"post\" \n              th:object=\"${profileUpdateRequest}\"\n              id=\"profileForm\">\n            \n            <!-- CSRF token is automatically added by Spring Security -->\n            <input type=\"hidden\" th:name=\"${_csrf.parameterName}\" th:value=\"${_csrf.token}\" />\n            \n            <div class=\"form-group\">\n                <label for=\"email\">Email:</label>\n                <input type=\"email\" th:field=\"*{email}\" class=\"form-control\" required>\n            </div>\n            \n            <div class=\"form-group\">\n                <label for=\"firstName\">First Name:</label>\n                <input type=\"text\" th:field=\"*{firstName}\" class=\"form-control\" required>\n            </div>\n            \n            <div class=\"form-group\">\n                <label for=\"lastName\">Last Name:</label>\n                <input type=\"text\" th:field=\"*{lastName}\" class=\"form-control\" required>\n            </div>\n            \n            <button type=\"submit\" class=\"btn btn-primary\">Update Profile</button>\n        </form>\n        \n        <!-- AJAX Form Example -->\n        <button id=\"deleteAccountBtn\" class=\"btn btn-danger\">Delete Account</button>\n    </div>\n    \n    <script src=\"/js/csrf-protection.js\"></script>\n</body>\n</html>\n\n// ============================================\n// JAVASCRIPT WITH CSRF TOKEN HANDLING\n// ============================================\n\n// csrf-protection.js\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Get CSRF token from meta tag\n    const csrfToken = document.querySelector('meta[name=\"_csrf\"]').getAttribute('content');\n    const csrfHeader = document.querySelector('meta[name=\"_csrf_header\"]').getAttribute('content');\n    \n    // Setup default headers for all fetch requests\n    const defaultHeaders = {\n        'Content-Type': 'application/json',\n        [csrfHeader]: csrfToken\n    };\n    \n    // Example: AJAX form submission with CSRF protection\n    document.getElementById('profileForm').addEventListener('submit', function(e) {\n        e.preventDefault();\n        \n        const formData = new FormData(this);\n        const formObject = {};\n        \n        // Convert FormData to JSON object\n        formData.forEach((value, key) => {\n            if (key !== '_csrf') { // Exclude CSRF token from data\n                formObject[key] = value;\n            }\n        });\n        \n        const formAction = this.getAttribute('action');\n        \n        fetch(formAction, {\n            method: 'POST',\n            headers: defaultHeaders,\n            body: JSON.stringify(formObject)\n        })\n        .then(response => {\n            if (response.ok) {\n                alert('Profile updated successfully!');\n                window.location.reload();\n            } else {\n                alert('Failed to update profile');\n            }\n        })\n        .catch(error => {\n            console.error('Error:', error);\n            alert('An error occurred while updating profile');\n        });\n    });\n    \n    // Example: Delete account with CSRF protection\n    document.getElementById('deleteAccountBtn').addEventListener('click', function() {\n        if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {\n            const userId = this.getAttribute('data-user-id');\n            \n            fetch(`/api/users/${userId}/delete`, {\n                method: 'POST',\n                headers: defaultHeaders\n            })\n            .then(response => {\n                if (response.ok) {\n                    alert('Account deleted successfully');\n                    window.location.href = '/login';\n                } else {\n                    alert('Failed to delete account');\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                alert('An error occurred while deleting account');\n            });\n        }\n    });\n});\n\n// ============================================\n// CSRF TOKEN UTILITY CLASS\n// ============================================\n\npublic class CsrfTokenUtil {\n    \n    public static void setupCsrfProtectionForAjax(HttpServletResponse response) {\n        // This method can be used to setup CSRF tokens for AJAX responses\n        // Spring Security automatically handles this, but this is for custom scenarios\n    }\n    \n    public static boolean validateCsrfToken(HttpServletRequest request, String expectedToken) {\n        String actualToken = request.getParameter(\"_csrf\");\n        if (actualToken == null) {\n            actualToken = request.getHeader(\"X-XSRF-TOKEN\");\n        }\n        return expectedToken.equals(actualToken);\n    }\n}\n\n// ============================================\n// SECURITY TESTING VERIFICATION\n// ============================================\n\n/*\nCSRF Protection Testing Steps:\n\n1. Manual Testing:\n   - Try submitting forms without CSRF token (should fail)\n   - Try submitting forms with invalid CSRF token (should fail)\n   - Verify normal form submission works with valid token\n   - Test AJAX requests include proper CSRF headers\n\n2. Automated Testing:\n   - Use OWASP ZAP to scan for CSRF vulnerabilities\n   - Create unit tests to verify CSRF token generation and validation\n   - Test with different user roles and permissions\n\n3. Security Headers Verification:\n   - Check that SameSite cookies are properly configured\n   - Verify that CSRF tokens are not stored in localStorage\n   - Ensure tokens have sufficient entropy and expire appropriately\n\n4. Integration Testing:\n   - Test CSRF protection across different browsers\n   - Verify behavior with disabled JavaScript\n   - Test with multiple tabs/windows open\n   - Verify token refresh behavior after login/logout\n\nExpected Results:\n- All state-changing operations should require valid CSRF token\n- Requests without valid tokens should be rejected with 403 Forbidden\n- Tokens should be unique per user session\n- AJAX requests should automatically include CSRF headers\n*/"
      },
      {
        "type": "Node.js Express CSRF Protection",
        "solution_description": "This solution shows how to implement CSRF protection in a Node.js Express application using the csurf middleware, including cookie-based token storage, form integration, and API endpoint protection.",
        "affected_files": "Express app configuration, middleware setup, route handlers, form templates, frontend JavaScript",
        "code": "// ============================================\n// EXPRESS APP CONFIGURATION WITH CSRF\n// ============================================\n\nconst express = require('express');\nconst cookieParser = require('cookie-parser');\nconst csrf = require('csurf');\nconst helmet = require('helmet');\nconst path = require('path');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(cookieParser());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Configure CSRF protection\nconst csrfProtection = csrf({\n    cookie: {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production', // Use secure cookies in production\n        sameSite: 'strict'\n    }\n});\n\n// Apply CSRF protection to all routes\napp.use(csrfProtection);\n\n// Middleware to make CSRF token available to all templates\napp.use((req, res, next) => {\n    res.locals.csrfToken = req.csrfToken();\n    next();\n});\n\n// ============================================\n// PROTECTED ROUTES\n// ============================================\n\n// GET routes don't need CSRF protection (safe operations)\napp.get('/', (req, res) => {\n    res.render('index', { title: 'Home' });\n});\n\napp.get('/profile', (req, res) => {\n    res.render('profile', { \n        title: 'User Profile',\n        user: req.user // Assuming user is set by auth middleware\n    });\n});\n\n// POST routes are automatically protected by CSRF middleware\napp.post('/api/users/:id/profile', (req, res) => {\n    const userId = req.params.id;\n    const { email, firstName, lastName } = req.body;\n    \n    // Additional authorization check\n    if (req.user.id !== parseInt(userId)) {\n        return res.status(403).json({ error: 'Unauthorized' });\n    }\n    \n    // Update user profile in database\n    try {\n        // Database update logic here\n        res.json({ success: true, message: 'Profile updated successfully' });\n    } catch (error) {\n        res.status(500).json({ error: 'Failed to update profile' });\n    }\n});\n\napp.post('/api/users/:id/delete', (req, res) => {\n    const userId = req.params.id;\n    \n    // Authorization check\n    if (req.user.id !== parseInt(userId)) {\n        return res.status(403).json({ error: 'Unauthorized' });\n    }\n    \n    try {\n        // Delete user account\n        res.json({ success: true, message: 'Account deleted successfully' });\n    } catch (error) {\n        res.status(500).json({ error: 'Failed to delete account' });\n    }\n});\n\n// ============================================\n// API ENDPOINT FOR CSRF TOKEN (for SPA/AJAX)\n// ============================================\n\napp.get('/api/csrf-token', csrfProtection, (req, res) => {\n    res.json({ csrfToken: req.csrfToken() });\n});\n\n// ============================================\n// ERROR HANDLING FOR CSRF VIOLATIONS\n// ============================================\n\napp.use((err, req, res, next) => {\n    if (err.code === 'EBADCSRFTOKEN') {\n        // CSRF token invalid or missing\n        return res.status(403).json({ \n            error: 'Invalid CSRF token',\n            message: 'Your session has expired or the request is invalid. Please refresh the page and try again.'\n        });\n    }\n    next(err);\n});\n\n// ============================================\n// EJS TEMPLATE WITH CSRF TOKEN\n// ============================================\n\n<!-- views/profile.ejs -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title><%= title %></title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 40px; }\n        .form-group { margin-bottom: 15px; }\n        label { display: block; margin-bottom: 5px; }\n        input[type=\"text\"], input[type=\"email\"] { \n            width: 100%; padding: 8px; border: 1px solid #ddd; \n        }\n        .btn { padding: 10px 20px; border: none; cursor: pointer; }\n        .btn-primary { background-color: #007bff; color: white; }\n        .btn-danger { background-color: #dc3545; color: white; }\n    </style>\n</head>\n<body>\n    <h1><%= title %></h1>\n    \n    <!-- Form with CSRF token -->\n    <form action=\"/api/users/<%= user.id %>/profile\" method=\"POST\">\n        <!-- Hidden CSRF token field -->\n        <input type=\"hidden\" name=\"_csrf\" value=\"<%= csrfToken %>\">\n        \n        <div class=\"form-group\">\n            <label for=\"email\">Email:</label>\n            <input type=\"email\" id=\"email\" name=\"email\" value=\"<%= user.email %>\" required>\n        </div>\n        \n        <div class=\"form-group\">\n            <label for=\"firstName\">First Name:</label>\n            <input type=\"text\" id=\"firstName\" name=\"firstName\" value=\"<%= user.firstName %>\" required>\n        </div>\n        \n        <div class=\"form-group\">\n            <label for=\"lastName\">Last Name:</label>\n            <input type=\"text\" id=\"lastName\" name=\"lastName\" value=\"<%= user.lastName %>\" required>\n        </div>\n        \n        <button type=\"submit\" class=\"btn btn-primary\">Update Profile</button>\n    </form>\n    \n    <hr>\n    \n    <!-- AJAX Example -->\n    <button id=\"deleteAccountBtn\" class=\"btn btn-danger\" data-user-id=\"<%= user.id %>\">\n        Delete Account\n    </button>\n    \n    <script src=\"/js/csrf-protection.js\"></script>\n</body>\n</html>\n\n// ============================================\n// FRONTEND JAVASCRIPT WITH CSRF\n// ============================================\n\n// public/js/csrf-protection.js\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Fetch CSRF token for AJAX requests\n    let csrfToken;\n    \n    // Get CSRF token from the page (if available) or fetch it\n    const csrfTokenInput = document.querySelector('input[name=\"_csrf\"]');\n    if (csrfTokenInput) {\n        csrfToken = csrfTokenInput.value;\n    } else {\n        // Fetch CSRF token from API\n        fetch('/api/csrf-token')\n            .then(response => response.json())\n            .then(data => {\n                csrfToken = data.csrfToken;\n            })\n            .catch(error => {\n                console.error('Failed to fetch CSRF token:', error);\n            });\n    }\n    \n    // Setup AJAX interceptor to include CSRF token\n    const originalFetch = window.fetch;\n    window.fetch = function(url, options = {}) {\n        // Only add CSRF token to state-changing requests\n        if (options.method && ['POST', 'PUT', 'DELETE', 'PATCH'].includes(options.method.toUpperCase())) {\n            options.headers = {\n                ...options.headers,\n                'X-CSRF-Token': csrfToken\n            };\n        }\n        return originalFetch(url, options);\n    };\n    \n    // Form submission handler\n    const profileForm = document.querySelector('form[action*=\"/profile\"]');\n    if (profileForm) {\n        profileForm.addEventListener('submit', function(e) {\n            e.preventDefault();\n            \n            const formData = new FormData(this);\n            const data = Object.fromEntries(formData.entries());\n            \n            // Remove CSRF token from data object\n            delete data._csrf;\n            \n            fetch(this.action, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRF-Token': csrfToken\n                },\n                body: JSON.stringify(data)\n            })\n            .then(response => {\n                if (response.ok) {\n                    alert('Profile updated successfully!');\n                    location.reload();\n                } else {\n                    return response.json().then(err => {\n                        throw new Error(err.error || 'Update failed');\n                    });\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n                alert(error.message || 'Failed to update profile');\n            });\n        });\n    }\n    \n    // Delete account handler\n    const deleteBtn = document.getElementById('deleteAccountBtn');\n    if (deleteBtn) {\n        deleteBtn.addEventListener('click', function() {\n            const userId = this.getAttribute('data-user-id');\n            \n            if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {\n                fetch(`/api/users/${userId}/delete`, {\n                    method: 'POST',\n                    headers: {\n                        'X-CSRF-Token': csrfToken\n                    }\n                })\n                .then(response => {\n                    if (response.ok) {\n                        alert('Account deleted successfully');\n                        window.location.href = '/';\n                    } else {\n                        return response.json().then(err => {\n                            throw new Error(err.error || 'Delete failed');\n                        });\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    alert(error.message || 'Failed to delete account');\n                });\n            }\n        });\n    }\n});\n\n// ============================================\n// SECURITY TESTING SCRIPT\n// ============================================\n\n/*\nCSRF Protection Testing for Node.js:\n\n1. Manual Testing Commands:\n   # Try to submit form without CSRF token\n   curl -X POST http://localhost:3000/api/users/1/profile \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\"email\":\"test@example.com\"}'\n   # Should return 403 Forbidden\n\n   # Try with invalid CSRF token\n   curl -X POST http://localhost:3000/api/users/1/profile \\\n        -H \"Content-Type: application/json\" \\\n        -H \"X-CSRF-Token: invalid-token\" \\\n        -d '{\"email\":\"test@example.com\"}'\n   # Should return 403 Forbidden\n\n2. Automated Testing:\n   npm install --save-dev supertest jest\n   \n   // test/csrf.test.js\n   const request = require('supertest');\n   const app = require('../app');\n   \n   describe('CSRF Protection', () => {\n     test('should reject POST without CSRF token', async () => {\n       const response = await request(app)\n         .post('/api/users/1/profile')\n         .send({ email: 'test@example.com' })\n         .expect(403);\n     });\n     \n     test('should reject POST with invalid CSRF token', async () => {\n       const response = await request(app)\n         .post('/api/users/1/profile')\n         .set('X-CSRF-Token', 'invalid-token')\n         .send({ email: 'test@example.com' })\n         .expect(403);\n     });\n   });\n\n3. Security Verification Checklist:\n   - All POST/PUT/DELETE endpoints require CSRF token\n   - CSRF tokens are cryptographically strong\n   - Tokens expire appropriately (same as session)\n   - SameSite cookies are properly configured\n   - Error messages don't leak sensitive information\n   - AJAX requests automatically include CSRF headers\n*/"
      }
    ]
  },
  {
    "pluginId": 10057,
    "title": "Username Hash Found",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Username hash disclosure vulnerabilities occur when applications expose hashed usernames or predictable user identifiers in URLs, forms, or responses, allowing attackers to enumerate users, gather intelligence about the user base, and potentially reverse-engineer user identification systems.",
    "simplified_description": "Your application is exposing user identification patterns that allow attackers to discover valid usernames and account information, like publishing a partial employee directory that helps outsiders identify who works at your company. This enables attackers to build targeted attacks, guess passwords for known accounts, and harvest user data for social engineering campaigns.",
    "solution": "Remove username hashes from publicly accessible areas and implement proper user enumeration protection with secure identification methods.",
    "simplified_solution": "Eliminate username exposure in URLs, API responses, and form fields. Replace predictable user IDs with random UUIDs, implement proper access controls that hide user existence from unauthorized users, and add rate limiting to prevent username enumeration attacks. Ensure user discovery requires proper authentication and authorization.",
    "references": [
      {
        "name": "OWASP User Enumeration Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: User Enumeration",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/04-Testing_for_User_Enumeration_and_Guessable_User_Account.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure User Identification and Enumeration Prevention",
        "solution_description": "This solution demonstrates comprehensive secure user management that prevents username enumeration, uses secure identification methods, implements proper access controls, and protects user information from unauthorized discovery.",
        "affected_files": "User management controllers, authentication systems, API endpoints, user profile pages, database schemas, frontend forms, search functionality",
        "code": "<?php\n// ============================================\n// SECURE USER MANAGEMENT CLASS\n// ============================================\n\nclass SecureUserManager {\n    private $db;\n    private $rateLimiter;\n    \n    public function __construct(PDO $db, RateLimiter $rateLimiter) {\n        $this->db = $db;\n        $this->rateLimiter = $rateLimiter;\n    }\n    \n    /**\n     * Create new user with secure identification\n     */\n    public function createUser($email, $username, $password) {\n        // Generate secure user identifier\n        $userId = $this->generateSecureUserId();\n        $publicId = $this->generatePublicId();\n        \n        // Generate username hash for internal use only\n        $usernameHash = $this->hashUsername($username);\n        \n        // Store user with secure data\n        $stmt = $this->db->prepare('\n            INSERT INTO users (\n                id, public_id, email, username, username_hash, \n                password_hash, created_at, updated_at\n            ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\n        ');\n        \n        $stmt->execute([\n            $userId,\n            $publicId,\n            $email,\n            $username,\n            $usernameHash,\n            password_hash($password, PASSWORD_ARGON2ID)\n        ]);\n        \n        return [\n            'id' => $publicId,\n            'email' => $email,\n            'username' => $username\n        ];\n    }\n    \n    /**\n     * Generate secure internal user ID\n     */\n    private function generateSecureUserId() {\n        return bin2hex(random_bytes(16));\n    }\n    \n    /**\n     * Generate public-facing user ID\n     */\n    private function generatePublicId() {\n        // Use UUID format for public IDs\n        return sprintf(\n            '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n            mt_rand(0, 0xffff), mt_rand(0, 0xffff),\n            mt_rand(0, 0xffff),\n            mt_rand(0, 0x0fff) | 0x4000,\n            mt_rand(0, 0x3fff) | 0x8000,\n            mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)\n        );\n    }\n    \n    /**\n     * Hash username for internal verification\n     */\n    private function hashUsername($username) {\n        // Use HMAC with server secret for username hashing\n        $serverSecret = $this->getServerSecret();\n        return hash_hmac('sha256', strtolower($username), $serverSecret);\n    }\n    \n    /**\n     * Get server secret from secure configuration\n     */\n    private function getServerSecret() {\n        return $_ENV['USER_HASH_SECRET'] ?? 'default-secret-change-in-production';\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 10058,
    "title": "GET for POST",
    "defaultRisk": "Medium",
    "cweid": "302",
    "description": "The application uses HTTP GET method for operations that should be performed using POST. This violates REST principles and can lead to security vulnerabilities since GET requests can be cached, bookmarked, and stored in browser history, potentially exposing sensitive operations and parameters.",
    "simplified_description": "Your application is using the wrong HTTP method for sensitive operations. GET requests are meant for retrieving data and are visible in browser history, URLs, and can be cached. When used for actions like changing data or making purchases, these sensitive operations can be accidentally repeated or triggered by browser crawlers, leading to unauthorized actions or duplicate transactions.",
    "solution": "Change sensitive operations from GET to POST requests and implement proper anti-CSRF protection.",
    "simplified_solution": "Update your application to use POST, PUT, or DELETE methods for actions that change data. Add CSRF tokens to forms and validate them on the server. This prevents accidental actions and protects against cross-site request forgery attacks.",
    "references": [
      {
        "name": "OWASP CSRF Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-302: Authentication Bypass by Assumed-Immutable Data",
        "url": "https://cwe.mitre.org/data/definitions/302.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "HTTP Method Security Implementation",
        "solution_description": "This solution demonstrates how to properly secure sensitive operations by changing from GET to POST and implementing CSRF protection. The code shows form updates, server-side validation, and proper HTTP method usage for data-modifying operations.",
        "affected_files": "HTML forms, JavaScript AJAX calls, backend controllers, routing configuration, authentication middleware",
        "code": "<!-- BEFORE (VULNERABLE): GET request for sensitive action -->\n<a href=\"/api/delete-user?id=123\" onclick=\"return confirm('Are you sure?')\">Delete User</a>\n\n<!-- AFTER (SECURE): POST request with CSRF protection -->\n<form method=\"POST\" action=\"/api/delete-user\" class=\"inline-form\" \n      onsubmit=\"return confirm('Are you sure you want to delete this user?')\">\n    <input type=\"hidden\" name=\"id\" value=\"123\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{csrf_token}}\">\n    <button type=\"submit\" class=\"btn btn-danger\">Delete User</button>\n</form>\n\n<!-- ======================================== -->\n<!-- SERVER-SIDE IMPLEMENTATION (Express.js) -->\n<!-- ======================================== -->\n\nconst express = require('express');\nconst csrf = require('csurf');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\n\n// Setup CSRF protection\nconst csrfProtection = csrf({ \n    cookie: {\n        httpOnly: true,\n        secure: true,\n        sameSite: 'strict'\n    }\n});\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cookieParser());\n\n// BAD: GET route for sensitive operation\napp.get('/api/delete-user', (req, res) => {\n    const userId = req.query.id;\n    // Vulnerable: can be triggered by crawlers, bookmarked, cached\n    deleteUser(userId);\n    res.redirect('/users');\n});\n\n// GOOD: POST route with CSRF protection\napp.delete('/api/users/:id', csrfProtection, async (req, res) => {\n    try {\n        const userId = req.params.id;\n        \n        // Validate user authorization\n        if (!req.user || !req.user.canDeleteUser(userId)) {\n            return res.status(403).json({ \n                error: 'Unauthorized to delete this user' \n            });\n        }\n        \n        // Additional input validation\n        if (!isValidUserId(userId)) {\n            return res.status(400).json({ \n                error: 'Invalid user ID' \n            });\n        }\n        \n        // Perform the deletion\n        await deleteUser(userId);\n        \n        // Log the action for audit\n        await logSecurityAction(req.user.id, 'DELETE_USER', userId);\n        \n        res.json({ \n            success: true, \n            message: 'User deleted successfully' \n        });\n        \n    } catch (error) {\n        console.error('Delete user error:', error);\n        res.status(500).json({ \n            error: 'Internal server error' \n        });\n    }\n});\n\n<!-- ======================================== -->\n<!-- JAVASCRIPT IMPLEMENTATION (Modern Frontend) -->\n<!-- ======================================== -->\n\n// BAD: Using GET for sensitive actions\nfunction deleteUser(userId) {\n    window.location.href = `/api/delete-user?id=${userId}`;\n}\n\n// GOOD: Using POST/DELETE with fetch API\nasync function deleteUser(userId) {\n    try {\n        // Confirm with user first\n        const confirmed = await showConfirmDialog(\n            'Are you sure you want to delete this user?',\n            'This action cannot be undone.'\n        );\n        \n        if (!confirmed) return;\n        \n        // Get CSRF token from meta tag or cookie\n        const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')\n            ?.getAttribute('content');\n        \n        // Make secure DELETE request\n        const response = await fetch(`/api/users/${userId}`, {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRF-Token': csrfToken\n            },\n            credentials: 'same-origin'\n        });\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const result = await response.json();\n        \n        // Show success message\n        showSuccessToast('User deleted successfully');\n        \n        // Update UI\n        removeUserFromList(userId);\n        \n        // Redirect if needed\n        if (shouldRedirect()) {\n            window.location.href = '/users';\n        }\n        \n    } catch (error) {\n        console.error('Delete user failed:', error);\n        showErrorToast('Failed to delete user. Please try again.');\n    }\n}\n\n<!-- ======================================== -->\n<!-- SPRING BOOT IMPLEMENTATION (Java) -->\n<!-- ======================================== -->\n\n@RestController\n@RequestMapping(\"/api/users\")\n@RequiredArgsConstructor\npublic class UserController {\n    \n    private final UserService userService;\n    private final SecurityAuditService auditService;\n    \n    // BAD: GET mapping for deletion\n    @GetMapping(\"/delete/{id}\")\n    public String deleteUser(@PathVariable Long id, Model model) {\n        // Vulnerable: GET request for destructive operation\n        userService.deleteUser(id);\n        return \"redirect:/users\";\n    }\n    \n    // GOOD: DELETE mapping with proper security\n    @DeleteMapping(\"/{id}\")\n    @PreAuthorize(\"hasRole('ADMIN') or hasPermission(#id, 'USER', 'DELETE')\")\n    public ResponseEntity<?> deleteUser(\n            @PathVariable Long id,\n            @AuthenticationPrincipal UserDetails userDetails) {\n        \n        try {\n            // Additional security checks\n            User currentUser = userService.getCurrentUser(userDetails);\n            \n            // Prevent self-deletion\n            if (currentUser.getId().equals(id)) {\n                return ResponseEntity.badRequest()\n                    .body(\"Cannot delete your own account\");\n            }\n            \n            // Validate user exists and can be deleted\n            User userToDelete = userService.findById(id)\n                .orElseThrow(() -> new UserNotFoundException(id));\n            \n            // Check if user has permission to delete this specific user\n            if (!userService.canDeleteUser(currentUser, userToDelete)) {\n                auditService.logUnauthorizedAccess(currentUser.getId(), \n                    \"DELETE_USER_ATTEMPT\", id);\n                return ResponseEntity.status(HttpStatus.FORBIDDEN)\n                    .body(\"Insufficient permissions\");\n            }\n            \n            // Perform deletion\n            userService.deleteUser(userToDelete);\n            \n            // Log for audit\n            auditService.logUserAction(currentUser.getId(), \n                \"DELETE_USER\", userToDelete.getId());\n            \n            return ResponseEntity.ok()\n                .body(Map.of(\n                    \"message\", \"User deleted successfully\",\n                    \"deletedUserId\", id\n                ));\n                \n        } catch (UserNotFoundException e) {\n            return ResponseEntity.notFound().build();\n        } catch (Exception e) {\n            log.error(\"Failed to delete user {}\", id, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"Failed to delete user\");\n        }\n    }\n}\n\n<!-- ======================================== -->\n<!-- CONFIGURATION AND BEST PRACTICES -->\n<!-- ======================================== -->\n\n/*\nSECURITY CONFIGURATION CHECKLIST:\n\n1. HTTP Method Usage:\n   - GET: Retrieve data only\n   - POST: Create new resources\n   - PUT/PATCH: Update existing resources  \n   - DELETE: Remove resources\n   - Never use GET for state-changing operations\n\n2. CSRF Protection:\n   - Implement CSRF tokens for all state-changing requests\n   - Validate tokens on the server side\n   - Use SameSite cookie attributes\n   - Consider double-submit cookie pattern\n\n3. Input Validation:\n   - Validate all parameters and inputs\n   - Use whitelist validation\n   - Sanitize user input\n   - Implement rate limiting\n\n4. Authorization:\n   - Check user permissions before operations\n   - Use role-based access control (RBAC)\n   - Implement principle of least privilege\n   - Log authorization failures\n\n5. Error Handling:\n   - Don't expose sensitive error details\n   - Use generic error messages for clients\n   - Log detailed errors for debugging\n   - Implement proper HTTP status codes\n\n6. Frontend Best Practices:\n   - Use forms with method=\"POST\" for sensitive actions\n   - Add confirmation dialogs for destructive operations\n   - Implement double-submit protection\n   - Disable buttons after submission\n\n7. Backend Best Practices:\n   - Use RESTful HTTP methods correctly\n   - Implement proper middleware for security checks\n   - Add audit logging for sensitive operations\n   - Validate request origins and referers\n\n8. Testing:\n   - Test with automated scanners\n   - Verify CSRF protection works\n   - Test for method bypassing\n   - Perform security penetration testing\n*/"
      }
    ]
  },
  {
    "pluginId": 10097,
    "title": "Hash Disclosure",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Hash disclosure vulnerabilities occur when cryptographic hashes are exposed in client-side code, error messages, or API responses. This can lead to hash cracking, password discovery, and unauthorized access to sensitive data.",
    "simplified_description": "Your application is exposing cryptographic hashes that attackers can potentially crack to reveal original sensitive information like passwords. This is like finding encrypted password clues that hackers can use with specialized tools to decode and gain unauthorized access to user accounts or sensitive data.",
    "solution": "Remove hash exposure, implement proper cryptographic storage practices, and ensure no sensitive hash values are transmitted to clients or logged inappropriately.",
    "simplified_solution": "Never expose password hashes or sensitive cryptographic hashes in API responses, client-side code, or error messages. Use strong, salted hashing algorithms like bcrypt or Argon2 for passwords, implement proper API response sanitization, and secure your logging practices to prevent hash leakage.",
    "references": [
      {
        "name": "OWASP Password Storage Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "NIST Special Publication 800-63B",
        "url": "https://pages.nist.gov/800-63-3/sp800-63b.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure API Response Implementation",
        "solution_description": "This solution demonstrates how to prevent hash disclosure by implementing proper API response sanitization and ensuring sensitive hash values are never exposed to clients. The code shows secure user profile management that excludes password hashes and other sensitive cryptographic data from API responses, implements proper data transfer objects, and includes logging practices that avoid hash exposure.",
        "affected_files": "API controllers, user management endpoints, authentication services, response mappers, logging configuration files, error handling middleware, database query results processing, serialization layers",
        "code": "// =========================================================\n// SECURE API RESPONSE - PREVENT HASH DISCLOSURE\n// =========================================================\n\n// BEFORE (VULNERABLE): Exposing sensitive data\n/*\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        return ResponseEntity.ok(user); // Returns full user object with passwordHash, salt, etc.\n    }\n}\n*/\n\n// AFTER (SECURE): Proper data sanitization\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n    private final Logger logger = LoggerFactory.getLogger(UserController.class);\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<UserProfileDTO> getUserProfile(@PathVariable Long id) {\n        try {\n            User user = userService.findById(id);\n            UserProfileDTO profile = UserProfileDTO.fromUser(user);\n            \n            // Log security events without sensitive data\n            logger.info(\"User profile accessed: userId={}\", id);\n            \n            return ResponseEntity.ok(profile);\n        } catch (UserNotFoundException e) {\n            logger.warn(\"User profile access failed: userId={}, reason=not_found\", id);\n            return ResponseEntity.notFound().build();\n        } catch (Exception e) {\n            logger.error(\"User profile access error: userId={}\", id, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n    }\n}\n\n// =========================================================\n// SECURE DATA TRANSFER OBJECTS (DTOs)\n// =========================================================\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class UserProfileDTO {\n    private Long id;\n    private String username;\n    private String email;\n    private String fullName;\n    private LocalDateTime lastLogin;\n    private String role;\n    private boolean isActive;\n    \n    // Static factory method to safely convert from User entity\n    public static UserProfileDTO fromUser(User user) {\n        return UserProfileDTO.builder()\n                .id(user.getId())\n                .username(user.getUsername())\n                .email(user.getEmail())\n                .fullName(user.getFullName())\n                .lastLogin(user.getLastLogin())\n                .role(user.getRole())\n                .isActive(user.isActive())\n                .build();\n    }\n}\n\n// =========================================================\n// SECURE USER ENTITY\n// =========================================================\n\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(unique = true, nullable = false)\n    private String username;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Column(name = \"password_hash\", nullable = false)\n    private String passwordHash; // NEVER expose this\n    \n    @Column(name = \"salt\", nullable = false)\n    private String salt; // NEVER expose this\n    \n    @Column(name = \"reset_token\")\n    private String passwordResetToken; // NEVER expose this\n    \n    @Column(name = \"api_key\")\n    private String apiKey; // NEVER expose this\n    \n    // Getters and setters...\n    // Ensure JSON serialization excludes sensitive fields\n    \n    @JsonIgnore\n    public String getPasswordHash() {\n        return passwordHash;\n    }\n    \n    @JsonIgnore\n    public String getSalt() {\n        return salt;\n    }\n    \n    @JsonIgnore\n    public String getPasswordResetToken() {\n        return passwordResetToken;\n    }\n    \n    @JsonIgnore\n    public String getApiKey() {\n        return apiKey;\n    }\n}\n\n// =========================================================\n// SECURE AUTHENTICATION SERVICE\n// =========================================================\n\n@Service\npublic class AuthenticationService {\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);\n    \n    @Autowired\n    public AuthenticationService(UserRepository userRepository, PasswordEncoder passwordEncoder) {\n        this.userRepository = userRepository;\n        this.passwordEncoder = passwordEncoder;\n    }\n    \n    public AuthenticationResponse authenticateUser(LoginRequest request) {\n        try {\n            User user = userRepository.findByUsername(request.getUsername())\n                    .orElseThrow(() -> new AuthenticationException(\"Invalid credentials\"));\n            \n            if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {\n                logger.warn(\"Authentication failed: username={}, reason=invalid_password\", request.getUsername());\n                throw new AuthenticationException(\"Invalid credentials\");\n            }\n            \n            if (!user.isActive()) {\n                logger.warn(\"Authentication failed: username={}, reason=account_disabled\", request.getUsername());\n                throw new AuthenticationException(\"Account disabled\");\n            }\n            \n            // Generate secure token\n            String token = generateSecureToken(user);\n            \n            // Log successful authentication without sensitive data\n            logger.info(\"Authentication successful: userId={}, username={}\", user.getId(), user.getUsername());\n            \n            return AuthenticationResponse.builder()\n                    .token(token)\n                    .userProfile(UserProfileDTO.fromUser(user))\n                    .expiresIn(3600)\n                    .build();\n                    \n        } catch (AuthenticationException e) {\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"Authentication error: username={}\", request.getUsername(), e);\n            throw new AuthenticationException(\"Authentication failed\");\n        }\n    }\n    \n    private String generateSecureToken(User user) {\n        // Implement secure JWT generation\n        return Jwts.builder()\n                .setSubject(user.getUsername())\n                .claim(\"userId\", user.getId())\n                .claim(\"role\", user.getRole())\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + 3600000))\n                .signWith(SignatureAlgorithm.HS512, getSigningKey())\n                .compact();\n    }\n    \n    private byte[] getSigningKey() {\n        // Load secure signing key from environment\n        String secretKey = Environment.getenv(\"JWT_SECRET_KEY\");\n        if (secretKey == null || secretKey.length() < 64) {\n            throw new IllegalStateException(\"Secure JWT signing key not configured\");\n        }\n        return Decoders.BASE64.decode(secretKey);\n    }\n}\n\n// =========================================================\n// SECURE PASSWORD HASHING\n// =========================================================\n\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        // Use bcrypt with proper strength (10-12 rounds)\n        return new BCryptPasswordEncoder(12);\n    }\n    \n    @Bean\n    public AuthenticationProvider authenticationProvider(UserService userService) {\n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();\n        provider.setUserDetailsService(userService);\n        provider.setPasswordEncoder(passwordEncoder());\n        return provider;\n    }\n}\n\n@Service\npublic class PasswordService {\n    private final PasswordEncoder passwordEncoder;\n    private final SecureRandom secureRandom;\n    \n    public PasswordService(PasswordEncoder passwordEncoder) {\n        this.passwordEncoder = passwordEncoder;\n        this.secureRandom = new SecureRandom();\n    }\n    \n    public String hashPassword(String plainPassword) {\n        if (plainPassword == null || plainPassword.length() < 8) {\n            throw new IllegalArgumentException(\"Password must be at least 8 characters\");\n        }\n        return passwordEncoder.encode(plainPassword);\n    }\n    \n    public boolean verifyPassword(String plainPassword, String hashedPassword) {\n        return passwordEncoder.matches(plainPassword, hashedPassword);\n    }\n}\n\n// =========================================================\n// SECURE LOGGING CONFIGURATION\n// =========================================================\n\n// logback-spring.xml\n/*\n<configuration>\n    <springProfile name=\"!prod\">\n        <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n            <encoder>\n                <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n            </encoder>\n        </appender>\n        <root level=\"INFO\">\n            <appender-ref ref=\"CONSOLE\" />\n        </root>\n    </springProfile>\n    \n    <springProfile name=\"prod\">\n        <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n            <file>/var/log/application.log</file>\n            <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n                <fileNamePattern>/var/log/application.%d{yyyy-MM-dd}.log</fileNamePattern>\n                <maxHistory>30</maxHistory>\n            </rollingPolicy>\n            <encoder>\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n            </encoder>\n        </appender>\n        <root level=\"WARN\">\n            <appender-ref ref=\"FILE\" />\n        </root>\n    </springProfile>\n    \n    <!-- Prevent logging of sensitive data -->\n    <logger name=\"com.yourapp.security\" level=\"INFO\" additivity=\"false\">\n        <appender-ref ref=\"FILE\" />\n    </logger>\n</configuration>\n*/\n\n// =========================================================\n// API RESPONSE FILTERS\n// =========================================================\n\n@Component\npublic class SensitiveDataFilter implements OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                  HttpServletResponse response, \n                                  FilterChain filterChain) \n                                  throws ServletException, IOException {\n        \n        ContentCachingResponseWrapper wrappedResponse = new ContentCachingResponseWrapper(response);\n        \n        filterChain.doFilter(request, wrappedResponse);\n        \n        // Analyze response for sensitive data\n        byte[] responseBytes = wrappedResponse.getContentAsByteArray();\n        String responseBody = new String(responseBytes, StandardCharsets.UTF_8);\n        \n        if (containsSensitiveData(responseBody)) {\n            logger.warn(\"Potential sensitive data exposure detected: path={}, method={}\", \n                       request.getRequestURI(), request.getMethod());\n            \n            // Replace response with sanitized version\n            String sanitizedResponse = sanitizeResponse(responseBody);\n            \n            response.setContentLength(sanitizedResponse.length());\n            response.getWriter().write(sanitizedResponse);\n        } else {\n            wrappedResponse.copyBodyToResponse();\n        }\n    }\n    \n    private boolean containsSensitiveData(String content) {\n        String[] sensitivePatterns = {\n            \"password_hash\",\n            \"salt\",\n            \"api_key\",\n            \"token\",\n            \"secret\",\n            \"\\\\$2[aby]\\\\$\", // bcrypt pattern\n            \"\\\\$[5-6]\\\\$\", // SHA256/SHA512 pattern\n            \"resetToken\",\n            \"accessToken\"\n        };\n        \n        for (String pattern : sensitivePatterns) {\n            if (Pattern.compile(Pattern.quote(pattern), Pattern.CASE_INSENSITIVE)\n                     .matcher(content).find()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private String sanitizeResponse(String content) {\n        // Remove or mask sensitive fields from JSON responses\n        return content.replaceAll(\"\\\\\\\"password_hash\\\\\\\"\\\\s*\\\\:\\\\s*\\\\\\\"[^\\\\\\\"]*\\\\\\\"\", \"\\\"password_hash\\\":\\\"[REDACTED]\\\"\")\n                     .replaceAll(\"\\\\\\\"salt\\\\\\\"\\\\s*\\\\:\\\\s*\\\\\\\"[^\\\\\\\"]*\\\\\\\"\", \"\\\"salt\\\":\\\"[REDACTED]\\\"\")\n                     .replaceAll(\"\\\\\\\"api_key\\\\\\\"\\\\s*\\\\:\\\\s*\\\\\\\"[^\\\\\\\"]*\\\\\\\"\", \"\\\"api_key\\\":\\\"[REDACTED]\\\"\");\n    }\n}\n\n// =========================================================\n// CLIENT-SIDE VALIDATION\n// =========================================================\n\n// NEVER include password validation in client-side JavaScript\n// Always validate on server-side only\n\n// BAD: Client-side hash exposure\n/*\nfunction validatePassword(password) {\n    // Never do this in frontend\n    const hashedPassword = md5(password); // Exposes hashing logic\n    return hashedPassword === storedHash; // Exposes stored hash\n}\n*/\n\n// GOOD: Simple validation hints only\nfunction validatePasswordRequirements(password) {\n    const requirements = {\n        minLength: password.length >= 8,\n        hasUppercase: /[A-Z]/.test(password),\n        hasLowercase: /[a-z]/.test(password),\n        hasNumbers: /\\d/.test(password),\n        hasSpecialChar: /[!@#$%^&*(),.?\\\":{}|<>]/.test(password)\n    };\n    \n    return {\n        isValid: Object.values(requirements).every(Boolean),\n        requirements: requirements\n    };\n}\n\n// =========================================================\n// SECURITY TESTING\n// =========================================================\n\n/*\nSECURITY TEST PLAN:\n\n1. API Response Testing:\n   - Verify no password hashes in any API responses\n   - Check authentication endpoints don't expose sensitive data\n   - Test error responses don't contain stack traces with hashes\n\n2. Log File Analysis:\n   - Review logs for exposed password hashes\n   - Ensure no sensitive data in log files\n   - Verify proper log levels are configured\n\n3. Database Access Testing:\n   - Ensure application users have limited database access\n   - Verify no direct database query results in client responses\n   - Test SQL injection protection\n\n4. Memory Dump Protection:\n   - Configure JVM to prevent heap dumps on OutOfMemoryError\n   - Implement proper exception handling\n   - Use secure key storage solutions\n\n5. Automated Security Testing:\n   - Integrate OWASP ZAP scans in CI/CD\n   - Use dependency scanning tools\n   - Implement secrets scanning in code repositories\n\nTESTING COMMANDS:\n\n# API Security Testing\ncurl -X GET \"http://localhost:8080/api/users/1\" | grep -i \"password\\|hash\\|salt\"\n\n# Log Analysis for sensitive data\ngrep -i \"password.*hash\\|salt\\|token\" /var/log/application.log\n\n# Database query testing\nSELECT * FROM information_schema.columns WHERE column_name LIKE '%password%' OR column_name LIKE '%hash%';\n\n# Memory dump protection testing\njava -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/dumps YourApp\n# Verify no dumps contain sensitive data\n*/\n\n// =========================================================\n// IMMEDIATE SECURITY ACTIONS\n// =========================================================\n\n/*\nCRITICAL ACTIONS REQUIRED:\n\n1. IMMEDIATE (Today):\n   - Audit all API endpoints for hash exposure\n   - Review logging configuration for sensitive data\n   - Disable detailed error messages in production\n   - Implement response sanitization filters\n\n2. SHORT TERM (This Week):\n   - Update all DTOs to exclude sensitive fields\n   - Implement proper JSON serialization annotations\n   - Add comprehensive logging filters\n   - Deploy monitoring for hash disclosure attempts\n\n3. MEDIUM TERM (Next 2 Weeks):\n   - Migrate to secure password hashing (bcrypt/Argon2)\n   - Implement proper secrets management\n   - Add automated security testing\n   - Train development team on secure coding practices\n\n4. LONG TERM (Next Month):\n   - Implement key rotation policies\n   - Set up security monitoring and alerting\n   - Conduct penetration testing\n   - Establish security code review processes\n\nSECURITY MONITORING:\n- Set up alerts for API responses containing sensitive patterns\n- Monitor log files for hash exposure\n- Implement rate limiting on authentication endpoints\n- Regular security scans and audits\n*/"
      }
    ]
  },
  {
    "pluginId": 10105,
    "title": "Weak Authentication Method",
    "defaultRisk": "Medium",
    "cweid": "287",
    "description": "The application uses weak authentication mechanisms such as Basic Authentication without HTTPS, hardcoded credentials, predictable session tokens, or insufficient password policies. These weaknesses allow attackers to easily compromise user accounts through credential theft, brute force attacks, or session hijacking.",
    "simplified_description": "Your application has weak security for logging in, like using a simple lock that can be easily picked or having a password system that's too easy to guess. Attackers can break into user accounts, steal personal information, and take over the system.",
    "solution": "Implement strong multi-factor authentication, use HTTPS for all authentication, enforce robust password policies, implement proper session management, and add protection against brute force attacks and credential stuffing.",
    "simplified_solution": "Enable HTTPS for all login processes, require strong passwords with complexity rules, add multi-factor authentication (like SMS codes or authenticator apps), implement account lockout after failed attempts, and use secure session management.",
    "references": [
      {
        "name": "OWASP Authentication Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-287: Improper Authentication",
        "url": "https://cwe.mitre.org/data/definitions/287.html"
      },
      {
        "name": "NIST SP 800-63B: Digital Identity Guidelines",
        "url": "https://pages.nist.gov/800-63-3/sp800-63b.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Strong Authentication Implementation",
        "solution_description": "This solution provides comprehensive implementation of strong authentication including password policies, multi-factor authentication, brute force protection, secure session management, and proper credential handling across multiple platforms and technologies.",
        "affected_files": "Authentication controllers, login forms, password policies, session management, user registration systems, API authentication middleware, database credential storage",
        "code": "<?php\n\n// ==================================================\n// SECURE AUTHENTICATION CONFIGURATION\n// ==================================================\n\nclass SecureAuthenticationSystem {\n    private $database;\n    private $rateLimiter;\n    private $twoFactorService;\n    private $sessionManager;\n    private $passwordPolicy;\n    \n    public function __construct(\n        DatabaseInterface $database,\n        RateLimiter $rateLimiter,\n        TwoFactorService $twoFactorService,\n        SessionManager $sessionManager\n    ) {\n        $this->database = $database;\n        $this->rateLimiter = $rateLimiter;\n        $this->twoFactorService = $twoFactorService;\n        $this->sessionManager = $sessionManager;\n        $this->passwordPolicy = new PasswordPolicy();\n    }\n    \n    /**\n     * Secure login with multi-factor authentication\n     */\n    public function authenticateUser(string $username, string $password, ?string $twoFactorCode = null): array {\n        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';\n        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';\n        \n        // Rate limiting - prevent brute force\n        if (!$this->rateLimiter->checkLoginAttempts($clientIp, $username)) {\n            $this->logSecurityEvent('login_rate_limit_exceeded', [\n                'username' => $username,\n                'ip' => $clientIp,\n                'user_agent' => $userAgent\n            ]);\n            \n            return [\n                'success' => false,\n                'error' => 'Too many login attempts. Please try again later.',\n                'retry_after' => $this->rateLimiter->getRetryTime($clientIp)\n            ];\n        }\n        \n        // Retrieve user with secure query\n        $user = $this->getUserByUsername($username);\n        if (!$user) {\n            // Use constant-time comparison to prevent timing attacks\n            $this->constantTimeCompare($password, '$2y$10$dummydummydummydummydumm');\n            $this->rateLimiter->recordFailedAttempt($clientIp, $username);\n            \n            return [\n                'success' => false,\n                'error' => 'Invalid credentials'\n            ];\n        }\n        \n        // Check if account is locked\n        if ($user['locked_until'] && $user['locked_until'] > time()) {\n            return [\n                'success' => false,\n                'error' => 'Account is temporarily locked. Please try again later.',\n                'locked_until' => $user['locked_until']\n            ];\n        }\n        \n        // Verify password securely\n        if (!password_verify($password, $user['password_hash'])) {\n            $this->rateLimiter->recordFailedAttempt($clientIp, $username);\n            $this->incrementFailedLoginAttempts($user['id']);\n            \n            // Lock account after too many failed attempts\n            if ($user['failed_attempts'] >= $this->getMaxFailedAttempts()) {\n                $this->lockAccount($user['id']);\n            }\n            \n            return [\n                'success' => false,\n                'error' => 'Invalid credentials'\n            ];\n        }\n        \n        // Check if password needs rehashing (for algorithm upgrades)\n        if (password_needs_rehash($user['password_hash'], PASSWORD_ARGON2ID)) {\n            $this->updatePasswordHash($user['id'], $password);\n        }\n        \n        // Check if 2FA is enabled\n        if ($user['two_factor_enabled']) {\n            if (!$twoFactorCode) {\n                // Request 2FA code\n                $tempToken = $this->generateTwoFactorTempToken($user['id']);\n                \n                return [\n                    'success' => false,\n                    'requires_two_factor' => true,\n                    'temp_token' => $tempToken,\n                    'two_factor_method' => $user['two_factor_method']\n                ];\n            }\n            \n            if (!$this->twoFactorService->verifyCode($user['id'], $twoFactorCode)) {\n                $this->rateLimiter->recordFailedAttempt($clientIp, $username);\n                \n                return [\n                    'success' => false,\n                    'error' => 'Invalid two-factor authentication code'\n                ];\n            }\n        }\n        \n        // Successful authentication\n        $this->resetFailedLoginAttempts($user['id']);\n        $sessionId = $this->createSecureSession($user);\n        \n        $this->logSecurityEvent('login_success', [\n            'user_id' => $user['id'],\n            'ip' => $clientIp,\n            'user_agent' => $userAgent,\n            'two_factor_used' => $user['two_factor_enabled']\n        ]);\n        \n        return [\n            'success' => true,\n            'session_id' => $sessionId,\n            'user' => [\n                'id' => $user['id'],\n                'display_name' => $user['display_name'],\n                'last_login' => $user['last_login']\n            ]\n        ];\n    }\n    \n    /**\n     * Secure user registration with strong password policy\n     */\n    public function registerUser(array $userData): array {\n        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';\n        \n        // Rate limiting for registration\n        if (!$this->rateLimiter->checkRegistrationAttempts($clientIp)) {\n            return [\n                'success' => false,\n                'error' => 'Too many registration attempts. Please try again later.'\n            ];\n        }\n        \n        // Validate input data\n        $validation = $this->validateRegistrationData($userData);\n        if (!$validation['valid']) {\n            return [\n                'success' => false,\n                'error' => 'Invalid registration data',\n                'field_errors' => $validation['errors']\n            ];\n        }\n        \n        // Validate password strength\n        $passwordValidation = $this->passwordPolicy->validate($userData['password']);\n        if (!$passwordValidation['valid']) {\n            return [\n                'success' => false,\n                'error' => 'Password does not meet security requirements',\n                'password_errors' => $passwordValidation['errors']\n            ];\n        }\n        \n        // Check if user already exists\n        if ($this->userExists($userData['username'], $userData['email'])) {\n            return [\n                'success' => false,\n                'error' => 'Username or email already exists'\n            ];\n        }\n        \n        // Create user with secure password hash\n        $passwordHash = password_hash($userData['password'], PASSWORD_ARGON2ID, [\n            'memory_cost' => 65536,\n            'time_cost' => 4,\n            'threads' => 1\n        ]);\n        \n        $userId = $this->createUser([\n            'username' => $userData['username'],\n            'email' => $userData['email'],\n            'display_name' => $userData['display_name'] ?? $userData['username'],\n            'password_hash' => $passwordHash,\n            'email_verified' => false,\n            'verification_token' => $this->generateSecureToken(),\n            'created_at' => time(),\n            'created_ip' => $clientIp\n        ]);\n        \n        // Send verification email\n        $this->sendVerificationEmail($userData['email'], $userId);\n        \n        $this->logSecurityEvent('user_registered', [\n            'user_id' => $userId,\n            'ip' => $clientIp,\n            'email' => $userData['email']\n        ]);\n        \n        return [\n            'success' => true,\n            'user_id' => $userId,\n            'message' => 'Registration successful. Please check your email for verification.'\n        ];\n    }\n    \n    private function createSecureSession(array $user): string {\n        return $this->sessionManager->createSecureSession([\n            'user_id' => $user['id'],\n            'username' => $user['username'],\n            'ip_address' => $_SERVER['REMOTE_ADDR'],\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'],\n            'authenticated_at' => time()\n        ]);\n    }\n    \n    private function constantTimeCompare(string $str1, string $str2): bool {\n        return hash_equals($str1, $str2);\n    }\n}\n\n// ==================================================\n// PASSWORD POLICY CLASS\n// ==================================================\n\nclass PasswordPolicy {\n    private $minLength = 12;\n    private $maxLength = 128;\n    private $requireUppercase = true;\n    private $requireLowercase = true;\n    private $requireNumbers = true;\n    private $requireSpecialChars = true;\n    private $forbiddenPatterns;\n    \n    public function __construct() {\n        $this->forbiddenPatterns = [\n            '/^[a-zA-Z]+$/',           // Only letters\n            '/^[0-9]+$/',              // Only numbers\n            '/(.)\\1{2,}/',            // Repeated characters (aaa, 111)\n            '/(012|123|234|345|456|567|678|789|890|987|876|765|654|543|432|321|210)/', // Sequential numbers\n            '/password|admin|root|user|login|welcome/i', // Common passwords\n            '/(.)\\1{1,}(.)\\2{1,}/'    // Repeated patterns (aabbcc)\n        ];\n    }\n    \n    public function validate(string $password): array {\n        $errors = [];\n        \n        // Length requirements\n        if (strlen($password) < $this->minLength) {\n            $errors[] = \"Password must be at least {$this->minLength} characters long\";\n        }\n        \n        if (strlen($password) > $this->maxLength) {\n            $errors[] = \"Password must not exceed {$this->maxLength} characters\";\n        }\n        \n        // Character requirements\n        if ($this->requireUppercase && !preg_match('/[A-Z]/', $password)) {\n            $errors[] = \"Password must contain at least one uppercase letter\";\n        }\n        \n        if ($this->requireLowercase && !preg_match('/[a-z]/', $password)) {\n            $errors[] = \"Password must contain at least one lowercase letter\";\n        }\n        \n        if ($this->requireNumbers && !preg_match('/[0-9]/', $password)) {\n            $errors[] = \"Password must contain at least one number\";\n        }\n        \n        if ($this->requireSpecialChars && !preg_match('/[!@#$%^&*()_+\\-=\\[\\]{};\\':\"\\\\|,.<>\\/?]/', $password)) {\n            $errors[] = \"Password must contain at least one special character\";\n        }\n        \n        // Check forbidden patterns\n        foreach ($this->forbiddenPatterns as $pattern) {\n            if (preg_match($pattern, $password)) {\n                $errors[] = \"Password contains forbidden patterns\";\n                break;\n            }\n        }\n        \n        // Check against common passwords list\n        if ($this->isCommonPassword($password)) {\n            $errors[] = \"Password is too common. Please choose a more secure password\";\n        }\n        \n        return [\n            'valid' => empty($errors),\n            'errors' => $errors,\n            'strength' => $this->calculateStrength($password)\n        ];\n    }\n    \n    private function isCommonPassword(string $password): bool {\n        $commonPasswords = file_get_contents(__DIR__ . '/common_passwords.txt');\n        $commonPasswordList = explode(\"\\n\", $commonPasswords);\n        \n        return in_array(strtolower($password), array_map('strtolower', $commonPasswordList));\n    }\n    \n    private function calculateStrength(string $password): string {\n        $score = 0;\n        \n        // Length bonus\n        $score += min(strlen($password) / 4, 5);\n        \n        // Character variety bonus\n        if (preg_match('/[a-z]/', $password)) $score += 1;\n        if (preg_match('/[A-Z]/', $password)) $score += 1;\n        if (preg_match('/[0-9]/', $password)) $score += 1;\n        if (preg_match('/[^a-zA-Z0-9]/', $password)) $score += 1;\n        \n        // Entropy bonus\n        $entropy = $this->calculateEntropy($password);\n        $score += min($entropy / 10, 3);\n        \n        if ($score >= 8) return 'very_strong';\n        if ($score >= 6) return 'strong';\n        if ($score >= 4) return 'medium';\n        if ($score >= 2) return 'weak';\n        return 'very_weak';\n    }\n    \n    private function calculateEntropy(string $password): float {\n        $charSetSize = 0;\n        if (preg_match('/[a-z]/', $password)) $charSetSize += 26;\n        if (preg_match('/[A-Z]/', $password)) $charSetSize += 26;\n        if (preg_match('/[0-9]/', $password)) $charSetSize += 10;\n        if (preg_match('/[^a-zA-Z0-9]/', $password)) $charSetSize += 32;\n        \n        return strlen($password) * log($charSetSize, 2);\n    }\n}\n\n// ==================================================\n// TWO-FACTOR AUTHENTICATION SERVICE\n// ==================================================\n\nclass TwoFactorService {\n    private $database;\n    private $emailService;\n    private $smsService;\n    \n    public function __construct(\n        DatabaseInterface $database,\n        EmailService $emailService,\n        SMSService $smsService\n    ) {\n        $this->database = $database;\n        $this->emailService = $emailService;\n        $this->smsService = $smsService;\n    }\n    \n    public function enableTwoFactor(int $userId, string $method, string $target): array {\n        $code = $this->generateTwoFactorCode();\n        \n        // Send verification code\n        if ($method === 'email') {\n            $this->emailService->sendTwoFactorCode($target, $code);\n        } elseif ($method === 'sms') {\n            $this->smsService->sendTwoFactorCode($target, $code);\n        } elseif ($method === 'totp') {\n            $secret = $this->generateTOTPSecret();\n            $this->updateUserTwoFactorSecret($userId, $secret);\n            return ['success' => true, 'secret' => $secret, 'qr_code' => $this->generateTOTPQRCode($secret)];\n        }\n        \n        // Store temporary code\n        $this->storeTempTwoFactorCode($userId, $code, $method, $target);\n        \n        return ['success' => true, 'message' => 'Verification code sent'];\n    }\n    \n    public function verifyCode(int $userId, string $code): bool {\n        $user = $this->getUserById($userId);\n        \n        if ($user['two_factor_method'] === 'totp') {\n            return $this->verifyTOTP($user['two_factor_secret'], $code);\n        } else {\n            return $this->verifyTempCode($userId, $code);\n        }\n    }\n    \n    private function generateTwoFactorCode(): string {\n        return str_pad(random_int(0, 999999), 6, '0', STR_PAD_LEFT);\n    }\n    \n    private function generateTOTPSecret(): string {\n        return strtoupper(implode(' ', str_split(bin2hex(random_bytes(16)), 4)));\n    }\n    \n    private function verifyTOTP(string $secret, string $code): bool {\n        // Implementation would use a TOTP library\n        // This is a simplified example\n        $timestamp = floor(time() / 30);\n        \n        for ($i = -1; $i <= 1; $i++) {\n            $expectedCode = $this->generateTOTPCode($secret, $timestamp + $i);\n            if (hash_equals($expectedCode, $code)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}\n\n// ==================================================\n// RATE LIMITER FOR AUTHENTICATION PROTECTION\n// ==================================================\n\nclass AuthenticationRateLimiter {\n    private $cache;\n    private $maxLoginAttempts = 5;\n    private $maxRegistrationAttempts = 3;\n    private $lockoutDuration = 900; // 15 minutes\n    \n    public function checkLoginAttempts(string $ip, string $username): bool {\n        $ipKey = \"login_attempts:ip:$ip\";\n        $userKey = \"login_attempts:user:$username\";\n        \n        $ipAttempts = $this->cache->get($ipKey, 0);\n        $userAttempts = $this->cache->get($userKey, 0);\n        \n        return $ipAttempts < $this->maxLoginAttempts && $userAttempts < $this->maxLoginAttempts;\n    }\n    \n    public function recordFailedAttempt(string $ip, string $username): void {\n        $ipKey = \"login_attempts:ip:$ip\";\n        $userKey = \"login_attempts:user:$username\";\n        \n        $this->cache->increment($ipKey);\n        $this->cache->increment($userKey);\n        $this->cache->expire($ipKey, $this->lockoutDuration);\n        $this->cache->expire($userKey, $this->lockoutDuration);\n    }\n    \n    public function getRetryTime(string $ip): int {\n        $ipKey = \"login_attempts:ip:$ip\";\n        return $this->cache->ttl($ipKey);\n    }\n}\n\n# ==================================================\n# NGINX CONFIGURATION FOR SECURE AUTHENTICATION\n# ==================================================\n\n# Force HTTPS for authentication endpoints\nserver {\n    listen 80;\n    server_name your-domain.com;\n    \n    # Redirect all HTTP to HTTPS\n    location / {\n        return 301 https://$server_name$request_uri;\n    }\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n    \n    # SSL configuration\n    ssl_certificate /path/to/certificate.crt;\n    ssl_certificate_key /path/to/private.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;\n    ssl_prefer_server_ciphers off;\n    \n    # Security headers\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\";\n    \n    # Rate limiting for authentication endpoints\n    limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/m;\n    limit_req_zone $binary_remote_addr zone=login_limit:10m rate=10r/m;\n    \n    location /api/auth/login {\n        limit_req zone=login_limit burst=5 nodelay;\n        \n        # Additional authentication security\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        proxy_pass http://backend;\n    }\n    \n    location /api/auth/register {\n        limit_req zone=auth_limit burst=3 nodelay;\n        \n        proxy_pass http://backend;\n    }\n    \n    # Block common authentication attack patterns\n    location ~* \\.(php|asp|jsp)$ {\n        # Block SQL injection attempts\n        if ($args ~* \"union.*select\") {\n            return 403;\n        }\n        \n        # Block XSS attempts\n        if ($args ~* \"<script\") {\n            return 403;\n        }\n        \n        proxy_pass http://backend;\n    }\n}\n\n# ==================================================\n# APACHE CONFIGURATION FOR SECURE AUTHENTICATION\n# ==================================================\n\n# Force HTTPS for authentication\n<VirtualHost *:80>\n    ServerName your-domain.com\n    DocumentRoot /var/www/html\n    \n    # Redirect all HTTP to HTTPS\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n</VirtualHost>\n\n<VirtualHost *:443>\n    ServerName your-domain.com\n    DocumentRoot /var/www/html\n    \n    # SSL Configuration\n    SSLEngine on\n    SSLCertificateFile /path/to/certificate.crt\n    SSLCertificateKeyFile /path/to/private.key\n    SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1\n    SSLCipherSuite ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512\n    \n    # Security Headers\n    Header always set Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\"\n    Header always set X-Frame-Options DENY\n    Header always set X-Content-Type-Options nosniff\n    Header always set X-XSS-Protection \"1; mode=block\"\n    Header always set Referrer-Policy \"strict-origin-when-cross-origin\"\n    \n    # Rate limiting for authentication endpoints\n    <Location \"/api/auth/login\">\n        # mod_security rules if available\n        SecRuleEngine On\n        SecRule ARGS \"@rx (union|select|insert|update|delete|drop)\" \"id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'\"\n        SecRule ARGS \"@rx <script\" \"id:1002,phase:2,deny,status:403,msg:'XSS Attempt'\"\n        \n        # Basic rate limiting (mod_evasive recommended)\n        # Require all granted\n    </Location>\n    \n    <Location \"/api/auth/register\">\n        # Similar security rules\n        # Require all granted\n    </Location>\n</VirtualHost>\n\n# ==================================================\n# JAVASCRIPT FRONTEND SECURITY\n# ==================================================\n\n/*\n// Secure authentication form handling\nclass SecureAuthForm {\n    constructor() {\n        this.setupSecureFormHandling();\n        this.setupPasswordStrengthIndicator();\n        this.setupRateLimitHandling();\n    }\n    \n    setupSecureFormHandling() {\n        const forms = document.querySelectorAll('form[data-auth-form]');\n        \n        forms.forEach(form => {\n            form.addEventListener('submit', async (e) => {\n                e.preventDefault();\n                \n                if (this.validateForm(form)) {\n                    await this.submitSecureForm(form);\n                }\n            });\n        });\n    }\n    \n    validateForm(form) {\n        const formData = new FormData(form);\n        const password = formData.get('password');\n        const confirmPassword = formData.get('confirm_password');\n        \n        // Password strength validation\n        if (password && !this.isPasswordStrong(password)) {\n            this.showError('Password does not meet security requirements');\n            return false;\n        }\n        \n        // Password confirmation\n        if (confirmPassword && password !== confirmPassword) {\n            this.showError('Passwords do not match');\n            return false;\n        }\n        \n        return true;\n    }\n    \n    async submitSecureForm(form) {\n        const formData = new FormData(form);\n        const formType = form.dataset.authForm;\n        \n        // Add CSRF token if available\n        const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')?.content;\n        if (csrfToken) {\n            formData.append('csrf_token', csrfToken);\n        }\n        \n        try {\n            const response = await fetch(form.action, {\n                method: form.method,\n                body: formData,\n                credentials: 'same-origin',\n                headers: {\n                    'X-Requested-With': 'XMLHttpRequest'\n                }\n            });\n            \n            const data = await response.json();\n            \n            if (data.success) {\n                this.handleAuthSuccess(data, formType);\n            } else {\n                this.handleAuthError(data);\n            }\n        } catch (error) {\n            this.showError('Network error. Please try again.');\n        }\n    }\n    \n    setupPasswordStrengthIndicator() {\n        const passwordInput = document.querySelector('#password');\n        const strengthIndicator = document.querySelector('#password-strength');\n        \n        if (passwordInput && strengthIndicator) {\n            passwordInput.addEventListener('input', () => {\n                const strength = this.calculatePasswordStrength(passwordInput.value);\n                this.updatePasswordStrengthIndicator(strength);\n            });\n        }\n    }\n    \n    calculatePasswordStrength(password) {\n        let score = 0;\n        \n        // Length\n        if (password.length >= 12) score += 2;\n        if (password.length >= 16) score += 1;\n        \n        // Character variety\n        if (/[a-z]/.test(password)) score += 1;\n        if (/[A-Z]/.test(password)) score += 1;\n        if (/[0-9]/.test(password)) score += 1;\n        if (/[^a-zA-Z0-9]/.test(password)) score += 1;\n        \n        // Complexity\n        if (/(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^a-zA-Z0-9])/.test(password)) {\n            score += 2;\n        }\n        \n        return Math.min(score, 8);\n    }\n    \n    handleAuthSuccess(data, formType) {\n        // Clear sensitive data from localStorage\n        localStorage.removeItem('temp_auth_data');\n        \n        if (formType === 'login') {\n            if (data.requires_two_factor) {\n                this.showTwoFactorForm(data.temp_token);\n            } else {\n                window.location.href = '/dashboard';\n            }\n        } else if (formType === 'register') {\n            window.location.href = '/verify-email';\n        }\n    }\n    \n    showTwoFactorForm(tempToken) {\n        const loginForm = document.querySelector('#login-form');\n        const twoFactorForm = document.querySelector('#two-factor-form');\n        \n        if (loginForm && twoFactorForm) {\n            loginForm.style.display = 'none';\n            twoFactorForm.style.display = 'block';\n            \n            // Store temp token securely\n            sessionStorage.setItem('temp_auth_token', tempToken);\n        }\n    }\n    \n    setupRateLimitHandling() {\n        // Handle rate limit responses\n        window.addEventListener('unhandledrejection', (event) => {\n            if (event.reason && event.reason.retry_after) {\n                this.showRateLimitError(event.reason.retry_after);\n            }\n        });\n    }\n}\n\n// Initialize secure authentication\ndocument.addEventListener('DOMContentLoaded', () => {\n    new SecureAuthForm();\n});\n*/\n\n# ==================================================\n# TESTING AND VALIDATION\n# ==================================================\n\n<?php\nclass AuthenticationSecurityTester {\n    private $baseUrl;\n    private $testUsers;\n    \n    public function __construct(string $baseUrl) {\n        $this->baseUrl = rtrim($baseUrl, '/');\n        $this->testUsers = [\n            'weak' => 'password123',\n            'common' => 'admin123',\n            'short' => '123',\n            'strong' => 'Str0ngP@ssw0rd!2024'\n        ];\n    }\n    \n    /**\n     * Test authentication security\n     */\n    public function testAuthenticationSecurity(): array {\n        $vulnerabilities = [];\n        \n        // Test 1: Weak password policy\n        $vulnerabilities = array_merge($vulnerabilities, $this->testPasswordPolicy());\n        \n        // Test 2: Brute force protection\n        $vulnerabilities = array_merge($vulnerabilities, $this->testBruteForceProtection());\n        \n        // Test 3: HTTPS enforcement\n        $vulnerabilities = array_merge($vulnerabilities, $this->testHTTPSUsage());\n        \n        // Test 4: Secure password storage\n        $vulnerabilities = array_merge($vulnerabilities, $this->testPasswordStorage());\n        \n        // Test 5: Session security\n        $vulnerabilities = array_merge($vulnerabilities, $this->testSessionSecurity());\n        \n        return $vulnerabilities;\n    }\n    \n    private function testPasswordPolicy(): array {\n        $vulnerabilities = [];\n        \n        foreach ($this->testUsers as $userType => $password) {\n            $userData = [\n                'username' => \"test_$userType\",\n                'email' => \"test_$userType@example.com\",\n                'password' => $password,\n                'display_name' => \"Test $userType\"\n            ];\n            \n            $result = $this->testRegistration($userData);\n            \n            if ($result['success'] && in_array($userType, ['weak', 'common', 'short'])) {\n                $vulnerabilities[] = [\n                    'type' => 'Weak Password Policy',\n                    'user_type' => $userType,\n                    'password' => $password,\n                    'evidence' => 'Weak password was accepted'\n                ];\n            }\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testBruteForceProtection(): array {\n        $vulnerabilities = [];\n        $attempts = 0;\n        $maxAttempts = 20;\n        \n        for ($i = 0; $i < $maxAttempts; $i++) {\n            $result = $this->testLogin('nonexistent', 'wrongpassword' . $i);\n            \n            if ($result['rate_limited']) {\n                // Rate limiting is working\n                break;\n            }\n            \n            $attempts++;\n        }\n        \n        if ($attempts >= $maxAttempts) {\n            $vulnerabilities[] = [\n                'type' => 'No Brute Force Protection',\n                'attempts_made' => $maxAttempts,\n                'evidence' => 'Account lockout not triggered after multiple failed attempts'\n            ];\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testHTTPSUsage(): array {\n        $vulnerabilities = [];\n        \n        // Test if HTTP endpoint is available\n        $httpUrl = str_replace('https://', 'http://', $this->baseUrl);\n        $httpResult = $this->testEndpoint($httpUrl . '/api/auth/login', 'POST', [\n            'username' => 'test',\n            'password' => 'test'\n        ]);\n        \n        if ($httpResult['accessible']) {\n            $vulnerabilities[] = [\n                'type' => 'HTTP Authentication Available',\n                'url' => $httpUrl . '/api/auth/login',\n                'evidence' => 'Authentication endpoint available over HTTP'\n            ];\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testPasswordStorage(): array {\n        $vulnerabilities = [];\n        \n        // Register a test user\n        $userData = [\n            'username' => 'test_storage',\n            'email' => 'test_storage@example.com',\n            'password' => 'TestPassword123!'\n        ];\n        \n        $registrationResult = $this->testRegistration($userData);\n        \n        if ($registrationResult['success']) {\n            // Check if password hash is properly stored (this would require database access)\n            // For external testing, we can only verify successful registration\n            // In a real scenario, you'd need database access to check hash strength\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testSessionSecurity(): array {\n        $vulnerabilities = [];\n        \n        // Test login and check session cookie security\n        $loginResult = $this->testLogin('testuser', $this->testUsers['strong']);\n        \n        if (isset($loginResult['cookies'])) {\n            foreach ($loginResult['cookies'] as $cookie) {\n                if (isset($cookie['session']) || isset($cookie['auth'])) {\n                    $issues = [];\n                    \n                    if (!($cookie['secure'] ?? false)) {\n                        $issues[] = 'Missing Secure flag';\n                    }\n                    \n                    if (!($cookie['httponly'] ?? false)) {\n                        $issues[] = 'Missing HttpOnly flag';\n                    }\n                    \n                    if (!($cookie['samesite'] ?? false)) {\n                        $issues[] = 'Missing SameSite attribute';\n                    }\n                    \n                    if (!empty($issues)) {\n                        $vulnerabilities[] = [\n                            'type' => 'Insecure Session Cookie',\n                            'cookie_name' => $cookie['name'] ?? 'session',\n                            'issues' => $issues\n                        ];\n                    }\n                }\n            }\n        }\n        \n        return $vulnerabilities;\n    }\n    \n    private function testRegistration(array $userData): array {\n        return $this->testEndpoint($this->baseUrl . '/api/auth/register', 'POST', $userData);\n    }\n    \n    private function testLogin(string $username, string $password): array {\n        return $this->testEndpoint($this->baseUrl . '/api/auth/login', 'POST', [\n            'username' => $username,\n            'password' => $password\n        ]);\n    }\n    \n    private function testEndpoint(string $url, string $method, array $data = []): array {\n        $context = stream_context_create([\n            'http' => [\n                'method' => $method,\n                'header' => 'Content-Type: application/json',\n                'content' => json_encode($data),\n                'timeout' => 10,\n                'user_agent' => 'Security-Scanner/1.0',\n                'ignore_errors' => true\n            ]\n        ]);\n        \n        $response = @file_get_contents($url, false, $context);\n        $headers = $http_response_header ?? [];\n        \n        $statusCode = 0;\n        foreach ($headers as $header) {\n            if (strpos($header, 'HTTP/') === 0) {\n                $parts = explode(' ', $header);\n                $statusCode = (int)($parts[1] ?? 0);\n                break;\n            }\n        }\n        \n        $responseData = $response ? json_decode($response, true) : [];\n        \n        return [\n            'accessible' => $statusCode !== 0,\n            'status_code' => $statusCode,\n            'success' => ($responseData['success'] ?? false),\n            'rate_limited' => ($statusCode === 429),\n            'cookies' => $this->extractCookies($headers)\n        ];\n    }\n    \n    private function extractCookies(array $headers): array {\n        $cookies = [];\n        \n        foreach ($headers as $header) {\n            if (strpos($header, 'Set-Cookie:') === 0) {\n                $cookieString = substr($header, 11);\n                $parts = explode(';', $cookieString);\n                \n                if (!empty($parts[0])) {\n                    $nameValue = explode('=', trim($parts[0]), 2);\n                    if (count($nameValue) === 2) {\n                        $cookie = [\n                            'name' => $nameValue[0],\n                            'session' => strpos(strtolower($nameValue[0]), 'session') !== false || \n                                     strpos(strtolower($nameValue[0]), 'auth') !== false\n                        ];\n                        \n                        // Parse cookie attributes\n                        foreach ($parts as $part) {\n                            $part = trim($part);\n                            if (stripos($part, 'Secure') === 0) {\n                                $cookie['secure'] = true;\n                            } elseif (stripos($part, 'HttpOnly') === 0) {\n                                $cookie['httponly'] = true;\n                            } elseif (stripos($part, 'SameSite=') === 0) {\n                                $cookie['samesite'] = explode('=', $part, 2)[1];\n                            }\n                        }\n                        \n                        $cookies[] = $cookie;\n                    }\n                }\n            }\n        }\n        \n        return $cookies;\n    }\n    \n    public function generateReport(array $vulnerabilities): string {\n        $report = \"Authentication Security Report\\n\";\n        $report .= \"Generated: \" . date('Y-m-d H:i:s') . \"\\n\";\n        $report .= \"Base URL: {$this->baseUrl}\\n\";\n        $report .= \"================================\\n\\n\";\n        \n        if (empty($vulnerabilities)) {\n            $report .= \"✓ No authentication security vulnerabilities found.\\n\";\n        } else {\n            $report .= \"⚠ \" . count($vulnerabilities) . \" authentication issues found:\\n\\n\";\n            \n            foreach ($vulnerabilities as $vuln) {\n                $report .= \"Type: {$vuln['type']}\\n\";\n                $report .= \"Evidence: {$vuln['evidence']}\\n\";\n                \n                if (isset($vuln['user_type'])) {\n                    $report .= \"User Type: {$vuln['user_type']}\\n\";\n                }\n                \n                if (isset($vuln['attempts_made'])) {\n                    $report .= \"Attempts Made: {$vuln['attempts_made']}\\n\";\n                }\n                \n                if (isset($vuln['issues'])) {\n                    $report .= \"Issues: \" . implode(', ', $vuln['issues']) . \"\\n\";\n                }\n                \n                $report .= \"\\n\";\n            }\n        }\n        \n        return $report;\n    }\n}\n\n# ==================================================\n# IMMEDIATE ACTION PLAN\n# ==================================================\n\n/*\nCRITICAL STEPS (Execute within 1 week):\n\n1. Implement strong password policy:\n   - Minimum 12 characters\n   - Require uppercase, lowercase, numbers, special chars\n   - Check against common passwords\n   - Implement password strength indicator\n\n2. Enable HTTPS for all authentication:\n   - Install SSL/TLS certificate\n   - Redirect HTTP to HTTPS\n   - Use HSTS headers\n   - Update all authentication endpoints\n\n3. Add multi-factor authentication:\n   - Implement TOTP support (Google Authenticator)\n   - Add SMS/email verification\n   - Make 2FA optional for users\n   - Require 2FA for admin accounts\n\n4. Implement brute force protection:\n   - Rate limit login attempts\n   - Account lockout after failures\n   - IP-based restrictions\n   - CAPTCHA for repeated attempts\n\n5. Secure password storage:\n   - Use Argon2id or bcrypt\n   - Implement password hashing\n   - Regular hash rehashing\n   - Never store plaintext passwords\n\n6. Secure session management:\n   - Use secure cookie flags\n   - Implement session timeout\n   - Session regeneration\n   - Proper logout handling\n\nTIMELINE:\n- Day 1-2: Implement HTTPS and password policy\n- Day 3-4: Add brute force protection\n- Day 5-6: Implement multi-factor authentication\n- Day 7: Secure session management and testing\n- Ongoing: Monitor and maintain security\n\nVERIFICATION CHECKLIST:\n[ ] HTTPS enforced for all authentication\n[ ] Strong password policy implemented\n[ ] Multi-factor authentication available\n[ ] Brute force protection active\n[ ] Passwords securely hashed\n[ ] Secure session management\n[ ] Rate limiting configured\n[ ] Security monitoring enabled\n[ ] Regular security testing\n\nTESTING PROCEDURES:\n# Test HTTPS enforcement\ncurl -I http://your-domain.com/api/auth/login\n# Should redirect to HTTPS\n\n# Test brute force protection\nfor i in {1..10}; do curl -X POST https://your-domain.com/api/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"test\",\"password\":\"wrong\"}'; done\n\n# Test password strength\ncurl -X POST https://your-domain.com/api/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"test\",\"email\":\"test@example.com\",\"password\":\"weak\"}'\n*/"
      }
    ]
  },
  {
    "pluginId": 10108,
    "title": "Reverse Tabnabbing",
    "defaultRisk": "Medium",
    "cweid": "1021",
    "description": "The application contains links that open new windows/tabs without proper rel attributes, making it vulnerable to reverse tabnabbing attacks. This allows malicious sites to take control of the original tab when a user clicks back, potentially leading to phishing attacks.",
    "simplified_description": "Your website has links that open new tabs without proper security protection. This vulnerability allows malicious websites to hijack the original tab when users click back to it. Attackers can replace your website with a fake login page to steal user credentials - it's like someone changing the sign on your office door while you're away.",
    "solution": "Add proper rel attributes (noopener and noreferrer) to all external links and implement Content Security Policy headers for additional protection.",
    "simplified_solution": "Add rel=\"noopener noreferrer\" to all external links, use target=\"_blank\" safely, implement CSP headers to restrict window.opener access, and consider using link sanitization in your framework.",
    "references": [
      {
        "name": "OWASP HTML5 Security Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/HTML5_Security_Cheat_Sheet.html"
      },
      {
        "name": "CWE-1021: Improper Restriction of Rendered UI Layers or Frames",
        "url": "https://cwe.mitre.org/data/definitions/1021.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Reverse Tabnabbing Prevention Implementation",
        "solution_description": "This solution demonstrates how to prevent reverse tabnabbing attacks by adding proper rel attributes to external links, implementing CSP headers, and creating secure link components that automatically apply necessary security attributes.",
        "affected_files": "HTML templates, React components, Angular components, Vue components, link generation utilities, CMS systems",
        "code": "<!-- BAD: Vulnerable external link -->\n<a href=\"https://externalsite.com\" target=\"_blank\">Visit External Site</a>\n<!-- Vulnerable: new tab can access window.opener and redirect original tab -->\n\n<!-- GOOD: Secure external link -->\n<a href=\"https://externalsite.com\" target=\"_blank\" \n   rel=\"noopener noreferrer\">Visit External Site</a>\n<!-- Secure:noopener prevents window.opener access, noreferrer prevents referrer leakage -->\n\n<!-- ======================================== -->\n<!-- REACT COMPONENT IMPLEMENTATION -->\n<!-- ======================================== -->\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\n// BAD: Vulnerable link component\nconst BadExternalLink = ({ href, children, ...props }) => (\n    <a href={href} target=\"_blank\" {...props}>\n        {children}\n    </a>\n);\n\n// GOOD: Secure external link component\nconst SecureExternalLink = ({ \n    href, \n    children, \n    rel = 'noopener noreferrer',\n    className,\n    ...props \n}) => {\n    // Validate URL before rendering\n    const isValidUrl = isValidExternalUrl(href);\n    \n    if (!isValidUrl) {\n        console.warn(`Invalid external URL: ${href}`);\n        return <span className={className}>{children}</span>;\n    }\n    \n    return (\n        <a \n            href={href}\n            target=\"_blank\"\n            rel={rel}\n            className={className}\n            {...props}\n        >\n            {children}\n        </a>\n    );\n};\n\nSecureExternalLink.propTypes = {\n    href: PropTypes.string.isRequired,\n    children: PropTypes.node.isRequired,\n    rel: PropTypes.string,\n    className: PropTypes.string\n};\n\n// URL validation helper\nconst isValidExternalUrl = (url) => {\n    if (!url || typeof url !== 'string') {\n        return false;\n    }\n    \n    try {\n        const parsedUrl = new URL(url, window.location.origin);\n        \n        // Allow only HTTP/HTTPS\n        if (!['http:', 'https:'].includes(parsedUrl.protocol)) {\n            return false;\n        }\n        \n        // Check for suspicious patterns\n        const suspiciousPatterns = [\n            /javascript:/i,\n            /data:/i,\n            /vbscript:/i\n        ];\n        \n        return !suspiciousPatterns.some(pattern => pattern.test(url));\n        \n    } catch (error) {\n        return false;\n    }\n};\n\n// ======================================== -->\n<!-- ANGULAR COMPONENT IMPLEMENTATION -->\n<!-- ======================================== -->\n\nimport { Component, Input, HostBinding } from '@angular/core';\nimport { DomSanitizer, SafeUrl } from '@angular/platform-browser';\n\n@Component({\n    selector: 'app-secure-external-link',\n    template: `\n        <a \n            *ngIf=\"safeUrl; else noLink\"\n            [href]=\"safeUrl\"\n            target=\"_blank\"\n            [rel]=\"rel\"\n            [class]=\"className\"\n            (click)=\"handleClick($event)\">\n            <ng-content></ng-content>\n        </a>\n        <ng-template #noLink>\n            <span [class]=\"className\">\n                <ng-content></ng-content>\n            </span>\n        </ng-template>\n    `,\n    styles: [`\n        :host {\n            display: inline;\n        }\n    `]\n})\nexport class SecureExternalLinkComponent {\n    @Input() href: string;\n    @Input() rel: string = 'noopener noreferrer';\n    @Input() className: string;\n    \n    @HostBinding('attr.title') \n    get title() {\n        return this.safeUrl ? `Opens ${this.href} in a new tab` : 'Invalid link';\n    }\n    \n    safeUrl: SafeUrl | null = null;\n    \n    constructor(private sanitizer: DomSanitizer) {}\n    \n    ngOnInit() {\n        this.safeUrl = this.getSafeUrl(this.href);\n    }\n    \n    private getSafeUrl(url: string): SafeUrl | null {\n        if (!this.isValidExternalUrl(url)) {\n            return null;\n        }\n        \n        return this.sanitizer.bypassSecurityTrustUrl(url);\n    }\n    \n    private isValidExternalUrl(url: string): boolean {\n        try {\n            const parsedUrl = new URL(url, window.location.origin);\n            \n            // Security checks\n            return ['http:', 'https:'].includes(parsedUrl.protocol) &&\n                   !url.includes('javascript:') &&\n                   !url.includes('data:') &&\n                   !url.includes('vbscript:');\n                   \n        } catch {\n            return false;\n        }\n    }\n    \n    handleClick(event: MouseEvent) {\n        // Log click for analytics or security monitoring\n        if (this.safeUrl) {\n            console.log(`External link clicked: ${this.href}`);\n        }\n    }\n}\n\n// ======================================== -->\n<!-- VUE COMPONENT IMPLEMENTATION -->\n<!-- ======================================== -->\n\n<template>\n    <a v-if=\"safeUrl\" \n       :href=\"safeUrl\" \n       target=\"_blank\" \n       :rel=\"rel\"\n       :class=\"className\"\n       @click=\"handleClick\">\n        <slot></slot>\n    </a>\n    <span v-else :class=\"className\">\n        <slot></slot>\n    </span>\n</template>\n\n<script>\nexport default {\n    name: 'SecureExternalLink',\n    props: {\n        href: {\n            type: String,\n            required: true\n        },\n        rel: {\n            type: String,\n            default: 'noopener noreferrer'\n        },\n        className: {\n            type: String,\n            default: ''\n        }\n    },\n    computed: {\n        safeUrl() {\n            return this.validateExternalUrl(this.href);\n        }\n    },\n    methods: {\n        validateExternalUrl(url) {\n            if (!url || typeof url !== 'string') {\n                return null;\n            }\n            \n            try {\n                const parsedUrl = new URL(url, window.location.origin);\n                \n                // Security validation\n                const isHttpOrHttps = ['http:', 'https:'].includes(parsedUrl.protocol);\n                const hasNoSuspiciousPatterns = !/javascript:|data:|vbscript:/i.test(url);\n                \n                return (isHttpOrHttps && hasNoSuspiciousPatterns) ? url : null;\n                \n            } catch (error) {\n                return null;\n            }\n        },\n        handleClick(event) {\n            // Analytics or security logging\n            if (this.safeUrl) {\n                this.$emit('link-clicked', this.href);\n            }\n        }\n    }\n};\n</script>\n\n// ======================================== -->\n<!-- SECURITY UTILITY LIBRARY -->\n<!-- ======================================== -->\n\nclass LinkSecurityUtils {\n    /**\n     * Sanitizes and adds security attributes to external links\n     */\n    static sanitizeExternalLinks(container) {\n        const links = container.querySelectorAll('a[href]:not([href^=\"#\"]):not([href^=\"javascript:\"])');\n        \n        links.forEach(link => {\n            const href = link.getAttribute('href');\n            \n            // Check if it's an external link\n            if (this.isExternalLink(href)) {\n                // Add target=\"_blank\" if not present\n                if (!link.hasAttribute('target')) {\n                    link.setAttribute('target', '_blank');\n                }\n                \n                // Add security attributes\n                const existingRel = link.getAttribute('rel') || '';\n                const securityAttrs = ['noopener', 'noreferrer'];\n                \n                securityAttrs.forEach(attr => {\n                    if (!existingRel.includes(attr)) {\n                        link.setAttribute('rel', `${existingRel} ${attr}`.trim());\n                    }\n                });\n            }\n        });\n    }\n    \n    /**\n     * Checks if a URL is external to the current domain\n     */\n    static isExternalLink(url) {\n        try {\n            const linkUrl = new URL(url, window.location.origin);\n            const currentDomain = window.location.hostname;\n            \n            return linkUrl.hostname !== currentDomain && \n                   !linkUrl.hostname.endsWith(`.${currentDomain}`);\n                   \n        } catch (error) {\n            return false;\n        }\n    }\n    \n    /**\n     * Creates a secure external link element\n     */\n    static createSecureLink(href, text, className = '') {\n        const link = document.createElement('a');\n        \n        if (this.isValidExternalUrl(href)) {\n            link.href = href;\n            link.target = '_blank';\n            link.rel = 'noopener noreferrer';\n            link.textContent = text;\n            link.className = className;\n        } else {\n            // Fallback for invalid URLs\n            link.textContent = text;\n            link.className = `${className} disabled-link`;\n            link.style.pointerEvents = 'none';\n        }\n        \n        return link;\n    }\n    \n    /**\n     * Validates external URL security\n     */\n    static isValidExternalUrl(url) {\n        if (!url || typeof url !== 'string') {\n            return false;\n        }\n        \n        try {\n            const parsedUrl = new URL(url, window.location.origin);\n            \n            // Security checks\n            const allowedProtocols = ['http:', 'https:'];\n            const hasValidProtocol = allowedProtocols.includes(parsedUrl.protocol);\n            \n            const suspiciousPatterns = [\n                /javascript:/i,\n                /data:/i,\n                /vbscript:/i,\n                /\\0/,      // Null bytes\n                /[<>\"']/    // HTML injection chars\n            ];\n            \n            const hasNoSuspiciousPatterns = !suspiciousPatterns.some(pattern => \n                pattern.test(url)\n            );\n            \n            return hasValidProtocol && hasNoSuspiciousPatterns;\n            \n        } catch (error) {\n            return false;\n        }\n    }\n}\n\n// ======================================== -->\n<!-- AUTOMATIC LINK SANITIZATION -->\n<!-- ======================================== -->\n\n// Initialize link sanitization when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Sanitize all external links in the document\n    LinkSecurityUtils.sanitizeExternalLinks(document);\n    \n    // Set up MutationObserver to handle dynamically added content\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.addedNodes.forEach((node) => {\n                // Check if the added node is an element\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    // Sanitize links in the added node\n                    LinkSecurityUtils.sanitizeExternalLinks(node);\n                }\n            });\n        });\n    });\n    \n    // Observe the entire document for changes\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n});\n\n// ======================================== -->\n<!-- SERVER-SIDE IMPLEMENTATION (Node.js) -->\n<!-- ======================================== -->\n\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Set security headers to prevent tabnabbing\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", \"data:\", \"https:\"],\n            frameAncestors: [\"'none'\"]\n        }\n    },\n    referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n    crossOriginEmbedderPolicy: false\n}));\n\n// Middleware to sanitize HTML content\napp.use((req, res, next) => {\n    const originalJson = res.json;\n    res.json = function(data) {\n        if (data && typeof data === 'object') {\n            data = sanitizeObjectLinks(data);\n        }\n        return originalJson.call(this, data);\n    };\n    next();\n});\n\nfunction sanitizeObjectLinks(obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    \n    const sanitized = Array.isArray(obj) ? [] : {};\n    \n    for (const [key, value] of Object.entries(obj)) {\n        if (typeof value === 'string' && isExternalLink(value)) {\n            sanitized[key] = sanitizeExternalLink(value);\n        } else if (typeof value === 'object') {\n            sanitized[key] = sanitizeObjectLinks(value);\n        } else {\n            sanitized[key] = value;\n        }\n    }\n    \n    return sanitized;\n}\n\nfunction isExternalLink(url) {\n    try {\n        const parsedUrl = new URL(url);\n        return parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:';\n    } catch {\n        return false;\n    }\n}\n\nfunction sanitizeExternalLink(url) {\n    // This would return HTML with proper attributes\n    // In a real implementation, you might use a template engine\n    return `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">External Link</a>`;\n}\n\n// ======================================== -->\n<!-- TESTING AND VALIDATION -->\n<!-- ======================================== -->\n\n/*\nSECURITY TESTING CHECKLIST:\n\n1. Manual Testing:\n   - Click external links and verify they open in new tabs\n   - Check that window.opener is null in the new tab\n   - Verify referrer header is not sent to external sites\n   - Test with browser developer tools\n\n2. Automated Testing (Jest):\n```javascript\ndescribe('Link Security Utils', () => {\n    test('sanitizes external links correctly', () => {\n        const container = document.createElement('div');\n        container.innerHTML = '<a href=\"https://external.com\">Link</a>';\n        \n        LinkSecurityUtils.sanitizeExternalLinks(container);\n        \n        const link = container.querySelector('a');\n        expect(link.target).toBe('_blank');\n        expect(link.rel).toContain('noopener');\n        expect(link.rel).toContain('noreferrer');\n    });\n    \n    test('identifies external links correctly', () => {\n        expect(LinkSecurityUtils.isExternalLink('https://external.com'))\n            .toBe(true);\n        expect(LinkSecurityUtils.isExternalLink('/internal-page'))\n            .toBe(false);\n        expect(LinkSecurityUtils.isExternalLink('https://same-domain.com'))\n            .toBe(false);\n    });\n    \n    test('validates URLs correctly', () => {\n        expect(LinkSecurityUtils.isValidExternalUrl('https://trustedsite.com'))\n            .toBe(true);\n        expect(LinkSecurityUtils.isValidExternalUrl('javascript:alert(1)'))\n            .toBe(false);\n        expect(LinkSecurityUtils.isValidExternalUrl('data:text/html,<script>alert(1)</script>'))\n            .toBe(false);\n    });\n});\n```\n\n3. Browser Console Testing:\n```javascript\n// Test window.opener access\nconst newWindow = window.open('https://external.com', '_blank');\nsetTimeout(() => {\n    console.log('window.opener is null:', newWindow.opener === null);\n    // Should be true for secure links\n}, 1000);\n```\n\n4. Security Headers Validation:\n   - Content-Security-Policy header is present\n   - Referrer-Policy header is set correctly\n   - X-Content-Type-Options header is present\n   - X-Frame-Options header is set\n\n5. Cross-browser Testing:\n   - Test in Chrome, Firefox, Safari, Edge\n   - Verify behavior in mobile browsers\n   - Test with various popup blockers\n\nBEST PRACTICES:\n\n1. Always use rel=\"noopener noreferrer\" for external links\n2. Prefer target=\"_blank\" for external navigation\n3. Validate all external URLs before rendering\n4. Implement Content Security Policy headers\n5. Use secure component libraries that handle this automatically\n6. Educate developers about tabnabbing risks\n7. Regular security audits of link usage\n8. Monitor for suspicious link patterns\n*/"
      }
    ]
  },
  {
    "pluginId": 10111,
    "title": "Authentication Request Identified",
    "defaultRisk": "Low",
    "cweid": "200",
    "description": "Authentication request identification occurs when applications expose information about authentication mechanisms, credentials formats, or security patterns through error messages, response structures, or network traffic analysis, potentially assisting attackers in crafting targeted attacks.",
    "simplified_description": "Your application is revealing information about how your authentication system works, like showing attackers the exact type and format of locks you use on your doors. This information helps attackers understand your security patterns, discover valid usernames, and develop more effective attacks against your authentication system.",
    "solution": "Implement generic error messages and consistent responses that don't reveal authentication mechanisms or account status information.",
    "simplified_solution": "Use generic, identical error messages for all authentication failures regardless of the reason. Don't reveal whether usernames exist, passwords are incorrect, or accounts are locked. Implement consistent response times for all authentication attempts. Use secure redirects and avoid exposing authentication details in URLs or responses.",
    "references": [
      {
        "name": "OWASP Authentication Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Authentication Testing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Authentication Response Implementation",
        "solution_description": "This solution demonstrates secure authentication handling that prevents information disclosure through generic responses, consistent timing, rate limiting, and proper error handling that doesn't reveal authentication mechanisms or account status.",
        "affected_files": "Authentication controllers, login endpoints, password reset functionality, API response handlers, error page templates, frontend JavaScript",
        "code": "<?php\n// ============================================\n// SECURE AUTHENTICATION MANAGER\n// ============================================\n\nclass SecureAuthenticationManager {\n    private $userManager;\n    private $rateLimiter;\n    private $sessionManager;\n    \n    // Generic error messages\n    private const GENERIC_ERROR = 'Invalid credentials';\n    private const GENERIC_LOCKOUT = 'Account temporarily locked. Please try again later.';\n    private const GENERIC_SUCCESS = 'Authentication successful';\n    \n    public function __construct(\n        UserManager $userManager,\n        RateLimiter $rateLimiter,\n        SessionManager $sessionManager\n    ) {\n        $this->userManager = $userManager;\n        $this->rateLimiter = $rateLimiter;\n        $this->sessionManager = $sessionManager;\n    }\n    \n    /**\n     * Handle login attempt with security measures\n     */\n    public function handleLogin(string $identifier, string $password): array {\n        $startTime = microtime(true);\n        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';\n        \n        // Apply rate limiting\n        if (!$this->rateLimiter->attempt('login', $clientIp)) {\n            $this->enforceConsistentTiming($startTime);\n            return $this->createErrorResponse(self::GENERIC_LOCKOUT, 429);\n        }\n        \n        try {\n            // Attempt authentication\n            $authResult = $this->attemptAuthentication($identifier, $password);\n            \n            if ($authResult['success']) {\n                // Successful authentication\n                $this->rateLimiter->clear('login', $clientIp);\n                $this->createUserSession($authResult['user']);\n                \n                // Generate response\n                $response = $this->createSuccessResponse($authResult['user']);\n                $this->enforceConsistentTiming($startTime);\n                \n                return $response;\n            } else {\n                // Failed authentication\n                $this->rateLimiter->recordFailure('login', $clientIp);\n                \n                $response = $this->createErrorResponse(self::GENERIC_ERROR, 401);\n                $this->enforceConsistentTiming($startTime);\n                \n                return $response;\n            }\n        } catch (Exception $e) {\n            // Log actual error but return generic response\n            $response = $this->createErrorResponse(self::GENERIC_ERROR, 500);\n            $this->enforceConsistentTiming($startTime);\n            \n            return $response;\n        }\n    }\n    \n    /**\n     * Attempt authentication without revealing account existence\n     */\n    private function attemptAuthentication(string $identifier, string $password): array {\n        // Always perform the same operations regardless of account existence\n        $user = $this->userManager->getUserByIdentifier($identifier);\n        \n        if (!$user) {\n            // Account doesn't exist - simulate password verification\n            $this->simulatePasswordVerification($password);\n            return ['success' => false];\n        }\n        \n        // Account exists - verify password\n        if ($this->verifyPassword($password, $user['password_hash'])) {\n            // Additional security checks\n            if (!$this->isAccountActive($user)) {\n                return ['success' => false];\n            }\n            \n            return [\n                'success' => true,\n                'user' => $this->createSafeUserResponse($user)\n            ];\n        }\n        \n        return ['success' => false];\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 10112,
    "title": "Session Management Response Identified",
    "defaultRisk": "Medium",
    "cweid": "200",
    "description": "Session management response identification vulnerabilities occur when applications expose session-related information in responses, headers, or error messages, revealing session handling mechanisms, session state information, or authentication status that can assist attackers in session hijacking or manipulation attacks.",
    "simplified_description": "Your application is revealing information about how it manages user sessions, like exposing the internal wiring and control systems of your building's security. This information helps attackers understand your session management patterns, identify active sessions, and develop targeted session hijacking or fixation attacks against your users.",
    "solution": "Implement secure session handling that prevents session information disclosure through headers, responses, or error messages.",
    "simplified_solution": "Remove session identifiers from URLs, headers, and responses. Use secure, HttpOnly cookies for session management. Implement proper session validation without revealing session state. Use generic error messages that don't disclose session-related information. Ensure all session management operations happen server-side with minimal client-side exposure.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Session Management Testing",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Session Response Implementation",
        "solution_description": "This solution demonstrates comprehensive secure session management that prevents session information disclosure through proper cookie handling, secure headers, server-side session validation, and minimal client-side exposure of session-related data.",
        "affected_files": "Session middleware, authentication controllers, API response handlers, security headers configuration, error handling systems, frontend JavaScript",
        "code": "<?php\n// ============================================\n// SECURE SESSION RESPONSE MANAGER\n// ============================================\n\nclass SecureSessionResponseManager {\n    private $sessionManager;\n    private $config;\n    \n    public function __construct(SessionManager $sessionManager, array $config = []) {\n        $this->sessionManager = $sessionManager;\n        $this->config = array_merge([\n            'secure_cookies' => true,\n            'httponly_cookies' => true,\n            'samesite_cookies' => 'Strict',\n            'session_timeout' => 1800,\n            'max_session_lifetime' => 7200\n        ], $config);\n    }\n    \n    /**\n     * Handle session creation with secure response\n     */\n    public function handleSessionCreation($userId, array $userData = []): array {\n        // Generate secure session\n        $sessionId = $this->sessionManager->createSecureSession($userId, $userData);\n        \n        // Set secure session cookie\n        $this->setSecureSessionCookie($sessionId);\n        \n        // Return minimal response without session details\n        return [\n            'success' => true,\n            'message' => 'Session established',\n            'user' => $this->createSafeUserResponse($userData)\n        ];\n    }\n    \n    /**\n     * Set secure session cookie\n     */\n    private function setSecureSessionCookie(string $sessionId): void {\n        $cookieOptions = [\n            'expires' => 0, // Session cookie\n            'path' => '/',\n            'domain' => $this->getCookieDomain(),\n            'secure' => $this->config['secure_cookies'],\n            'httponly' => $this->config['httponly_cookies'],\n            'samesite' => $this->config['samesite_cookies']\n        ];\n        \n        // Set cookie with secure options\n        setcookie(\n            $this->getSessionCookieName(),\n            $sessionId,\n            $cookieOptions\n        );\n    }\n    \n    /**\n     * Get session cookie name\n     */\n    private function getSessionCookieName(): string {\n        return 'APP_SESSION';\n    }\n    \n    /**\n     * Get cookie domain\n     */\n    private function getCookieDomain(): string {\n        return $this->config['cookie_domain'] ?? '';\n    }\n    \n    /**\n     * Create safe user response without sensitive data\n     */\n    private function createSafeUserResponse(array $userData): array {\n        return [\n            'id' => $userData['public_id'] ?? null,\n            'username' => $userData['username'] ?? null,\n            'roles' => $userData['roles'] ?? []\n        ];\n    }\n    \n    /**\n     * Handle session validation without exposing details\n     */\n    public function handleSessionValidation(): array {\n        $isValid = $this->sessionManager->validateCurrentSession();\n        \n        if ($isValid) {\n            $userData = $this->sessionManager->getSessionUser();\n            return [\n                'success' => true,\n                'authenticated' => true,\n                'user' => $this->createSafeUserResponse($userData)\n            ];\n        }\n        \n        return [\n            'success' => true,\n            'authenticated' => false\n        ];\n    }\n    \n    /**\n     * Handle session termination\n     */\n    public function handleSessionTermination(): array {\n        // Destroy session\n        $this->sessionManager->destroySession();\n        \n        // Clear session cookie\n        $this->clearSessionCookie();\n        \n        return [\n            'success' => true,\n            'message' => 'Session terminated'\n        ];\n    }\n    \n    /**\n     * Clear session cookie\n     */\n    private function clearSessionCookie(): void {\n        setcookie(\n            $this->getSessionCookieName(),\n            '',\n            [\n                'expires' => time() - 3600,\n                'path' => '/',\n                'domain' => $this->getCookieDomain()\n            ]\n        );\n    }\n    \n    /**\n     * Set security headers to prevent session information disclosure\n     */\n    public function setSecurityHeaders(): void {\n        // Prevent session ID in URL\n        header('Referrer-Policy: strict-origin-when-cross-origin');\n        \n        // Prevent clickjacking\n        header('X-Frame-Options: DENY');\n        \n        // Prevent MIME type sniffing\n        header('X-Content-Type-Options: nosniff');\n        \n        // XSS protection\n        header('X-XSS-Protection: 1; mode=block');\n        \n        // Content Security Policy\n        header('Content-Security-Policy: default-src \\'self\\'; script-src \\'self\\'');\n        \n        // Prevent caching of authenticated pages\n        if ($this->sessionManager->isAuthenticated()) {\n            header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');\n            header('Pragma: no-cache');\n            header('Expires: 0');\n        }\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 10113,
    "title": "Verification Request Identified",
    "defaultRisk": "Low",
    "cweid": "200",
    "description": "Verification request identification vulnerabilities occur when applications expose information about account verification processes, password reset mechanisms, or email validation systems through URLs, responses, or timing differences, potentially allowing attackers to enumerate valid accounts or bypass verification controls.",
    "simplified_description": "Your application is revealing information about its account verification processes, like showing attackers how your email verification system works and which email addresses are valid. This helps attackers identify active accounts, understand your verification workflows, and potentially craft targeted attacks against your user base or bypass security controls.",
    "solution": "Implement generic verification responses that don't reveal account status and use consistent timing for all verification requests.",
    "simplified_solution": "Use identical success messages for all verification requests regardless of account existence. Implement consistent response times to prevent timing attacks. Don't reveal whether email addresses are registered or verified. Use secure token generation and validation methods. Ensure verification URLs expire and cannot be reused.",
    "references": [
      {
        "name": "OWASP Forgot Password Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "OWASP Testing Guide: Testing for Account Enumeration and Guessable User Account",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Authentication_Testing/04-Testing_for_User_Enumeration_and_Guessable_User_Account.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Verification Request Implementation",
        "solution_description": "This solution demonstrates secure verification handling that prevents account enumeration through generic responses, consistent timing, rate limiting, and proper token management for email verification, password reset, and account activation processes.",
        "affected_files": "Verification controllers, email services, token management systems, API response handlers, rate limiting middleware, frontend forms",
        "code": "<?php\n// ============================================\n// SECURE VERIFICATION MANAGER\n// ============================================\n\nclass SecureVerificationManager {\n    private $userManager;\n    private $emailService;\n    private $tokenManager;\n    private $rateLimiter;\n    \n    // Generic responses to prevent enumeration\n    private const GENERIC_SUCCESS = 'If the account exists, a verification email has been sent';\n    private const GENERIC_RATE_LIMIT = 'Too many verification attempts. Please try again later.';\n    private const GENERIC_ERROR = 'Verification request processing failed';\n    \n    public function __construct(\n        UserManager $userManager,\n        EmailService $emailService,\n        TokenManager $tokenManager,\n        RateLimiter $rateLimiter\n    ) {\n        $this->userManager = $userManager;\n        $this->emailService = $emailService;\n        $this->tokenManager = $tokenManager;\n        $this->rateLimiter = $rateLimiter;\n    }\n    \n    /**\n     * Handle email verification request\n     */\n    public function handleEmailVerificationRequest(string $email): array {\n        $startTime = microtime(true);\n        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';\n        \n        // Apply rate limiting\n        if (!$this->rateLimiter->attempt('email_verification', $clientIp)) {\n            $this->enforceConsistentTiming($startTime);\n            return $this->createGenericResponse(self::GENERIC_RATE_LIMIT, 429);\n        }\n        \n        try {\n            // Process verification request\n            $this->processEmailVerification($email);\n            \n            // Always return generic success message\n            $response = $this->createGenericResponse(self::GENERIC_SUCCESS, 200);\n            $this->enforceConsistentTiming($startTime);\n            \n            return $response;\n            \n        } catch (Exception $e) {\n            // Log actual error but return generic response\n            $this->logSecurityEvent('email_verification_error', $clientIp, $email, $e->getMessage());\n            \n            $response = $this->createGenericResponse(self::GENERIC_ERROR, 500);\n            $this->enforceConsistentTiming($startTime);\n            \n            return $response;\n        }\n    }\n    \n    /**\n     * Process email verification without revealing account existence\n     */\n    private function processEmailVerification(string $email): void {\n        $user = $this->userManager->getUserByEmail($email);\n        \n        if ($user && !$user['email_verified']) {\n            // Generate verification token\n            $verificationToken = $this->tokenManager->generateVerificationToken(\n                $user['id'],\n                'email_verification',\n                3600 // 1 hour expiry\n            );\n            \n            // Send verification email\n            $this->emailService->sendVerificationEmail(\n                $user['email'],\n                $user['username'],\n                $verificationToken\n            );\n        }\n        \n        // Always record the attempt for rate limiting\n        $this->rateLimiter->recordAttempt('email_verification', $email);\n    }\n    \n    /**\n     * Handle password reset request\n     */\n    public function handlePasswordResetRequest(string $identifier): array {\n        $startTime = microtime(true);\n        $clientIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';\n        \n        // Apply rate limiting\n        if (!$this->rateLimiter->attempt('password_reset', $clientIp)) {\n            $this->enforceConsistentTiming($startTime);\n            return $this->createGenericResponse(self::GENERIC_RATE_LIMIT, 429);\n        }\n        \n        try {\n            // Process password reset request\n            $this->processPasswordReset($identifier);\n            \n            // Always return generic success message\n            $response = $this->createGenericResponse(self::GENERIC_SUCCESS, 200);\n            $this->enforceConsistentTiming($startTime);\n            \n            return $response;\n            \n        } catch (Exception $e) {\n            $this->logSecurityEvent('password_reset_error', $clientIp, $identifier, $e->getMessage());\n            \n            $response = $this->createGenericResponse(self::GENERIC_ERROR, 500);\n            $this->enforceConsistentTiming($startTime);\n            \n            return $response;\n        }\n    }\n    \n    /**\n     * Process password reset without revealing account existence\n     */\n    private function processPasswordReset(string $identifier): void {\n        $user = $this->userManager->getUserByIdentifier($identifier);\n        \n        if ($user && $this->userManager->isEligibleForPasswordReset($user)) {\n            // Generate password reset token\n            $resetToken = $this->tokenManager->generateVerificationToken(\n                $user['id'],\n                'password_reset',\n                1800 // 30 minutes expiry\n            );\n            \n            // Send password reset email\n            $this->emailService->sendPasswordResetEmail(\n                $user['email'],\n                $user['username'],\n                $resetToken\n            );\n        }\n        \n        // Always record the attempt for rate limiting\n        $this->rateLimiter->recordAttempt('password_reset', $identifier);\n    }\n    \n    /**\n     * Handle token verification\n     */\n    public function handleTokenVerification(string $token, string $type): array {\n        try {\n            $startTime = microtime(true);\n            \n            // Validate token\n            $tokenData = $this->tokenManager->validateToken($token, $type);\n            \n            if (!$tokenData) {\n                $this->enforceConsistentTiming($startTime);\n                return $this->createGenericResponse('Invalid or expired verification link', 400);\n            }\n            \n            // Process verification based on type\n            switch ($type) {\n                case 'email_verification':\n                    $result = $this->processEmailVerificationToken($tokenData);\n                    break;\n                    \n                case 'password_reset':\n                    $result = $this->processPasswordResetToken($tokenData);\n                    break;\n                    \n                default:\n                    throw new InvalidArgumentException('Unknown verification type');\n            }\n            \n            $this->enforceConsistentTiming($startTime);\n            return $result;\n            \n        } catch (Exception $e) {\n            $this->logSecurityEvent('token_verification_error', $_SERVER['REMOTE_ADDR'], $token, $e->getMessage());\n            \n            return $this->createGenericResponse(self::GENERIC_ERROR, 500);\n        }\n    }\n    \n    /**\n     * Process email verification token\n     */\n    private function processEmailVerificationToken(array $tokenData): array {\n        // Mark email as verified\n        $this->userManager->markEmailVerified($tokenData['user_id']);\n        \n        return [\n            'success' => true,\n            'message' => 'Email verified successfully'\n        ];\n    }\n    \n    /**\n     * Process password reset token\n     */\n    private function processPasswordResetToken(array $tokenData): array {\n        // Generate temporary authentication for password reset\n        $tempToken = $this->tokenManager->generateTemporaryAuthToken(\n            $tokenData['user_id'],\n            'password_reset',\n            900 // 15 minutes expiry\n        );\n        \n        return [\n            'success' => true,\n            'message' => 'Password reset token validated',\n            'temp_token' => $tempToken\n        ];\n    }\n    \n    /**\n     * Create generic response\n     */\n    private function createGenericResponse(string $message, int $statusCode): array {\n        return [\n            'success' => $statusCode === 200,\n            'message' => $message\n        ];\n    }\n    \n    /**\n     * Enforce consistent response timing\n     */\n    private function enforceConsistentTiming(float $startTime): void {\n        $minResponseTime = 200000; // 200ms in microseconds\n        $elapsed = microtime(true) - $startTime;\n        $remaining = ($minResponseTime - ($elapsed * 1000000));\n        \n        if ($remaining > 0) {\n            usleep($remaining);\n        }\n    }\n    \n    /**\n     * Log security events\n     */\n    private function logSecurityEvent(\n        string $event,\n        string $clientIp,\n        string $identifier,\n        ?string $details = null\n    ): void {\n        $logData = [\n            'event' => $event,\n            'client_ip' => $clientIp,\n            'identifier' => $identifier,\n            'details' => $details,\n            'timestamp' => date('Y-m-d H:i:s'),\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown'\n        ];\n        \n        error_log('VERIFICATION_SECURITY_EVENT: ' . json_encode($logData));\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 10202,
    "title": "Absence of Anti-CSRF Tokens",
    "defaultRisk": "High",
    "cweid": "352",
    "description": "The application lacks Cross-Site Request Forgery (CSRF) protection mechanisms. Without CSRF tokens, malicious websites can force authenticated users to perform unwanted actions on your application, potentially leading to unauthorized data changes, account takeovers, or other security breaches.",
    "simplified_description": "Your website is vulnerable to attacks where malicious sites can make your users perform actions without their knowledge. This is like someone forging your signature on documents - attackers can make requests that appear to come from legitimate users, allowing them to change passwords, make purchases, transfer money, or delete data.",
    "solution": "Implement CSRF protection using anti-CSRF tokens, SameSite cookie attributes, and additional defense-in-depth measures like origin and referrer header validation.",
    "simplified_solution": "Add CSRF tokens to all forms and AJAX requests, validate tokens on the server, use SameSite cookie attributes, and implement additional security measures like origin validation and double-submit cookie patterns.",
    "references": [
      {
        "name": "OWASP CSRF Prevention Cheat Sheet",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-352: Cross-Site Request Forgery (CSRF)",
        "url": "https://cwe.mitre.org/data/definitions/352.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Comprehensive CSRF Protection Implementation",
        "solution_description": "This solution demonstrates how to implement comprehensive CSRF protection including token generation and validation, SameSite cookie configuration, custom headers, double-submit cookie pattern, and defense-in-depth measures across multiple web frameworks.",
        "affected_files": "Authentication middleware, form templates, AJAX request handlers, server configuration, cookie settings, CSRF middleware libraries",
        "code": "// BAD: Form without CSRF protection\n<form method=\"POST\" action=\"/transfer-money\">\n    <input type=\"text\" name=\"amount\" placeholder=\"Amount\">\n    <input type=\"text\" name=\"recipient\" placeholder=\"Recipient\">\n    <button type=\"submit\">Transfer Money</button>\n</form>\n\n<!-- GOOD: Form with CSRF protection -->\n<form method=\"POST\" action=\"/transfer-money\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{csrf_token}}\">\n    <input type=\"text\" name=\"amount\" placeholder=\"Amount\">\n    <input type=\"text\" name=\"recipient\" placeholder=\"Recipient\">\n    <button type=\"submit\">Transfer Money</button>\n</form>\n\n<!-- ======================================== -->\n<!-- CSRF PROTECTION MIDDLEWARE (Node.js/Express) -->\n<!-- ======================================== -->\n\nconst express = require('express');\nconst cookieParser = require('cookie-parser');\nconst crypto = require('crypto');\nconst app = express();\n\n// CSRF Token Management Service\nclass CSRFProtectionService {\n    constructor() {\n        this.tokenSecret = process.env.CSRF_SECRET || crypto.randomBytes(32).toString('hex');\n        this.tokenExpiry = 3600000; // 1 hour in milliseconds\n    }\n    \n    /**\n     * Generate CSRF token for session\n     */\n    generateToken(sessionId) {\n        const timestamp = Date.now();\n        const data = `${sessionId}:${timestamp}`;\n        const signature = crypto\n            .createHmac('sha256', this.tokenSecret)\n            .update(data)\n            .digest('hex');\n        \n        return Buffer.from(`${data}:${signature}`).toString('base64');\n    }\n    \n    /**\n     * Validate CSRF token\n     */\n    validateToken(token, sessionId) {\n        if (!token || !sessionId) {\n            return false;\n        }\n        \n        try {\n            const decoded = Buffer.from(token, 'base64').toString();\n            const [tokenSessionId, timestamp, signature] = decoded.split(':');\n            \n            // Check session ID matches\n            if (tokenSessionId !== sessionId) {\n                return false;\n            }\n            \n            // Check token expiry\n            const tokenTime = parseInt(timestamp);\n            if (Date.now() - tokenTime > this.tokenExpiry) {\n                return false;\n            }\n            \n            // Verify signature\n            const data = `${tokenSessionId}:${timestamp}`;\n            const expectedSignature = crypto\n                .createHmac('sha256', this.tokenSecret)\n                .update(data)\n                .digest('hex');\n            \n            return crypto.timingSafeEqual(\n                Buffer.from(signature),\n                Buffer.from(expectedSignature)\n            );\n            \n        } catch (error) {\n            return false;\n        }\n    }\n    \n    /**\n     * Generate double-submit cookie token\n     */\n    generateDoubleSubmitToken() {\n        return crypto.randomBytes(32).toString('hex');\n    }\n}\n\nconst csrfService = new CSRFProtectionService();\n\n// Middleware to set CSRF token in cookies\napp.use((req, res, next) => {\n    if (req.session && req.session.id) {\n        const csrfToken = csrfService.generateToken(req.session.id);\n        \n        // Set CSRF token in HttpOnly, Secure, SameSite cookie\n        res.cookie('csrf_token', csrfToken, {\n            httpOnly: false, // Must be accessible by JavaScript\n            secure: process.env.NODE_ENV === 'production',\n            sameSite: 'strict',\n            maxAge: csrfService.tokenExpiry\n        });\n    }\n    next();\n});\n\n// CSRF validation middleware\nconst validateCSRF = (req, res, next) => {\n    // Skip CSRF validation for safe HTTP methods\n    if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {\n        return next();\n    }\n    \n    const sessionId = req.session?.id;\n    if (!sessionId) {\n        return res.status(401).json({ error: 'No session found' });\n    }\n    \n    // Get token from form data or headers\n    const token = req.body?.csrf_token || \n                  req.headers['x-csrf-token'] ||\n                  req.headers['x-xsrf-token'];\n    \n    if (!token) {\n        return res.status(403).json({ error: 'CSRF token missing' });\n    }\n    \n    if (!csrfService.validateToken(token, sessionId)) {\n        return res.status(403).json({ error: 'Invalid CSRF token' });\n    }\n    \n    next();\n};\n\n// Apply CSRF validation to state-changing routes\napp.post('/transfer-money', validateCSRF, (req, res) => {\n    // Process the money transfer\n    const { amount, recipient } = req.body;\n    \n    // Additional validation and business logic\n    if (!amount || !recipient) {\n        return res.status(400).json({ error: 'Amount and recipient required' });\n    }\n    \n    // Process the transfer\n    transferMoney(req.session.user, amount, recipient)\n        .then(() => {\n            res.json({ success: true, message: 'Transfer completed' });\n        })\n        .catch(error => {\n            res.status(500).json({ error: 'Transfer failed' });\n        });\n});\n\n// ======================================== -->\n<!-- SPRING BOOT CSRF PROTECTION (Java) -->\n<!-- ======================================== -->\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            // Enable CSRF protection\n            .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n            .and()\n            \n            // Configure session management\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                .sessionFixation().migrateSession()\n            .and()\n            \n            // Require authentication for state-changing operations\n            .authorizeRequests()\n                .antMatchers(HttpMethod.GET, \"/public/**\").permitAll()\n                .antMatchers(HttpMethod.POST, \"/api/**\").authenticated()\n                .antMatchers(HttpMethod.PUT, \"/api/**\").authenticated()\n                .antMatchers(HttpMethod.DELETE, \"/api/**\").authenticated()\n                .anyRequest().permitAll()\n            .and()\n            \n            // Configure logout\n            .logout()\n                .logoutUrl(\"/logout\")\n                .logoutSuccessUrl(\"/login\")\n                .invalidateHttpSession(true)\n                .deleteCookies(\"JSESSIONID\", \"XSRF-TOKEN\")\n            .and()\n            \n            // Add security headers\n            .headers()\n                .contentSecurityPolicy(\"default-src 'self'\")\n                .and()\n                .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)\n                .and()\n                .frameOptions().deny();\n    }\n}\n\n// Custom CSRF token service\n@Service\npublic class CustomCsrfTokenService {\n    \n    private final String csrfSecret;\n    private final long tokenValidityDuration = 3600000; // 1 hour\n    \n    public CustomCsrfTokenService(@Value(\"${csrf.secret}\") String csrfSecret) {\n        this.csrfSecret = csrfSecret != null ? csrfSecret : generateSecret();\n    }\n    \n    public String generateToken(HttpServletRequest request) {\n        String sessionId = request.getSession().getId();\n        long timestamp = System.currentTimeMillis();\n        \n        String data = sessionId + \":\" + timestamp;\n        String signature = calculateHmac(data);\n        \n        return Base64.getUrlEncoder().withoutPadding()\n            .encodeToString((data + \":\" + signature).getBytes());\n    }\n    \n    public boolean validateToken(String token, HttpServletRequest request) {\n        if (token == null || token.trim().isEmpty()) {\n            return false;\n        }\n        \n        try {\n            String decoded = new String(Base64.getUrlDecoder().decode(token));\n            String[] parts = decoded.split(\":\");\n            \n            if (parts.length != 3) {\n                return false;\n            }\n            \n            String sessionId = parts[0];\n            long timestamp = Long.parseLong(parts[1]);\n            String signature = parts[2];\n            \n            // Validate session\n            if (!sessionId.equals(request.getSession().getId())) {\n                return false;\n            }\n            \n            // Check expiry\n            if (System.currentTimeMillis() - timestamp > tokenValidityDuration) {\n                return false;\n            }\n            \n            // Verify signature\n            String data = sessionId + \":\" + timestamp;\n            String expectedSignature = calculateHmac(data);\n            \n            return MessageDigest.isEqual(\n                signature.getBytes(StandardCharsets.UTF_8),\n                expectedSignature.getBytes(StandardCharsets.UTF_8)\n            );\n            \n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private String calculateHmac(String data) {\n        try {\n            Mac hmac = Mac.getInstance(\"HmacSHA256\");\n            SecretKeySpec secretKey = new SecretKeySpec(\n                csrfSecret.getBytes(StandardCharsets.UTF_8), \n                \"HmacSHA256\"\n            );\n            hmac.init(secretKey);\n            byte[] signature = hmac.doFinal(data.getBytes(StandardCharsets.UTF_8));\n            return Base64.getUrlEncoder().withoutPadding()\n                .encodeToString(signature);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to calculate HMAC\", e);\n        }\n    }\n    \n    private String generateSecret() {\n        return UUID.randomUUID().toString().replace(\"-\", \"\");\n    }\n}\n\n// Controller with CSRF validation\n@RestController\n@RequestMapping(\"/api\")\npublic class SecureController {\n    \n    @PostMapping(\"/transfer-money\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public ResponseEntity<?> transferMoney(\n            @RequestBody TransferRequest request,\n            HttpServletRequest httpRequest,\n            @AuthenticationPrincipal UserDetails userDetails) {\n        \n        try {\n            // Business logic for money transfer\n            transactionService.transferMoney(\n                userDetails.getUsername(),\n                request.getRecipient(),\n                request.getAmount()\n            );\n            \n            return ResponseEntity.ok()\n                .body(Map.of(\"success\", true, \"message\", \"Transfer completed\"));\n                \n        } catch (Exception e) {\n            return ResponseEntity.badRequest()\n                .body(Map.of(\"error\", \"Transfer failed: \" + e.getMessage()));\n        }\n    }\n}\n\n// ======================================== -->\n<!-- FRONTEND IMPLEMENTATION (React) -->\n<!-- ======================================== -->\n\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n// CSRF Token Hook\nconst useCSRFToken = () => {\n    const [csrfToken, setCsrfToken] = useState('');\n    \n    useEffect(() => {\n        // Get CSRF token from cookie\n        const getCSRFToken = () => {\n            const cookies = document.cookie.split(';');\n            for (const cookie of cookies) {\n                const [name, value] = cookie.trim().split('=');\n                if (name === 'csrf_token') {\n                    return value;\n                }\n            }\n            return '';\n        };\n        \n        const token = getCSRFToken();\n        setCsrfToken(token);\n    }, []);\n    \n    return csrfToken;\n};\n\n// Secure API service with CSRF protection\nconst SecureAPIService = {\n    setupInterceptors() {\n        // Request interceptor to add CSRF token\n        axios.interceptors.request.use((config) => {\n            // Add CSRF token to state-changing requests\n            if (['post', 'put', 'patch', 'delete'].includes(config.method)) {\n                const csrfToken = this.getCSRFToken();\n                if (csrfToken) {\n                    config.headers['X-CSRF-Token'] = csrfToken;\n                }\n            }\n            return config;\n        });\n        \n        // Response interceptor to handle CSRF errors\n        axios.interceptors.response.use(\n            (response) => response,\n            (error) => {\n                if (error.response?.status === 403 && \n                    error.response.data?.error?.includes('CSRF')) {\n                    // Handle CSRF token error\n                    this.handleCSRFError();\n                }\n                return Promise.reject(error);\n            }\n        );\n    },\n    \n    getCSRFToken() {\n        const cookies = document.cookie.split(';');\n        for (const cookie of cookies) {\n            const [name, value] = cookie.trim().split('=');\n            if (name === 'csrf_token') {\n                return value;\n            }\n        }\n        return null;\n    },\n    \n    handleCSRFError() {\n        // Refresh page or redirect to login\n        window.location.href = '/login';\n    },\n    \n    async securePost(url, data) {\n        return axios.post(url, data, {\n            withCredentials: true, // Important for cookies\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRF-Token': this.getCSRFToken()\n            }\n        });\n    }\n};\n\n// Transfer Money Component\nconst TransferMoneyForm = () => {\n    const [amount, setAmount] = useState('');\n    const [recipient, setRecipient] = useState('');\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState('');\n    const csrfToken = useCSRFToken();\n    \n    useEffect(() => {\n        SecureAPIService.setupInterceptors();\n    }, []);\n    \n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        setLoading(true);\n        setError('');\n        \n        try {\n            const response = await SecureAPIService.securePost('/api/transfer-money', {\n                amount: parseFloat(amount),\n                recipient,\n                csrf_token: csrfToken // Alternative: send in request body\n            });\n            \n            alert('Transfer successful!');\n            setAmount('');\n            setRecipient('');\n            \n        } catch (error) {\n            setError(error.response?.data?.error || 'Transfer failed');\n        } finally {\n            setLoading(false);\n        }\n    };\n    \n    return (\n        <form onSubmit={handleSubmit} className=\"transfer-form\">\n            {error && (\n                <div className=\"error-message\">{error}</div>\n            )}\n            \n            <div className=\"form-group\">\n                <label htmlFor=\"amount\">Amount:</label>\n                <input\n                    type=\"number\"\n                    id=\"amount\"\n                    value={amount}\n                    onChange={(e) => setAmount(e.target.value)}\n                    step=\"0.01\"\n                    min=\"0\"\n                    required\n                />\n            </div>\n            \n            <div className=\"form-group\">\n                <label htmlFor=\"recipient\">Recipient:</label>\n                <input\n                    type=\"text\"\n                    id=\"recipient\"\n                    value={recipient}\n                    onChange={(e) => setRecipient(e.target.value)}\n                    required\n                />\n            </div>\n            \n            <button type=\"submit\" disabled={loading}>\n                {loading ? 'Transferring...' : 'Transfer Money'}\n            </button>\n        </form>\n    );\n};\n\nexport default TransferMoneyForm;\n\n// ======================================== -->\n<!-- DOUBLE-SUBMIT COOKIE PATTERN -->\n<!-- ======================================== -->\n\n// Middleware for double-submit cookie CSRF protection\nconst doubleSubmitCSRF = (req, res, next) => {\n    // Skip for safe HTTP methods\n    if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {\n        return next();\n    }\n    \n    // Get token from cookie\n    const cookieToken = req.cookies?.csrf_token;\n    if (!cookieToken) {\n        return res.status(403).json({ error: 'CSRF cookie missing' });\n    }\n    \n    // Get token from request body or header\n    const requestToken = req.body?.csrf_token || \n                        req.headers['x-csrf-token'];\n    \n    if (!requestToken) {\n        return res.status(403).json({ error: 'CSRF token missing from request' });\n    }\n    \n    // Compare tokens using timing-safe comparison\n    if (!crypto.timingSafeEqual(\n        Buffer.from(cookieToken),\n        Buffer.from(requestToken)\n    )) {\n        return res.status(403).json({ error: 'CSRF token mismatch' });\n    }\n    \n    next();\n};\n\n// ======================================== -->\n<!-- SECURITY CONFIGURATION -->\n<!-- ======================================== -->\n\n/*\nCSRF PROTECTION CHECKLIST:\n\n1. Token Generation:\n   - Use cryptographically secure random values\n   - Include session identifier in token\n   - Add timestamp for token expiry\n   - Sign tokens with HMAC\n\n2. Token Validation:\n   - Validate tokens on all state-changing requests\n   - Use timing-safe comparison\n   - Check token expiration\n   - Verify session binding\n\n3. Cookie Security:\n   - Set Secure flag for HTTPS\n   - Use SameSite=Strict or SameSite=Lax\n   - Consider HttpOnly for sensitive cookies\n   - Set appropriate expiration\n\n4. Defense-in-Depth:\n   - Implement SameSite cookie attributes\n   - Validate Origin and Referer headers\n   - Use custom headers for AJAX requests\n   - Implement rate limiting\n\n5. Browser Compatibility:\n   - Support legacy browsers\n   - Provide fallback mechanisms\n   - Test cross-browser behavior\n   - Handle mobile browsers\n\n6. Testing:\n   - Test CSRF attack scenarios\n   - Verify token generation/invalidation\n   - Test token expiry behavior\n   - Validate error handling\n\n7. Monitoring:\n   - Log CSRF validation failures\n   - Monitor for suspicious patterns\n   - Alert on repeated failures\n   - Track CSRF metrics\n\n8. Configuration:\n   - Set appropriate token expiry\n   - Configure secure cookie settings\n   - Adjust security headers\n   - Environment-specific settings\n*/"
      }
    ]
  },
  {
    "pluginId": 20015,
    "title": "Heartbleed OpenSSL Vulnerability",
    "defaultRisk": "Critical",
    "cweid": "200",
    "description": "The Heartbleed vulnerability (CVE-2014-0160) is a serious bug in OpenSSL's TLS/DTLS heartbeat extension that allows attackers to read up to 64KB of memory from the server or client, potentially exposing sensitive data including private keys, session tokens, and passwords.",
    "simplified_description": "Your server is vulnerable to the Heartbleed bug, which is like having a hole in your secure communication system that allows attackers to secretly listen in and steal sensitive information including passwords, private keys, and user data. This is one of the most critical cybersecurity vulnerabilities discovered, allowing attackers to extract sensitive data directly from server memory.",
    "solution": "Update OpenSSL to version 1.0.1g or later, revoke and reissue all SSL certificates, and invalidate all existing sessions and tokens.",
    "simplified_solution": "Immediately upgrade your OpenSSL library to a secure version (1.0.1g or later), replace all SSL certificates, and force all users to log out and change their passwords. This requires patching systems, rotating security credentials, and implementing proper security monitoring.",
    "references": [
      {
        "name": "CVE-2014-0160 - Heartbleed Bug",
        "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160"
      },
      {
        "name": "Heartbleed.com - Official Information",
        "url": "https://heartbleed.com/"
      },
      {
        "name": "NIST Vulnerability Database",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2014-0160"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Comprehensive Heartbleed Remediation",
        "solution_description": "This comprehensive solution provides step-by-step guidance for remediating the Heartbleed vulnerability, including system patching, certificate rotation, key management, application updates, and security monitoring. It covers multiple platforms and provides automated remediation scripts for large-scale deployments.",
        "affected_files": "System configuration files, OpenSSL library installations, SSL certificate files, web server configurations, application dependency files, deployment scripts, monitoring configurations, security policies",
        "code": "# =========================================================\n# HEARTBLEED (CVE-2014-0160) COMPREHENSIVE REMEDIATION\n# =========================================================\n\n#!/bin/bash\n# HEARTBLEED REMEDIATION SCRIPT\n# This script helps systematically remediate Heartbleed vulnerability\n\nset -euo pipefail\n\n# Configuration\nLOG_FILE=\"/var/log/heartbleed_remediation.log\"\nBACKUP_DIR=\"/etc/ssl/backup/$(date +%Y%m%d_%H%M%S)\"\nOPENSSL_VULNERABLE_VERSIONS=\"1.0.1 1.0.1a 1.0.1b 1.0.1c 1.0.1d 1.0.1e 1.0.1f\"\n\n# Logging function\nlog() {\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $1\" | tee -a \"$LOG_FILE\"\n}\n\n# Error handling\nerror_exit() {\n    log \"ERROR: $1\"\n    exit 1\n}\n\n# Check current OpenSSL version\ncheck_openssl_version() {\n    log \"Checking current OpenSSL version...\"\n    \n    if ! command -v openssl &> /dev/null; then\n        error_exit \"OpenSSL is not installed\"\n    fi\n    \n    local current_version=$(openssl version | awk '{print $2}')\n    log \"Current OpenSSL version: $current_version\"\n    \n    for vuln_version in $OPENSSL_VULNERABLE_VERSIONS; do\n        if [[ \"$current_version\" == \"$vuln_version\" ]]; then\n            log \"VULNERABLE: OpenSSL version $current_version is vulnerable to Heartbleed\"\n            return 0\n        fi\n    done\n    \n    log \"SECURE: OpenSSL version $current_version appears to be patched\"\n    return 1\n}\n\n# Create backup directory\ncreate_backup() {\n    log \"Creating backup directory: $BACKUP_DIR\"\n    mkdir -p \"$BACKUP_DIR\"\n    \n    # Backup current certificates and keys\n    if [[ -d \"/etc/ssl/certs\" ]]; then\n        cp -r /etc/ssl/certs \"$BACKUP_DIR/\" 2>/dev/null || true\n    fi\n    \n    if [[ -d \"/etc/ssl/private\" ]]; then\n        cp -r /etc/ssl/private \"$BACKUP_DIR/\" 2>/dev/null || true\n    fi\n    \n    # Backup web server configurations\n    for config in /etc/nginx/nginx.conf /etc/apache2/apache2.conf /etc/httpd/conf/httpd.conf; do\n        if [[ -f \"$config\" ]]; then\n            cp \"$config\" \"$BACKUP_DIR/\" 2>/dev/null || true\n        fi\n    done\n    \n    log \"Backup completed successfully\"\n}\n\n# Update OpenSSL library\nupdate_openssl() {\n    log \"Updating OpenSSL library...\"\n    \n    if command -v apt-get &> /dev/null; then\n        # Ubuntu/Debian\n        apt-get update\n        apt-get install -y openssl libssl-dev\n        log \"OpenSSL updated via apt-get\"\n        \n    elif command -v yum &> /dev/null; then\n        # CentOS/RHEL\n        yum update -y openssl openssl-devel\n        log \"OpenSSL updated via yum\"\n        \n    elif command -v apk &> /dev/null; then\n        # Alpine Linux\n        apk update\n        apk add --upgrade openssl\n        log \"OpenSSL updated via apk\"\n        \n    else\n        error_exit \"Unsupported package manager. Manual OpenSSL update required.\"\n    fi\n}\n\n# Test OpenSSL for Heartbleed vulnerability\ntest_heartbeat() {\n    log \"Testing OpenSSL for Heartbleed vulnerability...\"\n    \n    # Use nmap to test if available\n    if command -v nmap &> /dev/null; then\n        log \"Testing with nmap...\"\n        nmap --script ssl-heartbleed -p 443 localhost | tee -a \"$LOG_FILE\"\n    else\n        log \"nmap not available, proceeding with manual verification\"\n    fi\n    \n    # Alternative: Use openssl s_client test\n    log \"Testing with openssl s_client...\"\n    echo | timeout 5 openssl s_client -connect localhost:443 -tlsextdebug 2>&1 | head -20 | tee -a \"$LOG_FILE\"\n}\n\n# Generate new SSL certificates\ngenerate_new_certificates() {\n    log \"Generating new SSL certificates...\"\n    \n    local domain=\"$(hostname -f)\"\n    if [[ -z \"$domain\" ]]; then\n        domain=\"localhost\"\n    fi\n    \n    # Generate new private key\n    openssl genpkey -algorithm RSA -out /etc/ssl/private/new.key -pkeyopt rsa_keygen_bits:2048\n    chmod 600 /etc/ssl/private/new.key\n    \n    # Generate certificate signing request\n    openssl req -new -key /etc/ssl/private/new.key -out /tmp/new.csr -subj \"/C=US/ST=State/L=City/O=Organization/CN=$domain\"\n    \n    # Generate self-signed certificate (for immediate use)\n    openssl x509 -req -days 365 -in /tmp/new.csr -signkey /etc/ssl/private/new.key -out /etc/ssl/certs/new.crt\n    \n    # Clean up\n    rm -f /tmp/new.csr\n    \n    log \"New SSL certificates generated successfully\"\n}\n\n# Update web server configurations\nupdate_web_server_configs() {\n    log \"Updating web server configurations...\"\n    \n    # Nginx configuration\n    if command -v nginx &> /dev/null; then\n        cat > /etc/nginx/conf.d/ssl.conf << 'EOF'\nserver {\n    listen 443 ssl http2;\n    server_name _;\n    \n    ssl_certificate /etc/ssl/certs/new.crt;\n    ssl_certificate_key /etc/ssl/private/new.key;\n    \n    # SSL hardening\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    \n    # HSTS\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    \n    # Other security headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\";\n}\nEOF\n        log \"Nginx SSL configuration updated\"\n    fi\n    \n    # Apache configuration\n    if command -v apache2 &> /dev/null; then\n        cat > /etc/apache2/sites-available/ssl.conf << 'EOF'\n<IfModule mod_ssl.c>\n    <VirtualHost _default_:443>\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html\n        \n        SSLEngine on\n        SSLCertificateFile /etc/ssl/certs/new.crt\n        SSLCertificateKeyFile /etc/ssl/private/new.key\n        \n        # SSL hardening\n        SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1\n        SSLCipherSuite ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384\n        SSLHonorCipherOrder off\n        SSLSessionCache shmcb:/var/run/apache2/ssl_scache(512000)\n        SSLSessionCacheTimeout 300\n        \n        # HSTS\n        Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"\n        \n        # Other security headers\n        Header always set X-Frame-Options DENY\n        Header always set X-Content-Type-Options nosniff\n        Header always set X-XSS-Protection \"1; mode=block\"\n        Header always set Referrer-Policy \"strict-origin-when-cross-origin\"\n    </VirtualHost>\n</IfModule>\nEOF\n        a2enmod ssl\n        a2ensite ssl\n        log \"Apache SSL configuration updated\"\n    fi\n}\n\n# Restart services\nrestart_services() {\n    log \"Restarting web services...\"\n    \n    # Restart web servers\n    if command -v nginx &> /dev/null; then\n        systemctl restart nginx || service nginx restart\n        log \"Nginx restarted\"\n    fi\n    \n    if command -v apache2 &> /dev/null; then\n        systemctl restart apache2 || service apache2 restart\n        log \"Apache restarted\"\n    fi\n    \n    if command -v httpd &> /dev/null; then\n        systemctl restart httpd || service httpd restart\n        log \"HTTPD restarted\"\n    fi\n}\n\n# Invalidate existing sessions\ninvalidate_sessions() {\n    log \"Invalidating existing sessions...\"\n    \n    # Clear session directories if they exist\n    for session_dir in /var/lib/php/sessions /tmp/sessions /var/www/sessions; do\n        if [[ -d \"$session_dir\" ]]; then\n            find \"$session_dir\" -type f -name \"sess_*\" -delete 2>/dev/null || true\n            log \"Cleared sessions in $session_dir\"\n        fi\n    done\n    \n    # Redis sessions\n    if command -v redis-cli &> /dev/null; then\n        redis-cli FLUSHALL 2>/dev/null || true\n        log \"Cleared Redis sessions\"\n    fi\n    \n    # Memcached sessions\n    if command -v memcached-tool &> /dev/null; then\n        memcached-tool localhost:11211 flush_all 2>/dev/null || true\n        log \"Cleared Memcached sessions\"\n    fi\n}\n\n# Security monitoring setup\nsetup_monitoring() {\n    log \"Setting up security monitoring...\"\n    \n    # Create monitoring script\n    cat > /usr/local/bin/monitor_heartbleed.sh << 'EOF'\n#!/bin/bash\n\n# Monitor for Heartbleed-like vulnerabilities\nLOG_FILE=\"/var/log/heartbleed_monitor.log\"\nDATE=$(date '+%Y-%m-%d %H:%M:%S')\n\n# Check OpenSSL version\nOPENSSL_VERSION=$(openssl version | awk '{print $2}')\necho \"[$DATE] OpenSSL version: $OPENSSL_VERSION\" >> \"$LOG_FILE\"\n\n# Test for heartbeat vulnerability\nif command -v nmap &> /dev/null; then\n    nmap --script ssl-heartbleed -p 443 localhost 2>&1 | grep -i vulnerable >> \"$LOG_FILE\" || true\nfi\n\n# Monitor SSL certificate expiration\nif [[ -f \"/etc/ssl/certs/new.crt\" ]]; then\n    EXPIRY_DATE=$(openssl x509 -in /etc/ssl/certs/new.crt -noout -enddate | cut -d= -f2)\n    EXPIRY_EPOCH=$(date -d \"$EXPIRY_DATE\" +%s)\n    CURRENT_EPOCH=$(date +%s)\n    DAYS_LEFT=$(( (EXPIRY_EPOCH - CURRENT_EPOCH) / 86400 ))\n    \n    if [[ $DAYS_LEFT -lt 30 ]]; then\n        echo \"[$DATE] WARNING: SSL certificate expires in $DAYS_LEFT days\" >> \"$LOG_FILE\"\n    fi\nfi\nEOF\n    \n    chmod +x /usr/local/bin/monitor_heartbeat.sh\n    \n    # Add to cron\n    (crontab -l 2>/dev/null; echo \"0 */6 * * * /usr/local/bin/monitor_heartbleed.sh\") | crontab -\n    \n    log \"Security monitoring setup completed\"\n}\n\n# Generate remediation report\ngenerate_report() {\n    log \"Generating remediation report...\"\n    \n    cat > \"/tmp/heartbleed_remediation_report_$(date +%Y%m%d_%H%M%S).txt\" << EOF\nHeartbleed Vulnerability Remediation Report\n==========================================\nDate: $(date)\nSystem: $(hostname -f)\n\nREMEDIATION ACTIONS COMPLETED:\n1. ✅ OpenSSL library updated\n2. ✅ New SSL certificates generated\n3. ✅ Web server configurations updated\n4. ✅ Services restarted\n5. ✅ Existing sessions invalidated\n6. ✅ Security monitoring implemented\n\nCURRENT STATUS:\n- OpenSSL Version: $(openssl version | awk '{print $2}')\n- Certificate Location: /etc/ssl/certs/new.crt\n- Key Location: /etc/ssl/private/new.key\n- Backup Location: $BACKUP_DIR\n\nNEXT STEPS:\n1. Update DNS/Load Balancer if needed\n2. Notify users to change passwords\n3. Monitor for unusual activity\n4. Schedule regular security updates\n5. Implement automated vulnerability scanning\n\nLOG FILE: $LOG_FILE\nEOF\n    \n    log \"Remediation report generated\"\n}\n\n# Main execution function\nmain() {\n    log \"Starting Heartbleed vulnerability remediation...\"\n    \n    # Check if vulnerable\n    if ! check_openssl_version; then\n        log \"System appears to be secure. Exiting.\"\n        exit 0\n    fi\n    \n    # Execute remediation steps\n    create_backup\n    update_openssl\n    test_heartbeat\n    generate_new_certificates\n    update_web_server_configs\n    restart_services\n    invalidate_sessions\n    setup_monitoring\n    generate_report\n    \n    log \"Heartbleed remediation completed successfully!\"\n    log \"IMPORTANT: Notify all users to change their passwords immediately.\"\n    log \"IMPORTANT: Monitor the system for any suspicious activity.\"\n}\n\n# Execute main function if script is run directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n    main \"$@\"\nfi\n\n# =========================================================\n# DOCKER COMPOSE CONFIGURATION\n# =========================================================\n\n# docker-compose.yml - Secure configuration\nversion: '3.8'\n\nservices:\n  web:\n    image: nginx:1.25-alpine\n    ports:\n      - \"443:443\"\n    volumes:\n      - ./ssl:/etc/ssl:ro\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    environment:\n      - NGINX_HOST=localhost\n      - NGINX_PORT=443\n    depends_on:\n      - app\n\n  app:\n    image: your-app:latest\n    environment:\n      - SPRING_PROFILES_ACTIVE=production\n      - JAVA_OPTS=-Djava.security.egd=file:/dev/./urandom\n    depends_on:\n      - db\n\n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_DB=secureapp\n      - POSTGRES_USER=appuser\n      - POSTGRES_PASSWORD=${DB_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  default:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.enable_icc: \"false\"\n\n# =========================================================\n# APPLICATION CONFIGURATION\n# =========================================================\n\n# application.properties - Spring Boot\nserver:\n  port: 8443\n  ssl:\n    enabled: true\n    key-store: classpath:keystore.p12\n    key-store-password: ${SSL_KEYSTORE_PASSWORD}\n    key-store-type: PKCS12\n    key-alias: tomcat\n    protocol: TLS\n    enabled-protocols: TLSv1.2,TLSv1.3\n    ciphers: ECDHE-RSA-AES256-GCM-SHA512,DHE-RSA-AES256-GCM-SHA512,ECDHE-RSA-AES256-GCM-SHA384,DHE-RSA-AES256-GCM-SHA384\n\nlogging:\n  level:\n    org.springframework.web: INFO\n    org.springframework.security: INFO\n    root: WARN\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n\n# =========================================================\n# CONTINUOUS INTEGRATION TESTING\n# =========================================================\n\n# .github/workflows/security-scan.yml\nname: Security Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 2 * * 1'  # Weekly on Monday at 2 AM\n\njobs:\n  vulnerability-scan:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        scan-type: 'fs'\n        scan-ref: '.'\n        format: 'sarif'\n        output: 'trivy-results.sarif'\n    \n    - name: Upload Trivy scan results to GitHub Security tab\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: 'trivy-results.sarif'\n    \n    - name: Test for Heartbleed vulnerability\n      run: |\n        # Install test tools\n        sudo apt-get update\n        sudo apt-get install -y nmap openssl\n        \n        # Test application if running\n        if curl -f http://localhost:8080/health 2>/dev/null; then\n          echo \"Testing application for Heartbleed...\"\n          nmap --script ssl-heartbleed -p 8443 localhost || echo \"No Heartbleed detected\"\n        fi\n    \n    - name: Check OpenSSL version\n      run: |\n        echo \"OpenSSL version: $(openssl version)\"\n        if openssl version | grep -E \"1\\.0\\.1[a-f]\"; then\n          echo \"Vulnerable OpenSSL version detected!\"\n          exit 1\n        fi\n\n# =========================================================\n# SECURITY TESTING COMMANDS\n# =========================================================\n\n/*\nMANUAL TESTING PROCEDURES:\n\n1. OpenSSL Version Check:\n   openssl version\n   # Should be 1.0.1g or later\n\n2. SSL Certificate Validation:\n   openssl s_client -connect yourdomain.com:443 -showcerts\n   openssl x509 -in certificate.crt -text -noout\n\n3. Heartbleed Testing (Nmap):\n   nmap --script ssl-heartbleed -p 443 yourdomain.com\n\n4. Heartbleed Testing (Testssl.sh):\n   git clone https://github.com/drwetter/testssl.sh.git\n   cd testssl.sh\n   ./testssl.sh --heartbleed yourdomain.com\n\n5. SSL Labs Assessment:\n   https://www.ssllabs.com/ssltest/\n\n6. Continuous Monitoring:\n   # Set up automated scanning\n   while true; do\n     nmap --script ssl-heartbleed -p 443 localhost\n     sleep 3600  # Every hour\n   done\n\nAUTOMATED REMEDIATION COMMANDS:\n\n# Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install --only-upgrade openssl libssl1.0.0\n\n# CentOS/RHEL\nsudo yum update openssl openssl-devel\n\n# Amazon Linux\nsudo yum update openssl\n\n# Build from source (if packages unavailable)\ncd /usr/local/src\nwget https://www.openssl.org/source/openssl-1.0.2u.tar.gz\ntar xzf openssl-1.0.2u.tar.gz\ncd openssl-1.0.2u\n./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl shared zlib\nmake\nmake test\nsudo make install\n\nVERIFICATION COMMANDS:\n\n# Verify OpenSSL version is patched\nopenssl version\n# Should show 1.0.1g, 1.0.2, or 1.1.x\n\n# Test if server is vulnerable\necho | openssl s_client -connect yourdomain.com:443 -tlsextdebug 2>&1 | grep \"heartbeat\"\n# Should return empty if patched\n\n# Check certificate details\nopenssl x509 -in /etc/ssl/certs/new.crt -noout -dates\nopenssl x509 -in /etc/ssl/certs/new.crt -noout -subject\nopenssl x509 -in /etc/ssl/certs/new.crt -noout -issuer\n\nPOST-REMEDIATION VALIDATION:\n\n1. Functional Testing:\n   - Test all HTTPS endpoints\n   - Verify SSL handshake works\n   - Check browser compatibility\n   - Test API clients\n\n2. Security Testing:\n   - Run vulnerability scans\n   - Test SSL configuration\n   - Verify certificate chain\n   - Check for weak ciphers\n\n3. Performance Testing:\n   - Monitor CPU usage\n   - Check memory consumption\n   - Test response times\n   - Verify throughput\n\n4. Monitoring Setup:\n   - Set up log monitoring\n   - Configure alerts\n   - Implement health checks\n   - Schedule regular scans\n\nEMERGENCY CONTACT INFORMATION:\n- Security Team: security@company.com\n- System Administrator: admin@company.com\n- Incident Response: incident@company.com\n- Management: management@company.com\n\nREGULAR MAINTENANCE SCHEDULE:\n- Daily: Monitor logs and alerts\n- Weekly: Security scans and updates\n- Monthly: Certificate expiry checks\n- Quarterly: Full security audit\n- Annually: Complete system review\n*/"
      }
    ]
  },
  {
    "pluginId": 20017,
    "title": "Source Code Disclosure - CVE-2012-1823",
    "defaultRisk": "High",
    "cweid": "200",
    "description": "CVE-2012-1823 is a PHP source code disclosure vulnerability that allows attackers to view arbitrary PHP source code by passing specific query parameters, potentially exposing sensitive information, database credentials, and application logic.",
    "simplified_description": "Your PHP application has a critical vulnerability that allows anyone to view your source code simply by adding special parameters to URLs. This is like having the blueprints to your entire business publicly available - attackers can see your database passwords, authentication logic, and find every security weakness in your code to craft targeted attacks against your system.",
    "solution": "Upgrade to patched PHP versions and implement input validation to prevent source code disclosure through parameter manipulation.",
    "simplified_solution": "Immediately upgrade PHP to version 5.4.2 or later, or apply security patches for your current version. Implement strict input validation to reject malicious parameters, configure your web server to prevent source code access, and use secure error handling that doesn't expose sensitive information. Never expose production source code under any circumstances.",
    "references": [
      {
        "name": "CVE-2012-1823 - PHP Source Code Disclosure",
        "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-1823"
      },
      {
        "name": "PHP Security Advisories",
        "url": "https://www.php.net/security-advisories.php"
      },
      {
        "name": "OWASP PHP Security Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/PHP_Security_Cheat_Sheet.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP Security Hardening and Vulnerability Mitigation",
        "solution_description": "This solution demonstrates comprehensive PHP security hardening to prevent CVE-2012-1823 and similar source code disclosure vulnerabilities. Includes PHP configuration hardening, input validation, secure error handling, web server configuration, and version management for PHP applications.",
        "affected_files": "Authentication controllers, user service, security configuration, middleware, database models, frontend authentication components",
        "code": "<?php\n// ============================================\n// SECURITY CONFIGURATION AND VALIDATION\n// ============================================\n\nclass SecurityManager {\n    private $blockedParams = ['source', 'file', 'page', 'view', 'include', 'require'];\n    private $blockedExtensions = ['php', 'php3', 'php4', 'php5', 'phtml', 'inc'];\n    \n    public function __construct() {\n        $this->validateInput();\n        $this->configureSecurityHeaders();\n    }\n    \n    /**\n     * Validate all input parameters to prevent source code disclosure\n     */\n    private function validateInput() {\n        // Check GET parameters\n        foreach ($_GET as $key => $value) {\n            $this->validateParameter($key, $value);\n        }\n        \n        // Check POST parameters\n        foreach ($_POST as $key => $value) {\n            $this->validateParameter($key, $value);\n        }\n        \n        // Check REQUEST URI for malicious patterns\n        $this->validateRequestUri();\n        \n        // Check for CVE-2012-1823 specific attack patterns\n        $this->checkCve20121823();\n    }\n    \n    /**\n     * Validate individual parameter\n     */\n    private function validateParameter($key, $value) {\n        // Block parameters that could lead to file inclusion\n        if (in_array(strtolower($key), $this->blockedParams)) {\n            $this->blockRequest('Blocked parameter: ' . $key);\n        }\n        \n        // Check for file path attempts\n        if ($this->containsFilePath($value)) {\n            $this->blockRequest('File path detected in parameter: ' . $key);\n        }\n        \n        // Check for PHP file references\n        if ($this->containsPhpExtension($value)) {\n            $this->blockRequest('PHP file reference detected in parameter: ' . $key);\n        }\n        \n        // Check for encoding bypass attempts\n        $decodedValue = urldecode($value);\n        if ($this->containsFilePath($decodedValue) || $this->containsPhpExtension($decodedValue)) {\n            $this->blockRequest('Encoded file path detected in parameter: ' . $key);\n        }\n    }\n    \n    /**\n     * Check for CVE-2012-1823 specific attack patterns\n     */\n    private function checkCve20121823() {\n        $uri = $_SERVER['REQUEST_URI'];\n        $queryString = $_SERVER['QUERY_STRING'];\n        \n        // Check for specific CVE-2012-1823 patterns\n        $cvePatterns = [\n            '/^.*\\-[^\\/]*$/',  // Pattern ending with dash and text\n            '/^[^\\/]*\\-/',      // Pattern starting with text and dash\n            '/^[^\\/]*\\\\.php$/', // Direct PHP file reference\n            '/^.*\\\\.php.*$/'   // PHP extension anywhere in URI\n        ];\n        \n        foreach ($cvePatterns as $pattern) {\n            if (preg_match($pattern, $uri) || preg_match($pattern, $queryString)) {\n                $this->logAttack('CVE-2012-1823 pattern detected');\n                $this->blockRequest('Potential CVE-2012-1823 exploit attempt');\n            }\n        }\n        \n        // Check for specific parameter patterns from the vulnerability\n        if (isset($_GET['-d']) || isset($_POST['-d']) ||\n            isset($_GET['-f']) || isset($_POST['-f'])) {\n            $this->logAttack('CVE-2012-1823 parameter detected');\n            $this->blockRequest('CVE-2012-1823 exploit attempt blocked');\n        }\n    }\n    \n    /**\n     * Check if value contains file path patterns\n     */\n    private function containsFilePath($value) {\n        $pathPatterns = [\n            '\\.\\./',           // Directory traversal\n            '%2e%2e',          // URL encoded directory traversal\n            '\\\\.\\\\.\\\\',       // Windows path traversal\n            '\\\\/',             // Forward slash\n            '\\\\\\\\',           // Backslash\n            'etc/passwd',      // Common file inclusion target\n            'proc/self',       // Process file access\n            'windows\\\\system32' // Windows system files\n        ];\n        \n        foreach ($pathPatterns as $pattern) {\n            if (preg_match('/' . $pattern . '/i', $value)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Check if value contains PHP file extension\n     */\n    private function containsPhpExtension($value) {\n        $phpPatterns = [\n            '\\\\.php[345]?',     // .php, .php3, .php4, .php5\n            '\\\\.phtml',         // .phtml\n            '\\\\.inc',           // .inc\n            'source='           // source parameter\n        ];\n        \n        foreach ($phpPatterns as $pattern) {\n            if (preg_match('/' . $pattern . '/i', $value)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Validate request URI\n     */\n    private function validateRequestUri() {\n        $uri = $_SERVER['REQUEST_URI'];\n        $decodedUri = urldecode($uri);\n        \n        // Block direct PHP file access\n        if (preg_match('/\\.php[345]?$/i', $decodedUri) || \n            preg_match('/\\.phtml$/i', $decodedUri)) {\n            $this->blockRequest('Direct PHP file access attempted');\n        }\n        \n        // Block source code access patterns\n        if (preg_match('/(source|view|show)=[^&]*\\.php/i', $uri)) {\n            $this->blockRequest('Source code access attempted');\n        }\n    }\n    \n    /**\n     * Configure security headers\n     */\n    private function configureSecurityHeaders() {\n        if (!headers_sent()) {\n            header('X-Content-Type-Options: nosniff');\n            header('X-Frame-Options: DENY');\n            header('X-XSS-Protection: 1; mode=block');\n            header('Referrer-Policy: strict-origin-when-cross-origin');\n        }\n    }\n    \n    /**\n     * Block malicious request and log it\n     */\n    private function blockRequest($reason) {\n        $this->logAttack($reason);\n        \n        // Send 403 Forbidden response\n        http_response_code(403);\n        header('HTTP/1.1 403 Forbidden');\n        \n        // Don't reveal the reason to the attacker\n        echo '<!DOCTYPE html><html><head><title>Access Denied</title></head>';\n        echo '<body><h1>403 - Access Denied</h1><p>Your request has been blocked.</p></body></html>';\n        \n        exit();\n    }\n    \n    /**\n     * Log security violations\n     */\n    private function logAttack($reason) {\n        $logData = [\n            'timestamp' => date('Y-m-d H:i:s'),\n            'ip' => $_SERVER['REMOTE_ADDR'],\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'Unknown',\n            'uri' => $_SERVER['REQUEST_URI'],\n            'method' => $_SERVER['REQUEST_METHOD'],\n            'reason' => $reason,\n            'post_data' => $_POST\n        ];\n        \n        // Log to file\n        file_put_contents(\n            __DIR__ . '/security.log',\n            json_encode($logData) . PHP_EOL,\n            FILE_APPEND | LOCK_EX\n        );\n        \n        // Also log to error_log\n        error_log('SECURITY VIOLATION: ' . $reason . ' from ' . $_SERVER['REMOTE_ADDR']);\n    }\n}\n\n// Initialize security manager for all requests\n$securityManager = new SecurityManager();"
      }
    ]
  },
  {
    "pluginId": 20018,
    "title": "Remote Code Execution - CVE-2012-1823",
    "defaultRisk": "Critical",
    "cweid": 94,
    "description": "CVE-2012-1823 is a critical vulnerability in PHP CGI versions that allows remote code execution through improper handling of query string parameters. Attackers can execute arbitrary PHP code on the server by manipulating request parameters, potentially leading to complete server compromise.",
    "simplified_description": "Your PHP server has a critical security flaw that allows attackers to run any code they want on your server, like giving strangers the keys to your house and telling them to make themselves at home. Attackers can steal data, install malware, or take complete control of your server through this vulnerability.",
    "solution": "Immediately upgrade PHP to a version that patches CVE-2012-1823 (PHP 5.4.3+, 5.3.13+, or newer). If immediate upgrade is not possible, disable CGI mode or implement server-side workarounds. Additionally, scan for any signs of exploitation and audit the system for potential compromise.",
    "simplified_solution": "Update your PHP installation immediately to the latest stable version. This vulnerability affects older PHP versions running in CGI mode. If you cannot upgrade right away, temporarily disable PHP CGI or apply security patches. Check your server logs for any signs of exploitation and consider the server potentially compromised if running vulnerable versions.",
    "references": [
      {
        "name": "CVE-2012-1823 - NVD",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2012-1823"
      },
      {
        "name": "PHP Security Advisory",
        "url": "https://www.php.net/archive/2012.php#id2012-05-03-1"
      },
      {
        "name": "OWASP Remote Code Execution Guide",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP Version Upgrade and Security Configuration",
        "solution_description": "This comprehensive solution addresses CVE-2012-1823 by providing immediate mitigation strategies, PHP upgrade procedures, security hardening, and compromise detection methods. It includes Apache/Nginx configuration changes, PHP compilation options, server-side workarounds, and post-upgrade security validation.",
        "affected_files": "/etc/php/*/apache2/php.ini, /etc/php/*/fpm/php.ini, Apache virtual host configurations, Nginx server blocks, PHP CGI configuration, system package management files",
        "code": "# PHP CVE-2012-1823 Remote Code Execution Mitigation\n# Critical Security Update Required\n\n# ======================================\n# IMMEDIATE MITIGATION STEPS\n# ======================================\n\n# Step 1: Identify vulnerable PHP version\nphp -v\n\n# Check if running PHP CGI\nps aux | grep php-cgi\n\n# Step 2: Disable PHP CGI (Immediate workaround)\n# Apache configuration\n# Add to httpd.conf or apache2.conf\n\n# Disable PHP CGI handler\n<IfModule mod_cgi.c>\n    # Comment out or remove PHP CGI handler\n    # Action application/x-httpd-php /usr/bin/php-cgi\n    # AddType application/x-httpd-php .php\n</IfModule>\n\n# Disable CGI module\n# a2dismod cgi\n# systemctl restart apache2\n\n# Nginx configuration\n# Comment out PHP CGI pass in nginx.conf\n# location ~ \\.php$ {\n#     # fastcgi_pass unix:/var/run/php/php5-cgi.sock;\n# }\n\n# ======================================\n# PHP VERSION UPGRADE PROCEDURES\n# ======================================\n\n# Ubuntu/Debian Systems\nsudo apt update\nsudo apt list --upgradable | grep php\n\n# Upgrade to PHP 8.x (Recommended)\nsudo apt install php8.1 php8.1-fpm php8.1-mysql php8.1-xml php8.1-mbstring\n\n# Ubuntu 18.04+ specific\nsudo apt install software-properties-common\nsudo add-apt-repository ppa:ondrej/php\nsudo apt update\nsudo apt install php8.1\n\n# CentOS/RHEL Systems\nsudo yum install epel-release\nsudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm\nsudo yum-config-manager --enable remi-php81\nsudo yum install php php-fpm php-mysql php-xml php-mbstring\n\n# Ubuntu/Debian upgrade commands\nsudo apt update\nsudo apt upgrade php*\nsudo systemctl restart apache2\n\n# CentOS/RHEL upgrade commands\nsudo yum update php*\nsudo systemctl restart httpd\n\n# ======================================\n# PHP CONFIGURATION HARDENING\n# ======================================\n\n# php.ini security settings\n# /etc/php/8.1/apache2/php.ini\n\n; Disable functions that can be used for RCE\ndisable_functions = exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source\n\n; Disable dangerous classes\ndisable_classes = Reflection, ReflectionFunction, ReflectionMethod, ReflectionClass, ReflectionParameter, ReflectionProperty, ReflectionExtension\n\n; Prevent file inclusion attacks\nallow_url_fopen = Off\nallow_url_include = Off\n\n; Disable register globals (legacy PHP)\nregister_globals = Off\n\n; Enable safe mode (PHP < 5.4)\nsafe_mode = On\nsafe_mode_gid = Off\nsafe_mode_include_dir = \nsafe_mode_exec_dir = \n\n; Restrict file uploads\nfile_uploads = On\nupload_tmp_dir = /var/tmp/php_uploads\nupload_max_filesize = 2M\nmax_file_uploads = 20\n\n; Open base directory restriction\nopen_basedir = \"/var/www/:/tmp/:/usr/share/php/\"\n\n; Error reporting\nlog_errors = On\nerror_log = /var/log/php_errors.log\ndisplay_errors = Off\n\n; Session security\nsession.cookie_httponly = 1\nsession.use_strict_mode = 1\nsession.cookie_secure = 1\n\n# ======================================\n# APACHE SECURITY CONFIGURATION\n# ======================================\n\n# /etc/apache2/sites-available/000-default.conf\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # PHP-FPM configuration (instead of CGI)\n    <FilesMatch \\.php$>\n        SetHandler \"proxy:unix:/run/php/php8.1-fpm.sock|fcgi://localhost/\"\n    </FilesMatch>\n    \n    # Disable CGI module completely\n    # <IfModule mod_cgi.c>\n    #     # CGI disabled for security\n    # </IfModule>\n    \n    # Security headers\n    Header always set X-Content-Type-Options nosniff\n    Header always set X-Frame-Options DENY\n    Header always set X-XSS-Protection \"1; mode=block\"\n    Header always set Referrer-Policy \"strict-origin-when-cross-origin\"\n    \n    # PHP configuration\n    php_admin_flag engine on\n    php_admin_value open_basedir \"/var/www/:/tmp/:/usr/share/php/\"\n    php_admin_value disable_functions \"exec,passthru,shell_exec,system,proc_open,popen\"\n</VirtualHost>\n\n# Enable/disable Apache modules\nsudo a2dismod cgi\nsudo a2dismod cgid\nsudo a2enmod proxy_fcgi\nsudo a2enconf php8.1-fpm\n\n# ======================================\n# NGINX SECURITY CONFIGURATION\n# ======================================\n\n# /etc/nginx/sites-available/default\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    root /var/www/html;\n    \n    # PHP-FPM configuration (secure alternative to CGI)\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;\n        \n        # Security headers\n        fastcgi_param PHP_VALUE \"open_basedir=/var/www/:/tmp/:/usr/share/php/\";\n        fastcgi_param PHP_VALUE \"disable_functions=exec,passthru,shell_exec,system,proc_open,popen\";\n        fastcgi_param PHP_VALUE \"allow_url_fopen=Off\";\n        fastcgi_param PHP_VALUE \"allow_url_include=Off\";\n        \n        # Prevent PHP information disclosure\n        fastcgi_hide_header X-Powered-By;\n        \n        # Restrict execution\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        try_files $fastcgi_script_name =404;\n    }\n    \n    # Security headers\n    add_header X-Content-Type-Options nosniff always;\n    add_header X-Frame-Options DENY always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n    \n    # Disable PHP CGI\n    # location ~ \\.php$ {\n    #     # fastcgi_pass unix:/var/run/php/php-cgi.sock;  # DISABLED\n    # }\n}\n\n# ======================================\n# DETECTION AND LOGGING\n# ======================================\n\n# Apache logging for suspicious activity\n# /etc/apache2/apache2.conf\n\n# Enhanced logging\nLogFormat \"%h %l %u %t \\\"%r\\\" %>s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\" \\\"%{X-Forwarded-For}i\\\"\" combined_with_forward\n\n# Log PHP CGI activity\nCustomLog ${APACHE_LOG_DIR}/php_cgi_access.log combined_with_forward\n\n# Enable security module\n# a2enmod security2\n\n# ModSecurity configuration\n# /etc/modsecurity/modsecurity.conf\n\nSecRuleEngine On\n\n# Block PHP CGI exploitation attempts\nSecRule ARGS \"@contains -d\" \"phase:1,log,deny,id:1001,msg:'PHP CGI injection attempt'\"\nSecRule ARGS \"@contains -s\" \"phase:1,log,deny,id:1002,msg:'PHP CGI source disclosure attempt'\"\nSecRule QUERY_STRING \"@contains -d\" \"phase:1,log,deny,id:1003,msg:'PHP CGI -d parameter injection'\"\nSecRule QUERY_STRING \"@contains -s\" \"phase:1,log,deny,id:1004,msg:'PHP CGI -s parameter injection'\"\n\n# Monitor for common exploit patterns\nSecRule REQUEST_URI \"@rx (?i)php.*\\?.*-d.*allow_url_include\" \"phase:1,log,deny,id:1005,msg:'CVE-2012-1823 exploitation attempt'\"\n\n# ======================================\n# COMPROMISE ASSESSMENT SCRIPT\n# ======================================\n\n#!/bin/bash\n# PHP CVE-2012-1823 Compromise Assessment\n\necho \"=== PHP CVE-2012-1823 Compromise Assessment ===\"\nDATE=$(date '+%Y-%m-%d %H:%M:%S')\nLOG_FILE=\"/var/log/cve_2012_1823_assessment_$DATE.log\"\n\necho \"Assessment started at: $DATE\" | tee $LOG_FILE\n\n# Check current PHP version\necho \"\\n1. Current PHP Version:\" | tee -a $LOG_FILE\nphp -v | tee -a $LOG_FILE\n\n# Check for vulnerable versions\necho \"\\n2. Vulnerability Check:\" | tee -a $LOG_FILE\nPHP_VERSION=$(php -r \"echo PHP_VERSION;\")\nif [[ \"$PHP_VERSION\" < \"5.4.3\" ]]; then\n    echo \"⚠ VULNERABLE: PHP version $PHP_VERSION is vulnerable to CVE-2012-1823\" | tee -a $LOG_FILE\nelse\n    echo \"✓ PHP version $PHP_VERSION appears to be patched\" | tee -a $LOG_FILE\nfi\n\n# Check for PHP CGI processes\necho \"\\n3. PHP CGI Process Check:\" | tee -a $LOG_FILE\nif pgrep -f \"php-cgi\" > /dev/null; then\n    echo \"⚠ PHP CGI processes found (potential risk):\" | tee -a $LOG_FILE\n    ps aux | grep php-cgi | tee -a $LOG_FILE\nelse\n    echo \"✓ No PHP CGI processes found\" | tee -a $LOG_FILE\nfi\n\n# Check Apache configuration for CGI\necho \"\\n4. Apache CGI Configuration Check:\" | tee -a $LOG_FILE\nif [ -f \"/etc/apache2/mods-enabled/cgi.load\" ]; then\n    echo \"⚠ Apache CGI module is enabled\" | tee -a $LOG_FILE\nelse\n    echo \"✓ Apache CGI module is disabled\" | tee -a $LOG_FILE\nfi\n\n# Check for suspicious files in web directories\necho \"\\n5. Suspicious File Check:\" | tee -a $LOG_FILE\nWEB_DIRS=(\"/var/www/html\" \"/var/www\" \"/usr/share/nginx/html\")\nSUSPICIOUS_FILES=(\"shell.php\" \"backdoor.php\" \"c99.php\" \"r57.php\" \"webshell.php\")\n\nfor dir in \"${WEB_DIRS[@]}\"; do\n    if [ -d \"$dir\" ]; then\n        echo \"Checking $dir...\" | tee -a $LOG_FILE\n        for file in \"${SUSPICIOUS_FILES[@]}\"; do\n            if find \"$dir\" -name \"$file\" 2>/dev/null | grep -q .; then\n                echo \"⚠ Suspicious file found: $file\" | tee -a $LOG_FILE\n                find \"$dir\" -name \"$file\" | tee -a $LOG_FILE\n            fi\n        done\n    fi\ndone\n\n# Check for recent PHP error logs with exploitation patterns\necho \"\\n6. Error Log Analysis:\" | tee -a $LOG_FILE\nif [ -f \"/var/log/php_errors.log\" ]; then\n    echo \"Recent suspicious PHP errors:\" | tee -a $LOG_FILE\n    grep -i \"allow_url_include\\|auto_prepend_file\\|allow_url_fopen\" /var/log/php_errors.log | tail -20 | tee -a $LOG_FILE\nfi\n\n# Check web server logs for exploitation attempts\necho \"\\n7. Web Server Log Analysis:\" | tee -a $LOG_FILE\nLOG_PATTERNS=(\"?-d.*allow_url_include\" \"?-s\" \"?-d\" \"auto_prepend_file\")\nWEB_LOGS=(\"/var/log/apache2/access.log\" \"/var/log/nginx/access.log\")\n\nfor log in \"${WEB_LOGS[@]}\"; do\n    if [ -f \"$log\" ]; then\n        echo \"Checking $log...\" | tee -a $LOG_FILE\n        for pattern in \"${LOG_PATTERNS[@]}\"; do\n            if grep \"$pattern\" \"$log\" > /dev/null; then\n                echo \"⚠ Potential exploitation attempts found:\" | tee -a $LOG_FILE\n                grep \"$pattern\" \"$log\" | tail -10 | tee -a $LOG_FILE\n            fi\n        done\n    fi\ndone\n\n# Check system for unusual network connections\necho \"\\n8. Network Connection Check:\" | tee -a $LOG_FILE\necho \"Active network connections:\" | tee -a $LOG_FILE\nnetstat -tuln | grep LISTEN | tee -a $LOG_FILE\n\n# Check for unusual processes\necho \"\\n9. Process Check:\" | tee -a $LOG_FILE\necho \"Running processes (checking for unusual activity):\" | tee -a $LOG_FILE\nps aux | grep -E \"(nc|netcat|python.*-m|perl.*-e)\" | tee -a $LOG_FILE\n\necho \"\\nAssessment complete. Log saved to: $LOG_FILE\" | tee -a $LOG_FILE\n\n# ======================================\n# PHP-FPM CONFIGURATION (SECURE ALTERNATIVE)\n# ======================================\n\n# /etc/php/8.1/fpm/pool.d/www.conf\n\n[www]\nuser = www-data\ngroup = www-data\nlisten = /run/php/php8.1-fpm.sock\nlisten.owner = www-data\nlisten.group = www-data\npm = dynamic\npm.max_children = 50\npm.start_servers = 5\npm.min_spare_servers = 5\npm.max_spare_servers = 35\npm.max_requests = 500\n\n# Security settings\nsecurity.limit_extensions = .php\nphp_admin_value[disable_functions] = exec,passthru,shell_exec,system,proc_open,popen\nphp_admin_value[open_basedir] = /var/www/:/tmp/:/usr/share/php/\nphp_admin_flag[allow_url_fopen] = off\nphp_admin_flag[allow_url_include] = off\nphp_admin_value[upload_tmp_dir] = /var/tmp/php_uploads\n\n# Process management\npm.process_idle_timeout = 10s\npm.max_requests = 500\n\n# ======================================\n# AUTOMATED PATCH DEPLOYMENT\n# ======================================\n\n#!/bin/bash\n# Automated PHP Security Patch Deployment\n\nset -e\n\nBACKUP_DIR=\"/var/backups/php_cve_patch_$(date +%Y%m%d_%H%M%S)\"\nLOG_FILE=\"/var/log/php_cve_patch.log\"\n\nlog_message() {\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $1\" | tee -a $LOG_FILE\n}\n\nbackup_configuration() {\n    log_message \"Creating backup in $BACKUP_DIR\"\n    mkdir -p \"$BACKUP_DIR\"\n    \n    # Backup PHP configuration\n    cp -r /etc/php* \"$BACKUP_DIR/\" 2>/dev/null || true\n    \n    # Backup Apache configuration\n    cp -r /etc/apache2 \"$BACKUP_DIR/\" 2>/dev/null || true\n    \n    # Backup Nginx configuration\n    cp -r /etc/nginx \"$BACKUP_DIR/\" 2>/dev/null || true\n    \n    log_message \"Backup completed\"\n}\n\nupdate_php() {\n    log_message \"Starting PHP update\"\n    \n    # Detect distribution\n    if command -v apt > /dev/null; then\n        # Ubuntu/Debian\n        apt update\n        apt upgrade -y php*\n        systemctl restart apache2\n    elif command -v yum > /dev/null; then\n        # CentOS/RHEL\n        yum update -y php*\n        systemctl restart httpd\n    else\n        log_message \"Unsupported distribution\"\n        exit 1\n    fi\n    \n    log_message \"PHP update completed\"\n}\n\nverify_patch() {\n    log_message \"Verifying patch installation\"\n    \n    PHP_VERSION=$(php -r \"echo PHP_VERSION;\")\n    log_message \"New PHP version: $PHP_VERSION\"\n    \n    if [[ \"$PHP_VERSION\" < \"5.4.3\" ]]; then\n        log_message \"ERROR: PHP version still vulnerable\"\n        exit 1\n    fi\n    \n    # Test PHP functionality\n    echo \"<?php echo 'PHP test successful'; ?>\" > /tmp/php_test.php\n    php /tmp/php_test.php > /dev/null\n    rm /tmp/php_test.php\n    \n    log_message \"Patch verification successful\"\n}\n\ndisable_cgi() {\n    log_message \"Disabling PHP CGI\"\n    \n    # Disable Apache CGI module\n    if command -v a2dismod > /dev/null; then\n        a2dismod cgi || true\n        systemctl reload apache2\n    fi\n    \n    log_message \"PHP CGI disabled\"\n}\n\n# Main execution\nmain() {\n    log_message \"Starting PHP CVE-2012-1823 patch deployment\"\n    \n    backup_configuration\n    update_php\n    disable_cgi\n    verify_patch\n    \n    log_message \"Patch deployment completed successfully\"\n    log_message \"Backup available at: $BACKUP_DIR\"\n    log_message \"Reboot recommended to ensure all services use new PHP version\"\n}\n\n# Run if executed directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n    main \"$@\"\nfi\n\n# ======================================\n# CONTINUOUS MONITORING\n# ======================================\n\n# /etc/cron.d/php_security_monitor\n# Run every hour\n0 * * * * root /usr/local/bin/php_cve_monitor.sh >> /var/log/php_security_monitor.log\n\n#!/bin/bash\n# /usr/local/bin/php_cve_monitor.sh\n\necho \"[$(date '+%Y-%m-%d %H:%M:%S')] PHP Security Monitor Check\"\n\n# Check for PHP CGI processes\nif pgrep -f \"php-cgi\" > /dev/null; then\n    echo \"WARNING: PHP CGI processes detected\"\n    echo \"Process details:\"\n    ps aux | grep php-cgi\n    \n    # Send alert\n    # mail -s \"PHP CGI Alert\" admin@example.com <<< \"PHP CGI processes detected on $(hostname)\"\nfi\n\n# Check web server logs for exploitation attempts\nLOG_PATTERNS=(\"?-d\" \"?-s\" \"allow_url_include\")\nALERT_THRESHOLD=5\nALERT_COUNT=0\n\nfor pattern in \"${LOG_PATTERNS[@]}\"; do\n    # Check recent logs (last hour)\n    RECENT_COUNT=$(grep \"$pattern\" /var/log/apache2/access.log 2>/dev/null | grep \"$(date '+%d/%b/%Y:%H' -d '1 hour ago')\" | wc -l)\n    ALERT_COUNT=$((ALERT_COUNT + RECENT_COUNT))\ndone\n\nif [ $ALERT_COUNT -gt $ALERT_THRESHOLD ]; then\n    echo \"HIGH ALERT: $ALERT_COUNT potential exploitation attempts detected\"\n    # mail -s \"HIGH ALERT: PHP Exploitation Attempts\" admin@example.com <<< \"Multiple PHP exploitation attempts detected on $(hostname)\"\nfi\n\necho \"Security check completed\""
      }
    ]
  },
  {
    "pluginId": 20019,
    "title": "External Redirect",
    "defaultRisk": "Medium",
    "cweid": "601",
    "description": "The application contains an open redirect vulnerability where user-controlled input is used to redirect users to external websites without proper validation. This allows attackers to redirect users to malicious sites for phishing, malware distribution, or other attacks.",
    "simplified_description": "Your application has a security flaw that allows attackers to redirect users to malicious websites. This is like having a receptionist that redirects visitors to any address they provide - attackers could send your users to fake login pages, malware sites, or phishing websites that steal their credentials.",
    "solution": "Implement strict validation of redirect URLs, use a whitelist approach, and avoid direct user input for redirect destinations.",
    "simplified_solution": "Create a list of approved redirect URLs, validate all redirect parameters against this whitelist, use relative URLs when possible, and implement proper URL validation to prevent malicious redirects.",
    "references": [
      {
        "name": "OWASP Open Redirect",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      },
      {
        "name": "CWE-601: URL Redirection to Untrusted Site",
        "url": "https://cwe.mitre.org/data/definitions/601.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure URL Redirect Implementation",
        "solution_description": "This solution demonstrates how to prevent open redirect vulnerabilities by implementing URL validation, whitelisting approaches, and secure redirect handling in various web frameworks.",
        "affected_files": "Authentication controllers, login/logout handlers, OAuth flow handlers, redirect middleware, utility functions",
        "code": "// BAD: Vulnerable open redirect\napp.get('/redirect', (req, res) => {\n    const targetUrl = req.query.url; // User-controlled input\n    res.redirect(targetUrl); // Vulnerable: redirects anywhere\n});\n\n// GOOD: Secure redirect implementation\napp.get('/redirect', (req, res) => {\n    const targetUrl = req.query.url;\n    \n    // Validate against whitelist\n    if (isAllowedRedirectUrl(targetUrl)) {\n        res.redirect(targetUrl);\n    } else {\n        res.status(400).send('Invalid redirect URL');\n    }\n});\n\n// ========================================\n// SECURITY VALIDATION UTILITIES\n// ========================================\n\nclass SecureRedirectValidator {\n    // Whitelist of allowed domains and paths\n    private static readonly ALLOWED_DOMAINS = [\n        'yourdomain.com',\n        'app.yourdomain.com',\n        'admin.yourdomain.com'\n    ];\n    \n    private static readonly ALLOWED_PATHS = [\n        '/dashboard',\n        '/profile',\n        '/settings',\n        '/home'\n    ];\n    \n    /**\n     * Validates if a URL is safe for redirect\n     * @param url The URL to validate\n     * @returns true if safe, false otherwise\n     */\n    static isValidRedirectUrl(url: string): boolean {\n        if (!url || typeof url !== 'string') {\n            return false;\n        }\n        \n        try {\n            // Parse the URL\n            const parsedUrl = new URL(url);\n            \n            // Allow only HTTP/HTTPS protocols\n            if (!['http:', 'https:'].includes(parsedUrl.protocol)) {\n                return false;\n            }\n            \n            // Check if domain is in whitelist\n            const hostname = parsedUrl.hostname.toLowerCase();\n            if (!this.ALLOWED_DOMAINS.some(domain => \n                hostname === domain || hostname.endsWith('.' + domain))) {\n                return false;\n            }\n            \n            // Optional: Restrict to certain paths\n            const pathname = parsedUrl.pathname;\n            if (this.ALLOWED_PATHS.length > 0 && \n                !this.ALLOWED_PATHS.includes(pathname)) {\n                return false;\n            }\n            \n            // Reject URLs with suspicious parts\n            if (this.containsSuspiciousPatterns(url)) {\n                return false;\n            }\n            \n            return true;\n            \n        } catch (error) {\n            // Invalid URL format\n            return false;\n        }\n    }\n    \n    /**\n     * Alternative validation using path mapping\n     * @param target The redirect target (can be path or full URL)\n     * @returns Safe redirect URL\n     */\n    static getSafeRedirectUrl(target: string, defaultUrl: string = '/dashboard'): string {\n        if (!target || typeof target !== 'string') {\n            return defaultUrl;\n        }\n        \n        // If it's a relative path, validate and return\n        if (target.startsWith('/') && !target.startsWith('//')) {\n            return this.isValidPath(target) ? target : defaultUrl;\n        }\n        \n        // If it's a full URL, validate against whitelist\n        if (this.isValidRedirectUrl(target)) {\n            return target;\n        }\n        \n        // Default to safe location\n        return defaultUrl;\n    }\n    \n    /**\n     * Validates URL path components\n     */\n    private static isValidPath(path: string): boolean {\n        // Reject dangerous patterns\n        const dangerousPatterns = [\n            /\\//\\//,  // Double slashes\n            /\\\\/,     // Backslashes\n            /\\.\\./,    // Directory traversal\n            /\\0/,      // Null bytes\n            /[<>]/,    // HTML injection\n        ];\n        \n        return !dangerousPatterns.some(pattern => pattern.test(path));\n    }\n    \n    /**\n     * Checks for suspicious URL patterns\n     */\n    private static containsSuspiciousPatterns(url: string): boolean {\n        const suspiciousPatterns = [\n            /data:/i,      // Data URLs\n            /javascript:/i, // JavaScript URLs\n            /vbscript:/i,  // VBScript URLs\n            /file:/i,      // File URLs\n            /ftp:/i,       // FTP URLs\n        ];\n        \n        return suspiciousPatterns.some(pattern => pattern.test(url));\n    }\n}\n\n// ========================================\n// CONTROLLER IMPLEMENTATION (Express.js)\n// ========================================\n\nconst express = require('express');\nconst app = express();\n\n// Authentication flow with secure redirect\napp.post('/login', (req, res) => {\n    const { username, password, redirectTo } = req.body;\n    \n    // Authenticate user\n    if (authenticateUser(username, password)) {\n        req.session.user = { username };\n        \n        // Secure redirect after login\n        const safeRedirectUrl = SecureRedirectValidator.getSafeRedirectUrl(\n            redirectTo, \n            '/dashboard'\n        );\n        \n        res.redirect(safeRedirectUrl);\n    } else {\n        res.status(401).render('login', { \n            error: 'Invalid credentials',\n            redirectTo: redirectTo\n        });\n    }\n});\n\n// Logout with secure redirect\napp.post('/logout', (req, res) => {\n    const redirectTo = req.body.redirectTo || '/login';\n    \n    // Clear session\n    req.session.destroy((err) => {\n        if (err) {\n            console.error('Logout error:', err);\n            return res.redirect('/login');\n        }\n        \n        // Secure redirect after logout\n        const safeRedirectUrl = SecureRedirectValidator.getSafeRedirectUrl(\n            redirectTo,\n            '/login'\n        );\n        \n        res.redirect(safeRedirectUrl);\n    });\n});\n\n// ========================================\n// SPRING BOOT IMPLEMENTATION (Java)\n// ========================================\n\n@Component\npublic class RedirectService {\n    \n    private static final List<String> ALLOWED_DOMAINS = Arrays.asList(\n        \"yourdomain.com\",\n        \"app.yourdomain.com\"\n    );\n    \n    /**\n     * Validates and returns safe redirect URL\n     */\n    public String getSafeRedirectUrl(String targetUrl, String defaultUrl) {\n        if (StringUtils.isEmpty(targetUrl)) {\n            return defaultUrl;\n        }\n        \n        try {\n            URI uri = new URI(targetUrl);\n            \n            // Allow only HTTP/HTTPS\n            if (!Arrays.asList(\"http\", \"https\").contains(uri.getScheme())) {\n                return defaultUrl;\n            }\n            \n            // Check domain whitelist\n            String host = uri.getHost();\n            if (host != null && !isAllowedDomain(host)) {\n                return defaultUrl;\n            }\n            \n            // For relative URLs, ensure they start with / and don't have //\n            if (targetUrl.startsWith(\"/\") && !targetUrl.startsWith(\"//\")) {\n                return targetUrl;\n            }\n            \n            return defaultUrl;\n            \n        } catch (URISyntaxException e) {\n            return defaultUrl;\n        }\n    }\n    \n    private boolean isAllowedDomain(String host) {\n        return ALLOWED_DOMAINS.stream()\n            .anyMatch(allowed -> host.equals(allowed) || host.endsWith(\".\" + allowed));\n    }\n}\n\n@Controller\npublic class AuthController {\n    \n    private final RedirectService redirectService;\n    \n    @PostMapping(\"/login\")\n    public String login(@ModelAttribute LoginRequest request,\n                       RedirectAttributes redirectAttributes,\n                       HttpServletRequest httpRequest) {\n        \n        // Authenticate user\n        if (authService.authenticate(request.getUsername(), request.getPassword())) {\n            \n            // Get redirect target from request\n            String redirectTo = request.getRedirectTo();\n            \n            // Validate redirect URL\n            String safeRedirectUrl = redirectService.getSafeRedirectUrl(\n                redirectTo, \n                \"/dashboard\"\n            );\n            \n            // Add success message\n            redirectAttributes.addFlashAttribute(\"message\", \"Login successful\");\n            \n            return \"redirect:\" + safeRedirectUrl;\n            \n        } else {\n            redirectAttributes.addFlashAttribute(\"error\", \"Invalid credentials\");\n            return \"redirect:/login\";\n        }\n    }\n}\n\n// ========================================\n// FRONTEND IMPLEMENTATION (React)\n// ========================================\n\nimport React, { useState, useEffect } from 'react';\n\nconst SecureRedirectHandler = () => {\n    const [redirectUrl, setRedirectUrl] = useState('/dashboard');\n    \n    useEffect(() => {\n        // Get redirect parameter from URL\n        const urlParams = new URLSearchParams(window.location.search);\n        const redirectTo = urlParams.get('redirectTo');\n        \n        if (redirectTo) {\n            // Validate redirect URL\n            const safeUrl = validateRedirectUrl(redirectTo);\n            setRedirectUrl(safeUrl);\n        }\n    }, []);\n    \n    const validateRedirectUrl = (url) => {\n        // Allow only relative URLs or specific allowed domains\n        const allowedDomains = ['yourdomain.com', 'app.yourdomain.com'];\n        \n        try {\n            // If it's a relative URL\n            if (url.startsWith('/') && !url.startsWith('//')) {\n                return url;\n            }\n            \n            // If it's an absolute URL, check domain\n            const parsedUrl = new URL(url, window.location.origin);\n            const hostname = parsedUrl.hostname.toLowerCase();\n            \n            if (allowedDomains.some(domain => \n                hostname === domain || hostname.endsWith('.' + domain))) {\n                return url;\n            }\n            \n            // Default to dashboard\n            return '/dashboard';\n            \n        } catch (e) {\n            return '/dashboard';\n        }\n    };\n    \n    const handleLogin = async (credentials) => {\n        try {\n            const response = await fetch('/api/login', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    ...credentials,\n                    redirectTo: redirectUrl\n                })\n            });\n            \n            if (response.ok) {\n                window.location.href = redirectUrl;\n            } else {\n                throw new Error('Login failed');\n            }\n        } catch (error) {\n            console.error('Login error:', error);\n            // Handle error\n        }\n    };\n    \n    return (\n        <LoginForm onLogin={handleLogin} />\n    );\n};\n\nexport default SecureRedirectHandler;\n\n// ========================================\n// CONFIGURATION AND TESTING\n// ========================================\n\n/*\nSECURITY TESTING CHECKLIST:\n\n1. Test Cases for Open Redirect:\n   - Normal redirects to allowed domains\n   - Redirect attempts to malicious domains\n   - JavaScript/data URL injection attempts\n   - Path traversal attempts\n   - URL encoding bypass attempts\n   - Null byte injection attempts\n\n2. Automated Tests:\n```javascript\n// Jest test examples\ndescribe('Redirect Security', () => {\n    test('allows valid internal redirects', () => {\n        expect(SecureRedirectValidator.isValidRedirectUrl('/dashboard'))\n            .toBe(true);\n    });\n    \n    test('blocks malicious external redirects', () => {\n        expect(SecureRedirectValidator.isValidRedirectUrl('http://evil.com'))\n            .toBe(false);\n    });\n    \n    test('blocks JavaScript URLs', () => {\n        expect(SecureRedirectValidator.isValidRedirectUrl('javascript:alert(1)'))\n            .toBe(false);\n    });\n    \n    test('blocks data URLs', () => {\n        expect(SecureRedirectValidator.isValidRedirectUrl('data:text/html,<script>alert(1)</script>'))\n            .toBe(false);\n    });\n});\n```\n\n3. Security Headers:\n   - Implement Content-Security-Policy header\n   - Add X-Frame-Options: DENY or SAMEORIGIN\n   - Use Referrer-Policy: strict-origin-when-cross-origin\n   - Enable X-Content-Type-Options: nosniff\n\n4. Monitoring:\n   - Log redirect attempts\n   - Monitor for suspicious patterns\n   - Alert on multiple failed redirect attempts\n   - Track unusual redirect destinations\n\n5. Code Review:\n   - Check all redirect usage\n   - Verify input validation\n   - Ensure proper error handling\n   - Review URL parsing logic\n*/"
      }
    ]
  },
  {
    "pluginId": 30001,
    "title": "Buffer Overflow",
    "defaultRisk": "High",
    "cweid": 121,
    "description": "Buffer overflow vulnerabilities occur when a program writes data beyond the boundaries of a fixed-length buffer, overwriting adjacent memory locations. This can lead to program crashes, data corruption, or arbitrary code execution. The vulnerability typically arises from unsafe use of functions like strcpy(), sprintf(), gets(), or improper array bounds checking.",
    "simplified_description": "Your application has a memory safety vulnerability where it can be tricked into writing data beyond allocated memory limits, like pouring water into a glass that's already full - the excess water spills over and damages whatever is nearby. Attackers can exploit this to crash your application, steal sensitive data, or execute malicious code on your server.",
    "solution": "Implement bounds checking, use safe string functions, enable compiler protections, and adopt memory-safe programming practices.",
    "simplified_solution": "Replace unsafe functions like strcpy() and gets() with safe alternatives like strncpy() and fgets(). Always validate array bounds and buffer sizes. Enable compiler protections like stack canaries and ASLR. Use memory-safe languages or frameworks when possible. Implement comprehensive input validation and length limits for all data processing.",
    "references": [
      {
        "name": "OWASP Buffer Overflow",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Buffer_Overflow_Cheat_Sheet.html"
      },
      {
        "name": "CWE-121: Stack-based Buffer Overflow",
        "url": "https://cwe.mitre.org/data/definitions/121.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Memory-Safe Programming",
        "solution_description": "Implement bounds checking, use safe string operations, enable compiler protections, and adopt secure coding practices to prevent buffer overflows.",
        "affected_files": "C/C++ source files, native code modules, string processing functions, input validation routines, network data handlers, file processing utilities",
        "code": "// VULNERABLE EXAMPLES:\nvoid vulnerableCopy(char* dest, const char* src) {\n    strcpy(dest, src); // No bounds checking\n}\n\n// SECURE EXAMPLES:\nvoid secureCopy(char* dest, size_t destSize, const char* src) {\n    if (!dest || !src || destSize == 0) {\n        return; // Input validation\n    }\n    \n    size_t srcLen = strnlen(src, destSize - 1);\n    if (srcLen >= destSize) {\n        return; // Handle truncation\n    }\n    \n    strncpy(dest, src, destSize - 1);\n    dest[destSize - 1] = '\\0'; // Ensure null termination\n}\n\n// Use safe string operations\n#include <string>\n#include <vector>\n\nclass SecureStringHandler {\npublic:\n    std::string safeConcat(const std::string& str1, const std::string& str2) {\n        const size_t MAX_LENGTH = 1024;\n        if (str1.length() + str2.length() > MAX_LENGTH) {\n            throw std::length_error(\"String too long\");\n        }\n        return str1 + str2;\n    }\n};"
      }
    ]
  },
  {
    "pluginId": 30002,
    "title": "Format String Error",
    "defaultRisk": "High",
    "cweid": 134,
    "description": "Format string vulnerabilities occur when user-supplied input is used directly as a format string in functions like printf(), sprintf(), syslog(), or error logging functions. This allows attackers to read memory contents, write to arbitrary memory locations, or execute arbitrary code by crafting format strings with %x, %s, %n specifiers.",
    "simplified_description": "Your application has a vulnerability where malicious users can inject special formatting characters into input that gets processed by string formatting functions. This is like giving someone a blank check and letting them fill in the amount - attackers can use format specifiers like %x, %s, and %n to read sensitive data from memory or even modify your program's memory to execute malicious code.",
    "solution": "Never use user-supplied input as format strings. Always use proper format specifiers and validate input before string formatting operations.",
    "simplified_solution": "Replace dangerous functions that use user input as format strings with safe alternatives that separate format strings from data. Always use literal format strings like '%s' for user input, never use user input directly as the format string. Enable compiler warnings for format string vulnerabilities and validate all input that will be used in formatting operations.",
    "references": [
      {
        "name": "OWASP Format String Attack",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Format_String_Cheat_Sheet.html"
      },
      {
        "name": "CWE-134: Use of Externally-Controlled Format String",
        "url": "https://cwe.mitre.org/data/definitions/134.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Format String Handling",
        "solution_description": "Implement proper format string handling by separating format strings from user data, using safe formatting functions, and enabling compiler protections.",
        "affected_files": "C/C++ source files, logging functions, error handling routines, string formatting code, user input processing, internationalization/localization code",
        "code": "// VULNERABLE EXAMPLES:\nvoid vulnerableLog(char* userInput) {\n    printf(userInput); // DANGEROUS: userInput used as format string\n}\n\n// SECURE EXAMPLES:\nvoid secureLog(const char* userInput) {\n    if (!userInput) {\n        return; // Input validation\n    }\n    \n    // Validate length\n    if (strlen(userInput) > 1024) {\n        printf(\"[LOG] %s\", \"Input too long\");\n        return;\n    }\n    \n    // SAFE: Use literal format string with %s specifier\n    printf(\"[LOG] %s\", userInput);\n}\n\n// Input sanitization\nstd::string sanitizeFormatString(const std::string& input) {\n    std::string result;\n    for (char c : input) {\n        if (c == '%') {\n            result += \"%%\"; // Escape percent sign\n        } else if (c >= 32 && c <= 126) { // Printable ASCII\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Safe logging class\nclass SecureLogger {\npublic:\n    void logError(const std::string& errorMessage, const std::string& userMessage = \"\") {\n        std::string safeUserMessage = sanitizeFormatString(userMessage);\n        fprintf(stderr, \"ERROR: %s - %s\\n\", errorMessage.c_str(), safeUserMessage.c_str());\n    }\n};"
      }
    ]
  },
  {
    "pluginId": 40003,
    "title": "CRLF Injection",
    "defaultRisk": "Medium",
    "cweid": "93",
    "description": "CRLF (Carriage Return Line Feed) Injection vulnerabilities allow attackers to inject HTTP headers through CRLF characters, potentially leading to HTTP response splitting, cache poisoning, or cross-site scripting.",
    "simplified_description": "Your application has a security flaw that allows attackers to inject special characters that can manipulate HTTP headers. This is like allowing someone to add fake addresses to your mail - attackers can redirect users to malicious websites, steal cookies, or poison web caches.",
    "solution": "Implement strict input validation, remove CRLF characters from user input, use secure HTTP client libraries, and validate all header values.",
    "simplified_solution": "Remove or escape all carriage return (\\r) and line feed (\\n) characters from user input, validate all data before using it in HTTP headers, use modern web frameworks that automatically handle header injection, and implement proper input sanitization.",
    "references": [
      {
        "name": "OWASP CRLF Injection",
        "url": "https://owasp.org/www-community/vulnerabilities/CRLF_Injection"
      },
      {
        "name": "CWE-93: Improper Neutralization of CRLF Sequences ('HTTP Response Splitting')",
        "url": "https://cwe.mitre.org/data/definitions/93.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "CRLF Injection Prevention",
        "solution_description": "Comprehensive CRLF injection prevention including input validation, header sanitization, and secure HTTP response handling.",
        "affected_files": "HTTP response handling, redirect controllers, cookie setting, file download functionality, logging systems",
        "code": "// ==========================\n// CRLF INJECTION PREVENTION UTILITIES\n// ==========================\npublic class CrlfInjectionPrevention {\n    private static final Logger logger = LoggerFactory.getLogger(CrlfInjectionPrevention.class);\n    \n    private static final Pattern CRLF_PATTERN = Pattern.compile(\"[\\\\r\\\\n]\");\n    private static final Pattern CRLF_URL_PATTERN = Pattern.compile(\"%0[ad]|%0[AD]\");\n    \n    /**\n     * Sanitizes input to prevent CRLF injection by removing CRLF characters\n     */\n    public static String sanitize(String input) {\n        if (input == null) {\n            return null;\n        }\n        \n        // Remove CRLF characters\n        String sanitized = CRLF_PATTERN.matcher(input).replaceAll(\"\");\n        \n        // Remove URL-encoded CRLF characters\n        sanitized = CRLF_URL_PATTERN.matcher(sanitized).replaceAll(\"\");\n        \n        if (!sanitized.equals(input)) {\n            logger.warn(\"CRLF injection attempt detected and blocked: {}\", input);\n        }\n        \n        return sanitized;\n    }\n    \n    /**\n     * Validates input for CRLF injection patterns\n     */\n    public static boolean isValid(String input) {\n        if (input == null) {\n            return true; // Null is considered valid\n        }\n        \n        // Check for CRLF characters\n        if (CRLF_PATTERN.matcher(input).find()) {\n            return false;\n        }\n        \n        // Check for URL-encoded CRLF characters\n        if (CRLF_URL_PATTERN.matcher(input).find()) {\n            return false;\n        }\n        \n        return true;\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 40008,
    "title": "Parameter Tampering",
    "defaultRisk": "Medium",
    "cweid": "642",
    "description": "Parameter tampering occurs when attackers modify parameters in HTTP requests, hidden form fields, cookies, or URL parameters to bypass security controls, manipulate application logic, access unauthorized data, or escalate privileges. This includes tampering with price parameters, user IDs, quantity fields, status flags, authentication tokens, or any other data transmitted between client and server that isn't properly validated on the server side.",
    "simplified_description": "Your application has a security flaw that allows attackers to modify data being sent between their browser and your server. This is like allowing someone to change prices on price tags before they reach the cashier - attackers can manipulate product prices, change user IDs to access other people's accounts, modify quantities in shopping carts, or bypass security checks by tampering with authentication tokens and parameters.",
    "solution": "Implement comprehensive server-side validation for all parameters, use digital signatures for critical data, validate business logic constraints, implement proper session management, use server-side state management, and never trust client-supplied data for security decisions.",
    "simplified_solution": "Validate every parameter on the server before processing, even if it was validated on the client. Check that prices match your database, verify users can only access their own data, validate all business rules, use secure session tokens, implement CSRF protection, add digital signatures to critical parameters, log all modifications for audit purposes, and never trust hidden form fields or JavaScript validation for security.",
    "references": [
      {
        "name": "OWASP Parameter Tampering",
        "url": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
      },
      {
        "name": "CWE-642: External Control of Critical State Data",
        "url": "https://cwe.mitre.org/data/definitions/642.html"
      },
      {
        "name": "OWASP Input Validation Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Spring Boot Parameter Security",
        "solution_description": "Comprehensive parameter validation and tampering prevention using Spring Boot, Bean Validation annotations, custom validators, digital signatures for critical parameters, server-side state management, and audit logging for all parameter modifications.",
        "affected_files": "Controller classes, request DTOs, validation classes, security configuration, audit services, middleware filters, configuration files (application.yml)",
        "code": "// ============================================\n// SECURE ORDER REQUEST DTO WITH VALIDATION\n// ============================================\n\nimport javax.validation.constraints.*;\nimport java.math.BigDecimal;\nimport java.util.List;\n\n@Data\n@JsonIgnoreProperties(ignoreUnknown = true) // Ignore unknown parameters\npublic class SecureOrderRequestDTO {\n    \n    @NotNull(message = \"User ID is required\")\n    @Positive(message = \"User ID must be positive\")\n    private Long userId;\n    \n    @NotBlank(message = \"Session token is required\")\n    @Pattern(regexp = \"^[a-zA-Z0-9-_]{32,64}$\", message = \"Invalid session token format\")\n    private String sessionToken;\n    \n    @NotEmpty(message = \"Order items cannot be empty\")\n    @Size(max = 50, message = \"Maximum 50 items per order\")\n    private List<OrderItemDTO> items;\n    \n    @Valid\n    private ShippingAddressDTO shippingAddress;\n    \n    @NotBlank(message = \"Currency is required\")\n    @Pattern(regexp = \"^[A-Z]{3}$\", message = \"Invalid currency format\")\n    private String currency;\n    \n    // Digital signature for tamper detection\n    @NotBlank(message = \"Request signature is required\")\n    @Pattern(regexp = \"^[a-fA-F0-9]{64}$\", message = \"Invalid signature format\")\n    private String signature;\n    \n    @Positive(message = \"Discount must be positive\")\n    @Max(value = 100, message = \"Discount cannot exceed 100%\")\n    private BigDecimal discountPercentage = BigDecimal.ZERO;\n    \n    // Secure getter for calculated total\n    public BigDecimal getTotal() {\n        return items.stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add)\n            .subtract(calculateDiscountAmount());\n    }\n    \n    private BigDecimal calculateDiscountAmount() {\n        return items.stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add)\n            .multiply(discountPercentage)\n            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);\n    }\n    \n    @Data\n    public static class OrderItemDTO {\n        \n        @NotNull(message = \"Product ID is required\")\n        @Positive(message = \"Product ID must be positive\")\n        private Long productId;\n        \n        @NotNull(message = \"Quantity is required\")\n        @Min(value = 1, message = \"Minimum quantity is 1\")\n        @Max(value = 100, message = \"Maximum quantity is 100\")\n        private Integer quantity;\n        \n        @NotNull(message = \"Price is required\")\n        @Positive(message = \"Price must be positive\")\n        @DecimalMin(value = \"0.01\", message = \"Price cannot be less than 0.01\")\n        @DecimalMax(value = \"99999.99\", message = \"Price cannot exceed 99999.99\")\n        private BigDecimal price;\n        \n        // Server-side price verification\n        public boolean isValidPrice(BigDecimal serverPrice) {\n            return price != null && \n                   serverPrice != null &&\n                   price.compareTo(serverPrice) == 0;\n        }\n    }\n    \n    @Data\n    public static class ShippingAddressDTO {\n        \n        @NotBlank(message = \"Address line 1 is required\")\n        @Size(max = 100, message = \"Address line 1 too long\")\n        private String addressLine1;\n        \n        @Size(max = 100, message = \"Address line 2 too long\")\n        private String addressLine2;\n        \n        @NotBlank(message = \"City is required\")\n        @Size(max = 50, message = \"City name too long\")\n        @Pattern(regexp = \"^[a-zA-Z\\s-']+$\", message = \"Invalid city name\")\n        private String city;\n        \n        @NotBlank(message = \"State/Province is required\")\n        @Size(max = 50, message = \"State/Province name too long\")\n        @Pattern(regexp = \"^[a-zA-Z\\s-']+$\", message = \"Invalid state name\")\n        private String state;\n        \n        @NotBlank(message = \"Postal code is required\")\n        @Pattern(regexp = \"^[A-Za-z0-9\\s-]{3,10}$\", message = \"Invalid postal code format\")\n        private String postalCode;\n        \n        @NotBlank(message = \"Country is required\")\n        @Pattern(regexp = \"^[A-Z]{2}$\", message = \"Invalid country code\")\n        private String country;\n    }\n}\n\n// ============================================\n// PARAMETER TAMPERING PREVENTION SERVICE\n// ============================================\n\n@Service\n@Transactional\npublic class ParameterTamperPreventionService {\n    \n    private final ProductService productService;\n    private final UserService userService;\n    private final SessionService sessionService;\n    private final AuditService auditService;\n    private final SignatureService signatureService;\n    \n    // HMAC secret key for signing critical parameters\n    @Value(\"${parameter.signature.secret}\")\n    private String signatureSecret;\n    \n    // Create secure order with comprehensive tamper protection\n    public OrderResponse createSecureOrder(SecureOrderRequestDTO request, String ipAddress, String userAgent) {\n        \n        // 1. Verify digital signature first\n        if (!verifySignature(request)) {\n            auditService.logTamperingAttempt(null, \"Invalid signature\", ipAddress);\n            throw new SecurityException(\"Request signature verification failed\");\n        }\n        \n        // 2. Validate session and authorize user\n        Session session = sessionService.validateSession(request.getSessionToken());\n        if (!session.getUserId().equals(request.getUserId())) {\n            auditService.logTamperingAttempt(session.getUserId(), \"User ID tampering\", ipAddress);\n            throw new SecurityException(\"User ID mismatch\");\n        }\n        \n        // 3. Validate each order item against server data\n        for (SecureOrderRequestDTO.OrderItemDTO item : request.getItems()) {\n            validateOrderItem(item, session.getUserId(), ipAddress);\n        }\n        \n        // 4. Validate business rules and constraints\n        validateBusinessRules(request, session.getUserId(), ipAddress);\n        \n        // 5. Calculate total server-side and verify\n        BigDecimal serverTotal = calculateOrderTotal(request.getItems(), request.getDiscountPercentage());\n        \n        // 6. Create order with tamper-evident data\n        Order order = createOrderEntity(request, session.getUserId());\n        order.setIpAddress(ipAddress);\n        order.setUserAgent(userAgent);\n        order.setOriginalSignature(request.getSignature());\n        order.setCalculatedTotal(serverTotal);\n        \n        // 7. Save order and generate response with new signature\n        Order savedOrder = orderRepository.save(order);\n        OrderResponse response = new OrderResponse(savedOrder);\n        response.setResponseSignature(signatureService.signResponse(response, signatureSecret));\n        \n        // 8. Audit successful order creation\n        auditService.logOrderCreation(session.getUserId(), savedOrder.getId(), ipAddress);\n        \n        return response;\n    }\n    \n    // Validate individual order item for tampering\n    private void validateOrderItem(SecureOrderRequestDTO.OrderItemDTO item, Long userId, String ipAddress) {\n        \n        // Get current server price and product data\n        Product product = productService.getProductById(item.getProductId());\n        if (product == null) {\n            auditService.logTamperingAttempt(userId, \"Invalid product ID: \" + item.getProductId(), ipAddress);\n            throw new IllegalArgumentException(\"Product not found: \" + item.getProductId());\n        }\n        \n        // Verify price hasn't been tampered\n        if (!item.getPrice().equals(product.getCurrentPrice())) {\n            auditService.logTamperingAttempt(userId, \n                \"Price tampering - Product: \" + item.getProductId() + \n                \", Client price: \" + item.getPrice() + \n                \", Server price: \" + product.getCurrentPrice(), ipAddress);\n            throw new SecurityException(\"Price verification failed for product: \" + item.getProductId());\n        }\n        \n        // Validate quantity limits\n        if (item.getQuantity() > product.getMaxOrderQuantity()) {\n            auditService.logTamperingAttempt(userId, \n                \"Quantity tampering - Product: \" + item.getProductId() + \n                \", Requested: \" + item.getQuantity() + \n                \", Max allowed: \" + product.getMaxOrderQuantity(), ipAddress);\n            throw new IllegalArgumentException(\"Quantity exceeds maximum allowed for product: \" + item.getProductId());\n        }\n        \n        // Check product availability\n        if (item.getQuantity() > product.getStockQuantity()) {\n            throw new IllegalArgumentException(\"Insufficient stock for product: \" + item.getProductId());\n        }\n        \n        // Verify user has access to this product (business-specific rules)\n        if (!productService.userCanPurchaseProduct(userId, item.getProductId())) {\n            auditService.logTamperingAttempt(userId, \"Unauthorized product access: \" + item.getProductId(), ipAddress);\n            throw new SecurityException(\"Unauthorized product access\");\n        }\n    }\n    \n    // Validate business rules to prevent tampering\n    private void validateBusinessRules(SecureOrderRequestDTO request, Long userId, String ipAddress) {\n        \n        // Check for discount tampering\n        if (request.getDiscountPercentage().compareTo(BigDecimal.ZERO) > 0) {\n            BigDecimal maxAllowedDiscount = userService.getMaxAllowedDiscount(userId);\n            if (request.getDiscountPercentage().compareTo(maxAllowedDiscount) > 0) {\n                auditService.logTamperingAttempt(userId, \n                    \"Discount tampering - Requested: \" + request.getDiscountPercentage() + \n                    \", Max allowed: \" + maxAllowedDiscount, ipAddress);\n                throw new SecurityException(\"Discount percentage exceeds allowed limit\");\n            }\n        }\n        \n        // Validate order frequency limits\n        if (!orderService.canPlaceOrder(userId, request.getItems().size())) {\n            auditService.logTamperingAttempt(userId, \"Order frequency limit exceeded\", ipAddress);\n            throw new SecurityException(\"Order frequency limit exceeded\");\n        }\n        \n        // Validate shipping address belongs to authorized regions\n        if (request.getShippingAddress() != null) {\n            if (!shippingService.isValidShippingAddress(userId, request.getShippingAddress())) {\n                auditService.logTamperingAttempt(userId, \"Invalid shipping address\", ipAddress);\n                throw new SecurityException(\"Invalid shipping address\");\n            }\n        }\n        \n        // Check for suspicious order patterns\n        if (isSuspiciousOrder(request, userId)) {\n            auditService.logTamperingAttempt(userId, \"Suspicious order pattern detected\", ipAddress);\n            throw new SecurityException(\"Order flagged for review\");\n        }\n    }\n    \n    // Calculate order total server-side\n    private BigDecimal calculateOrderTotal(List<SecureOrderRequestDTO.OrderItemDTO> items, BigDecimal discountPercentage) {\n        BigDecimal subtotal = items.stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n        \n        BigDecimal discountAmount = subtotal.multiply(discountPercentage)\n            .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);\n        \n        return subtotal.subtract(discountAmount);\n    }\n    \n    // Verify digital signature of request\n    private boolean verifySignature(SecureOrderRequestDTO request) {\n        try {\n            // Create string representation of critical parameters\n            String dataToSign = createSignatureData(request);\n            \n            // Verify HMAC signature\n            String expectedSignature = signatureService.signData(dataToSign, signatureSecret);\n            return MessageDigest.isEqual(\n                expectedSignature.getBytes(StandardCharsets.UTF_8),\n                request.getSignature().getBytes(StandardCharsets.UTF_8)\n            );\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    // Create canonical string for signature\n    private String createSignatureData(SecureOrderRequestDTO request) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"userId=\").append(request.getUserId());\n        sb.append(\"&currency=\").append(request.getCurrency());\n        sb.append(\"&discount=\").append(request.getDiscountPercentage());\n        \n        // Add items in consistent order\n        request.getItems().stream()\n            .sorted(Comparator.comparing(SecureOrderRequestDTO.OrderItemDTO::getProductId))\n            .forEach(item -> {\n                sb.append(\"&item_\").append(item.getProductId())\n                  .append(\"_qty=\").append(item.getQuantity())\n                  .append(\"_price=\").append(item.getPrice());\n            });\n        \n        return sb.toString();\n    }\n    \n    // Detect suspicious order patterns\n    private boolean isSuspiciousOrder(SecureOrderRequestDTO request, Long userId) {\n        \n        // Check for rapid order placement\n        long recentOrders = orderService.countRecentOrders(userId, Duration.ofMinutes(5));\n        if (recentOrders > 10) {\n            return true;\n        }\n        \n        // Check for unusual order value\n        BigDecimal userAvgOrderValue = userService.getAverageOrderValue(userId);\n        BigDecimal currentOrderValue = calculateOrderTotal(request.getItems(), BigDecimal.ZERO);\n        if (userAvgOrderValue.multiply(BigDecimal.valueOf(5)).compareTo(currentOrderValue) < 0) {\n            return true;\n        }\n        \n        // Check for high-value items first time buyer\n        if (userService.isFirstTimeBuyer(userId)) {\n            boolean hasHighValueItems = request.getItems().stream()\n                .anyMatch(item -> item.getPrice().compareTo(new BigDecimal(\"1000\")) > 0);\n            if (hasHighValueItems) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}\n\n// ============================================\n// DIGITAL SIGNATURE SERVICE\n// ============================================\n\n@Service\npublic class SignatureService {\n    \n    public String signData(String data, String secret) throws NoSuchAlgorithmException, InvalidKeyException {\n        Mac hmacSha256 = Mac.getInstance(\"HmacSHA256\");\n        SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), \"HmacSHA256\");\n        hmacSha256.init(secretKey);\n        \n        byte[] signatureBytes = hmacSha256.doFinal(data.getBytes(StandardCharsets.UTF_8));\n        return bytesToHex(signatureBytes);\n    }\n    \n    public String signResponse(OrderResponse response, String secret) throws NoSuchAlgorithmException, InvalidKeyException {\n        String dataToSign = String.format(\n            \"orderId=%s&total=%s&status=%s&timestamp=%s\",\n            response.getOrderId(),\n            response.getTotal(),\n            response.getStatus(),\n            response.getTimestamp()\n        );\n        return signData(dataToSign, secret);\n    }\n    \n    private String bytesToHex(byte[] bytes) {\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : bytes) {\n            String hex = Integer.toHexString(0xff & b);\n            if (hex.length() == 1) {\n                hexString.append('0');\n            }\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n}\n\n// ============================================\n// SECURE CONTROLLER WITH TAMPER PROTECTION\n// ============================================\n\n@RestController\n@RequestMapping(\"/api/v1/orders\")\n@Validated\npublic class SecureOrderController {\n    \n    private final ParameterTamperPreventionService tamperService;\n    private final RateLimiter rateLimiter;\n    \n    @PostMapping\n    @PreAuthorize(\"hasRole('USER')\")\n    public ResponseEntity<OrderResponse> createOrder(\n            @Valid @RequestBody SecureOrderRequestDTO request,\n            HttpServletRequest httpRequest) {\n        \n        // Rate limiting\n        if (!rateLimiter.tryAcquire()) {\n            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).build();\n        }\n        \n        String ipAddress = getClientIpAddress(httpRequest);\n        String userAgent = httpRequest.getHeader(\"User-Agent\");\n        \n        try {\n            OrderResponse response = tamperService.createSecureOrder(request, ipAddress, userAgent);\n            return ResponseEntity.ok(response);\n        } catch (SecurityException e) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();\n        } catch (IllegalArgumentException e) {\n            return ResponseEntity.badRequest().build();\n        }\n    }\n    \n    // Additional secure endpoints with tamper protection...\n    \n    private String getClientIpAddress(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null && !xForwardedFor.isEmpty() && !\"unknown\".equalsIgnoreCase(xForwardedFor)) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        \n        String xRealIp = request.getHeader(\"X-Real-IP\");\n        if (xRealIp != null && !xRealIp.isEmpty() && !\"unknown\".equalsIgnoreCase(xRealIp)) {\n            return xRealIp;\n        }\n        \n        return request.getRemoteAddr();\n    }\n}\n\n// ============================================\n// CUSTOM VALIDATOR FOR BUSINESS RULES\n// ============================================\n\n@Component\npublic class BusinessRuleValidator {\n    \n    public void validateOrderLimits(Long userId, List<OrderItemDTO> items) {\n        // Check user-specific order limits\n        User user = userService.getUserById(userId);\n        \n        int totalItems = items.stream()\n            .mapToInt(OrderItemDTO::getQuantity)\n            .sum();\n        \n        if (totalItems > user.getMaxItemsPerOrder()) {\n            throw new ConstraintViolationException(\"Order exceeds maximum items limit\", null);\n        }\n        \n        BigDecimal orderTotal = calculateOrderTotal(items);\n        if (orderTotal.compareTo(user.getMaxOrderValue()) > 0) {\n            throw new ConstraintViolationException(\"Order exceeds maximum value limit\", null);\n        }\n    }\n}\n\n<!-- ============================================ -->\n// ANGULAR CLIENT-SIDE PARAMETER SIGNING\n<!-- ============================================ -->\n\n/*\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as CryptoJS from 'crypto-js';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SecureOrderService {\n  private readonly API_URL = '/api/v1/orders';\n  private readonly SIGNATURE_SECRET = 'your-secret-key';\n\n  constructor(private http: HttpClient) {}\n\n  createOrder(orderRequest: SecureOrderRequest): Observable<OrderResponse> {\n    // Add digital signature to request\n    const signedRequest = this.signOrderRequest(orderRequest);\n    \n    return this.http.post<OrderResponse>(this.API_URL, signedRequest).pipe(\n      map(response => {\n        // Verify response signature\n        if (!this.verifyResponseSignature(response)) {\n          throw new Error('Response signature verification failed');\n        }\n        return response;\n      })\n    );\n  }\n\n  private signOrderRequest(request: SecureOrderRequest): SecureOrderRequest {\n    // Create canonical string for signature\n    const signatureData = this.createSignatureData(request);\n    \n    // Generate HMAC-SHA256 signature\n    const signature = CryptoJS.HmacSHA256(signatureData, this.SIGNATURE_SECRET).toString(CryptoJS.enc.Hex);\n    \n    return {\n      ...request,\n      signature\n    };\n  }\n\n  private createSignatureData(request: SecureOrderRequest): string {\n    const parts = [\n      `userId=${request.userId}`,\n      `currency=${request.currency}`,\n      `discount=${request.discountPercentage || 0}`\n    ];\n\n    // Add items in sorted order for consistent signature\n    request.items\n      .sort((a, b) => a.productId - b.productId)\n      .forEach(item => {\n        parts.push(\n          `item_${item.productId}_qty=${item.quantity}_price=${item.price}`\n        );\n      });\n\n    return parts.join('&');\n  }\n\n  private verifyResponseSignature(response: OrderResponse): boolean {\n    const expectedSignature = this.generateResponseSignature(response);\n    return response.responseSignature === expectedSignature;\n  }\n\n  private generateResponseSignature(response: OrderResponse): string {\n    const signatureData = `orderId=${response.orderId}&total=${response.total}&status=${response.status}&timestamp=${response.timestamp}`;\n    return CryptoJS.HmacSHA256(signatureData, this.SIGNATURE_SECRET).toString(CryptoJS.enc.Hex);\n  }\n}\n*/"
      }
    ]
  },
  {
    "pluginId": 40012,
    "title": "Cross Site Scripting (Reflected)",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Reflected Cross-Site Scripting (XSS) occurs when untrusted user input is immediately returned by the web application in an error message, search result, or any other response that includes some or all of the input provided by the user as part of the request, without that data being made safe to render in the browser, and without permanently storing the user provided data.",
    "simplified_description": "Your application has a security vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. This is like allowing someone to write graffiti on your walls that contains harmful instructions - when other people read it, their computers execute those harmful instructions, potentially stealing their login credentials, session cookies, or personal information.",
    "solution": "Implement proper input validation, output encoding, and use Content Security Policy (CSP) headers to prevent XSS attacks.",
    "simplified_solution": "Always sanitize user input before displaying it, use secure coding frameworks that automatically protect against XSS, implement Content Security Policy headers, and validate all user input on both client and server sides.",
    "references": [
      {
        "name": "OWASP XSS Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Input Handling and Output Encoding",
        "solution_description": "This solution demonstrates comprehensive XSS prevention through input validation, output encoding, and secure coding practices across multiple programming languages and frameworks.",
        "affected_files": "Web controllers, view templates, API endpoints, form handling code, JavaScript files",
        "code": "// ============= NODE.JS/EXPRESS SOLUTION =============\nconst express = require('express');\nconst helmet = require('helmet');\nconst validator = require('validator');\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Content Security Policy\napp.use(helmet.contentSecurityPolicy({\n    directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://trusted.cdn.com\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n}));\n\n// Input validation and sanitization middleware\nfunction validateAndSanitize(req, res, next) {\n    if (req.body) {\n        Object.keys(req.body).forEach(key => {\n            if (typeof req.body[key] === 'string') {\n                // Escape HTML entities\n                req.body[key] = validator.escape(req.body[key]);\n            }\n        });\n    }\n    next();\n}\n\n// Secure search endpoint (vulnerable to XSS before fix)\napp.get('/search', validateAndSanitize, (req, res) => {\n    const searchTerm = req.query.q || '';\n    \n    // Input validation\n    if (!validator.isLength(searchTerm, { min: 1, max: 100 })) {\n        return res.status(400).json({ error: 'Invalid search term length' });\n    }\n    \n    if (!validator.isAlphanumeric(searchTerm.replace(/\\s/g, ''))) {\n        return res.status(400).json({ error: 'Invalid characters in search term' });\n    }\n    \n    // Perform search (example)\n    const results = performSearch(searchTerm);\n    \n    // Secure response template\n    res.render('search-results', {\n        searchTerm: searchTerm,\n        results: results,\n        csrfToken: req.csrfToken()\n    });\n});\n\n// ============= REACT/FRONTEND SOLUTION =============\nimport React, { useState } from 'react';\nimport DOMPurify from 'dompurify';\n\nconst SearchComponent = () => {\n    const [searchTerm, setSearchTerm] = useState('');\n    const [results, setResults] = useState([]);\n    const [error, setError] = useState('');\n    \n    const handleSearch = async (e) => {\n        e.preventDefault();\n        setError('');\n        \n        // Client-side validation\n        if (!searchTerm.trim()) {\n            setError('Please enter a search term');\n            return;\n        }\n        \n        if (searchTerm.length > 100) {\n            setError('Search term too long');\n            return;\n        }\n        \n        try {\n            const response = await fetch(`/api/search?q=${encodeURIComponent(searchTerm)}`);\n            const data = await response.json();\n            \n            if (!response.ok) {\n                throw new Error(data.error || 'Search failed');\n            }\n            \n            setResults(data.results);\n        } catch (err) {\n            setError(err.message);\n        }\n    };\n    \n    // Safe HTML rendering with DOMPurify\n    const renderHighlight = (text) => {\n        const cleanText = DOMPurify.sanitize(text);\n        return <span dangerouslySetInnerHTML={{ __html: cleanText }} />;\n    };\n    \n    return (\n        <div className=\"search-container\">\n            <form onSubmit={handleSearch}>\n                <input\n                    type=\"text\"\n                    value={searchTerm}\n                    onChange={(e) => setSearchTerm(e.target.value)}\n                    placeholder=\"Search...\"\n                    maxLength={100}\n                    pattern=\"[a-zA-Z0-9\\s]+\"\n                    title=\"Only letters, numbers, and spaces allowed\"\n                />\n                <button type=\"submit\">Search</button>\n            </form>\n            \n            {error && <div className=\"error\">{error}</div>}\n            \n            <div className=\"results\">\n                {results.map((result, index) => (\n                    <div key={index} className=\"result-item\">\n                        <h3>{result.title}</h3>\n                        <p>{renderHighlight(result.snippet)}</p>\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n};\n\n// ============= PYTHON/DJANGO SOLUTION =============\nfrom django.shortcuts import render\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.http import require_http_methods\nfrom django.core.validators import RegexValidator\nfrom django.core.exceptions import ValidationError\nimport bleach\nimport re\n\n@csrf_protect\n@require_http_methods([\"GET\"])\ndef search_view(request):\n    search_term = request.GET.get('q', '').strip()\n    \n    # Input validation\n    try:\n        validate_search_term(search_term)\n    except ValidationError as e:\n        return JsonResponse({'error': str(e)}, status=400)\n    \n    # Perform search\n    results = perform_database_search(search_term)\n    \n    # Sanitize results for template\n    sanitized_results = []\n    for result in results:\n        sanitized_results.append({\n            'title': bleach.clean(result['title']),\n            'snippet': bleach.clean(result['snippet']),\n            'url': result['url']\n        })\n    \n    return render(request, 'search/results.html', {\n        'search_term': search_term,\n        'results': sanitized_results\n    })\n\ndef validate_search_term(value):\n    if not value:\n        raise ValidationError('Search term cannot be empty')\n    \n    if len(value) > 100:\n        raise ValidationError('Search term too long')\n    \n    # Allow only letters, numbers, and spaces\n    validator = RegexValidator(\n        regex=r'^[a-zA-Z0-9\\s]+$',\n        message='Only letters, numbers, and spaces are allowed'\n    )\n    validator(value)\n\n// ============= PHP SOLUTION =============\n<?php\n// Secure search implementation with XSS prevention\n\nfunction sanitizeInput($input) {\n    return htmlspecialchars(trim($input), ENT_QUOTES | ENT_HTML5, 'UTF-8');\n}\n\nfunction validateSearchTerm($term) {\n    if (empty($term)) {\n        throw new InvalidArgumentException('Search term cannot be empty');\n    }\n    \n    if (strlen($term) > 100) {\n        throw new InvalidArgumentException('Search term too long');\n    }\n    \n    // Allow only alphanumeric characters and spaces\n    if (!preg_match('/^[a-zA-Z0-9\\s]+$/', $term)) {\n        throw new InvalidArgumentException('Invalid characters in search term');\n    }\n    \n    return true;\n}\n\nfunction performSearch($term) {\n    // Implement your search logic here\n    // Always use prepared statements for database queries\n    global $pdo;\n    \n    $stmt = $pdo->prepare(\"SELECT * FROM articles WHERE title LIKE :term OR content LIKE :term\");\n    $stmt->execute(['term' => '%' . $term . '%']);\n    \n    return $stmt->fetchAll(PDO::FETCH_ASSOC);\n}\n\n// Secure search endpoint\nif ($_SERVER['REQUEST_METHOD'] === 'GET') {\n    try {\n        $searchTerm = sanitizeInput($_GET['q'] ?? '');\n        validateSearchTerm($searchTerm);\n        \n        $results = performSearch($searchTerm);\n        \n        // Secure output\n        foreach ($results as &$result) {\n            $result['title'] = htmlspecialchars($result['title'], ENT_QUOTES, 'UTF-8');\n            $result['content'] = htmlspecialchars($result['content'], ENT_QUOTES, 'UTF-8');\n        }\n        \n        header('Content-Type: application/json');\n        echo json_encode(['results' => $results]);\n        \n    } catch (Exception $e) {\n        header('HTTP/1.1 400 Bad Request');\n        header('Content-Type: application/json');\n        echo json_encode(['error' => $e->getMessage()]);\n    }\n}\n?>\n\n<!-- ============= HTML TEMPLATE WITH SECURE OUTPUT ============= -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Search Results</title>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';\">\n</head>\n<body>\n    <div class=\"search-container\">\n        <h1>Search Results</h1>\n        \n        <!-- Search form with proper encoding -->\n        <form action=\"/search\" method=\"GET\" onsubmit=\"return validateSearch()\">\n            <input \n                type=\"text\" \n                name=\"q\" \n                value=\"<?php echo htmlspecialchars($searchTerm ?? '', ENT_QUOTES, 'UTF-8'); ?>\"\n                placeholder=\"Search...\"\n                maxlength=\"100\"\n                pattern=\"[a-zA-Z0-9\\s]+\"\n                required\n            >\n            <button type=\"submit\">Search</button>\n        </form>\n        \n        <!-- Secure results display -->\n        <div class=\"results\">\n            <?php if (!empty($results)): ?>\n                <?php foreach ($results as $result): ?>\n                    <div class=\"result-item\">\n                        <h2><?php echo htmlspecialchars($result['title'], ENT_QUOTES, 'UTF-8'); ?></h2>\n                        <p><?php echo htmlspecialchars($result['content'], ENT_QUOTES, 'UTF-8'); ?></p>\n                    </div>\n                <?php endforeach; ?>\n            <?php else: ?>\n                <p>No results found.</p>\n            <?php endif; ?>\n        </div>\n    </div>\n    \n    <script>\n        function validateSearch() {\n            const searchInput = document.querySelector('input[name=\"q\"]');\n            const searchTerm = searchInput.value.trim();\n            \n            if (searchTerm.length === 0) {\n                alert('Please enter a search term');\n                return false;\n            }\n            \n            if (searchTerm.length > 100) {\n                alert('Search term too long');\n                return false;\n            }\n            \n            if (!/^[a-zA-Z0-9\\s]+$/.test(searchTerm)) {\n                alert('Only letters, numbers, and spaces are allowed');\n                return false;\n            }\n            \n            return true;\n        }\n    </script>\n</body>\n</html>\n\n// ============= ADDITIONAL SECURITY MEASURES =============\n\n/*\n1. IMPLEMENT CONTENT SECURITY POLICY (CSP):\n   - Use strict CSP headers to prevent inline script execution\n   - Whitelist trusted domains for external resources\n   - Use nonces or hashes for inline scripts when necessary\n\n2. USE SECURITY HEADERS:\n   - X-XSS-Protection: \"1; mode=block\"\n   - X-Content-Type-Options: \"nosniff\"\n   - X-Frame-Options: \"DENY\" or \"SAMEORIGIN\"\n   - Strict-Transport-Security for HTTPS sites\n\n3. INPUT VALIDATION BEST PRACTICES:\n   - Always validate on both client and server side\n   - Use whitelist validation (allow only known good input)\n   - Implement length limits and character restrictions\n   - Sanitize, but don't rely on sanitization alone\n\n4. OUTPUT ENCODING:\n   - HTML encode all user-generated content\n   - Use context-specific encoding (HTML, JavaScript, CSS, URL)\n   - Never concatenate untrusted data into executable contexts\n\n5. DEPENDENCY SECURITY:\n   - Regularly update all dependencies\n   - Use automated security scanning tools\n   - Monitor for security advisories\n\n6. TESTING:\n   - Perform automated XSS scanning\n   - Conduct manual penetration testing\n   - Use browser developer tools to test input handling\n   - Implement security unit tests\n\nIMPLEMENTATION CHECKLIST:\n✓ Add CSP headers\n✓ Validate all user input\n✓ Encode all output\n✓ Use secure frameworks\n✓ Implement CSRF protection\n✓ Set security headers\n✓ Regularly update dependencies\n✓ Conduct security testing\n*/"
      }
    ]
  },
  {
    "pluginId": 40014,
    "title": "Cross Site Scripting (Persistent)",
    "defaultRisk": "Critical",
    "cweid": "79",
    "description": "Persistent (stored) Cross-Site Scripting occurs when the malicious script is permanently stored on the target servers, such as in a database, in a message forum post, in a comment field, in visitor logs, in an audit trail, or in other fields. The victim then retrieves the malicious script from the server when it requests the stored information.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to permanently store malicious scripts in your system. This is like allowing someone to write invisible poison on your walls that affects everyone who reads it - the malicious code gets saved in your database and runs automatically every time someone views the affected page, potentially stealing their credentials or taking control of their accounts.",
    "solution": "Implement proper input validation, output encoding, and secure storage of user-generated content with Content Security Policy.",
    "simplified_solution": "Always validate and sanitize user input before storing it, encode all user-generated content before displaying it, implement Content Security Policy headers, use parameterized queries for database operations, and regularly scan for stored malicious content.",
    "references": [
      {
        "name": "OWASP Stored XSS Prevention",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Content Storage and Display System",
        "solution_description": "This solution provides comprehensive protection against stored XSS attacks through secure input validation, safe database storage, and proper output encoding when displaying user-generated content.",
        "affected_files": "Content management systems, comment sections, user profile pages, forum applications, database models, API endpoints",
        "code": "// ============= NODE.JS/EXPRESS - SECURE BLOG COMMENT SYSTEM =============\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst validator = require('validator');\nconst sanitizeHtml = require('sanitize-html');\nconst DOMPurify = require('isomorphic-dompurify');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", \"data:\", \"https:\"],\n            connectSrc: [\"'self'\"],\n            fontSrc: [\"'self'\"],\n            objectSrc: [\"'none'\"],\n            mediaSrc: [\"'self'\"],\n            frameSrc: [\"'none'\"]\n        }\n    }\n}));\n\n// Rate limiting to prevent spam and automated attacks\nconst commentLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 10, // limit each IP to 10 comments per windowMs\n    message: 'Too many comments from this IP, please try again later.'\n});\n\n// MongoDB Schema for Comments\nconst commentSchema = new mongoose.Schema({\n    content: {\n        type: String,\n        required: true,\n        maxlength: 2000,\n        trim: true\n    },\n    author: {\n        type: String,\n        required: true,\n        maxlength: 50,\n        trim: true\n    },\n    email: {\n        type: String,\n        required: true,\n        validate: [validator.isEmail, 'Invalid email']\n    },\n    postId: {\n        type: mongoose.Schema.Types.ObjectId,\n        required: true,\n        ref: 'Post'\n    },\n    ipAddress: String,\n    userAgent: String,\n    approved: {\n        type: Boolean,\n        default: false\n    },\n    createdAt: {\n        type: Date,\n        default: Date.now\n    }\n});\n\nconst Comment = mongoose.model('Comment', commentSchema);\n\n// Input sanitization and validation\nclass CommentValidator {\n    static sanitizeComment(commentData) {\n        return {\n            content: this.sanitizeContent(commentData.content),\n            author: this.sanitizeName(commentData.author),\n            email: validator.normalizeEmail(commentData.email)\n        };\n    }\n    \n    static sanitizeContent(content) {\n        // Allow basic HTML tags but sanitize dangerous ones\n        const cleanHtml = sanitizeHtml(content, {\n            allowedTags: ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li', 'blockquote', 'code'],\n            allowedAttributes: {\n                'a': ['href']\n            },\n            allowedSchemes: ['http', 'https', 'mailto'],\n            transformTags: {\n                'a': function(tagName, attribs) {\n                    // Validate href attribute\n                    if (attribs.href && !validator.isURL(attribs.href)) {\n                        delete attribs.href;\n                    }\n                    return { tagName, attribs };\n                }\n            }\n        });\n        \n        return DOMPurify.sanitize(cleanHtml, {\n            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li', 'blockquote', 'code'],\n            ALLOWED_ATTR: ['href']\n        });\n    }\n    \n    static sanitizeName(name) {\n        // Remove HTML tags and limit characters\n        return validator.escape(name.substring(0, 50));\n    }\n    \n    static validateComment(commentData) {\n        const errors = [];\n        \n        if (!commentData.content || commentData.content.trim().length === 0) {\n            errors.push('Comment content is required');\n        }\n        \n        if (commentData.content.length > 2000) {\n            errors.push('Comment content too long');\n        }\n        \n        if (!commentData.author || commentData.author.trim().length === 0) {\n            errors.push('Author name is required');\n        }\n        \n        if (!commentData.email || !validator.isEmail(commentData.email)) {\n            errors.push('Valid email is required');\n        }\n        \n        // Check for potential XSS patterns\n        const xssPatterns = [\n            /<script[^>]*>.*?<\\/script>/gi,\n            /javascript:/gi,\n            /on\\w+\\s*=/gi,\n            /<iframe[^>]*>/gi,\n            /<object[^>]*>/gi,\n            /<embed[^>]*>/gi\n        ];\n        \n        for (const pattern of xssPatterns) {\n            if (pattern.test(commentData.content)) {\n                errors.push('Comment contains potentially dangerous content');\n                break;\n            }\n        }\n        \n        return errors;\n    }\n}\n\n// Secure comment creation endpoint\napp.post('/api/posts/:postId/comments', commentLimiter, async (req, res) => {\n    try {\n        const { postId } = req.params;\n        \n        // Sanitize input\n        const sanitizedData = CommentValidator.sanitizeComment(req.body);\n        \n        // Validate input\n        const validationErrors = CommentValidator.validateComment(sanitizedData);\n        if (validationErrors.length > 0) {\n            return res.status(400).json({ \n                error: 'Validation failed', \n                details: validationErrors \n            });\n        }\n        \n        // Check if post exists\n        const post = await mongoose.model('Post').findById(postId);\n        if (!post) {\n            return res.status(404).json({ error: 'Post not found' });\n        }\n        \n        // Create comment with metadata\n        const comment = new Comment({\n            ...sanitizedData,\n            postId: postId,\n            ipAddress: req.ip,\n            userAgent: req.get('User-Agent'),\n            approved: false // Require moderation\n        });\n        \n        await comment.save();\n        \n        res.status(201).json({\n            message: 'Comment submitted for moderation',\n            commentId: comment._id\n        });\n        \n    } catch (error) {\n        console.error('Comment creation error:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Secure comment retrieval\napp.get('/api/posts/:postId/comments', async (req, res) => {\n    try {\n        const { postId } = req.params;\n        \n        // Only retrieve approved comments\n        const comments = await Comment.find({ \n            postId: postId, \n            approved: true \n        })\n        .sort({ createdAt: -1 })\n        .select('content author createdAt')\n        .lean();\n        \n        // Encode data for JSON response\n        const encodedComments = comments.map(comment => ({\n            content: comment.content, // Already sanitized when stored\n            author: comment.author,   // Already sanitized when stored\n            createdAt: comment.createdAt\n        }));\n        \n        res.json(encodedComments);\n        \n    } catch (error) {\n        console.error('Comment retrieval error:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// ============= REACT FRONTEND COMPONENT =============\nimport React, { useState, useEffect } from 'react';\nimport DOMPurify from 'dompurify';\n\nconst CommentSection = ({ postId }) => {\n    const [comments, setComments] = useState([]);\n    const [newComment, setNewComment] = useState({\n        content: '',\n        author: '',\n        email: ''\n    });\n    const [errors, setErrors] = useState([]);\n    const [isSubmitting, setIsSubmitting] = useState(false);\n    const [submitMessage, setSubmitMessage] = useState('');\n    \n    useEffect(() => {\n        fetchComments();\n    }, [postId]);\n    \n    const fetchComments = async () => {\n        try {\n            const response = await fetch(`/api/posts/${postId}/comments`);\n            if (response.ok) {\n                const data = await response.json();\n                setComments(data);\n            }\n        } catch (error) {\n            console.error('Error fetching comments:', error);\n        }\n    };\n    \n    const validateForm = () => {\n        const newErrors = [];\n        \n        if (!newComment.content.trim()) {\n            newErrors.push('Comment cannot be empty');\n        }\n        \n        if (newComment.content.length > 2000) {\n            newErrors.push('Comment too long');\n        }\n        \n        if (!newComment.author.trim()) {\n            newErrors.push('Name is required');\n        }\n        \n        if (!newComment.email.trim() || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(newComment.email)) {\n            newErrors.push('Valid email is required');\n        }\n        \n        setErrors(newErrors);\n        return newErrors.length === 0;\n    };\n    \n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        \n        if (!validateForm() || isSubmitting) {\n            return;\n        }\n        \n        setIsSubmitting(true);\n        setSubmitMessage('');\n        \n        try {\n            const response = await fetch(`/api/posts/${postId}/comments`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRF-Token': getCsrfToken()\n                },\n                body: JSON.stringify(newComment)\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok) {\n                setSubmitMessage('Comment submitted for moderation');\n                setNewComment({ content: '', author: '', email: '' });\n                setErrors([]);\n            } else {\n                setErrors(data.details || [data.error || 'Submission failed']);\n            }\n        } catch (error) {\n            console.error('Error submitting comment:', error);\n            setErrors(['Network error. Please try again.']);\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n    \n    const renderComment = (comment) => {\n        // Use DOMPurify for additional client-side protection\n        const cleanContent = DOMPurify.sanitize(comment.content, {\n            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li', 'blockquote', 'code'],\n            ALLOWED_ATTR: []\n        });\n        \n        return (\n            <div key={comment.id} className=\"comment\">\n                <div className=\"comment-header\">\n                    <h4>{comment.author}</h4>\n                    <span className=\"comment-date\">\n                        {new Date(comment.createdAt).toLocaleDateString()}\n                    </span>\n                </div>\n                <div \n                    className=\"comment-content\"\n                    dangerouslySetInnerHTML={{ __html: cleanContent }}\n                />\n            </div>\n        );\n    };\n    \n    return (\n        <div className=\"comment-section\">\n            <h3>Comments</h3>\n            \n            {/* Comment Form */}\n            <form onSubmit={handleSubmit} className=\"comment-form\">\n                <div className=\"form-group\">\n                    <textarea\n                        value={newComment.content}\n                        onChange={(e) => setNewComment({...newComment, content: e.target.value})}\n                        placeholder=\"Write your comment...\"\n                        maxLength={2000}\n                        required\n                    />\n                </div>\n                \n                <div className=\"form-row\">\n                    <input\n                        type=\"text\"\n                        value={newComment.author}\n                        onChange={(e) => setNewComment({...newComment, author: e.target.value})}\n                        placeholder=\"Your name\"\n                        maxLength={50}\n                        required\n                    />\n                    \n                    <input\n                        type=\"email\"\n                        value={newComment.email}\n                        onChange={(e) => setNewComment({...newComment, email: e.target.value})}\n                        placeholder=\"Your email\"\n                        required\n                    />\n                </div>\n                \n                {errors.length > 0 && (\n                    <div className=\"errors\">\n                        {errors.map((error, index) => (\n                            <p key={index} className=\"error\">{error}</p>\n                        ))}\n                    </div>\n                )}\n                \n                {submitMessage && (\n                    <p className=\"success-message\">{submitMessage}</p>\n                )}\n                \n                <button type=\"submit\" disabled={isSubmitting}>\n                    {isSubmitting ? 'Submitting...' : 'Submit Comment'}\n                </button>\n            </form>\n            \n            {/* Comments List */}\n            <div className=\"comments-list\">\n                {comments.map(renderComment)}\n            </div>\n        </div>\n    );\n};\n\nexport default CommentSection;\n\n// ============= PYTHON/DJANGO SOLUTION =============\nfrom django.db import models\nfrom django.core.validators import EmailValidator, RegexValidator\nfrom django.contrib.auth.models import User\nimport bleach\nimport re\n\n# Models\nclass Post(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n    \nclass Comment(models.Model):\n    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')\n    author = models.CharField(max_length=50, validators=[\n        RegexValidator(r'^[a-zA-Z0-9\\s]+$', 'Only alphanumeric characters and spaces allowed')\n    ])\n    email = models.EmailField()\n    content = models.TextField(max_length=2000)\n    approved = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    ip_address = models.GenericIPAddressField()\n    user_agent = models.TextField(blank=True)\n    \n    def clean(self):\n        # Additional validation and sanitization\n        self.author = bleach.clean(self.author, tags=[], strip=True)[:50]\n        self.content = self.sanitize_content(self.content)\n    \n    def sanitize_content(self, content):\n        # Allow basic HTML but sanitize dangerous content\n        allowed_tags = ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li', 'blockquote', 'code']\n        allowed_attributes = {'*': []}\n        \n        clean_content = bleach.clean(content, tags=allowed_tags, attributes=allowed_attributes)\n        \n        # Check for remaining XSS patterns\n        xss_patterns = [\n            r'javascript:',\n            r'on\\w+\\s*=',\n            r'<iframe',\n            r'<object',\n            r'<embed'\n        ]\n        \n        for pattern in xss_patterns:\n            if re.search(pattern, clean_content, re.IGNORECASE):\n                raise ValidationError('Content contains potentially dangerous elements')\n        \n        return clean_content\n\n# Views\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.http import require_http_methods\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\n\n@method_decorator(csrf_protect, name='dispatch')\nclass CommentView(View):\n    def post(self, request, post_id):\n        try:\n            # Get post\n            post = Post.objects.get(id=post_id)\n            \n            # Validate and sanitize input\n            author = bleach.clean(request.POST.get('author', ''), tags=[], strip=True)\n            email = request.POST.get('email', '')\n            content = request.POST.get('content', '')\n            \n            # Create comment with validation\n            comment = Comment(\n                post=post,\n                author=author,\n                email=email,\n                content=content,\n                ip_address=self.get_client_ip(request),\n                user_agent=request.META.get('HTTP_USER_AGENT', '')\n            )\n            \n            # This triggers clean() method for sanitization\n            comment.full_clean()\n            comment.save()\n            \n            return JsonResponse({\n                'message': 'Comment submitted for moderation',\n                'comment_id': comment.id\n            })\n            \n        except Post.DoesNotExist:\n            return JsonResponse({'error': 'Post not found'}, status=404)\n        except ValidationError as e:\n            return JsonResponse({'error': dict(e)}, status=400)\n        except Exception as e:\n            return JsonResponse({'error': 'Internal server error'}, status=500)\n    \n    def get(self, request, post_id):\n        try:\n            post = Post.objects.get(id=post_id)\n            comments = Comment.objects.filter(post=post, approved=True).order_by('-created_at')\n            \n            comments_data = [{\n                'author': comment.author,\n                'content': comment.content,  # Already sanitized\n                'created_at': comment.created_at.isoformat()\n            } for comment in comments]\n            \n            return JsonResponse({'comments': comments_data})\n            \n        except Post.DoesNotExist:\n            return JsonResponse({'error': 'Post not found'}, status=404)\n\n// ============= PHP SOLUTION =============\n<?php\n// Secure comment system with stored XSS prevention\n\nclass CommentSystem {\n    private $pdo;\n    \n    public function __construct($pdo) {\n        $this->pdo = $pdo;\n    }\n    \n    public function sanitizeInput($input, $type = 'text') {\n        switch ($type) {\n            case 'text':\n                return $this->sanitizeText($input);\n            case 'name':\n                return $this->sanitizeName($input);\n            case 'email':\n                return filter_var(trim($input), FILTER_SANITIZE_EMAIL);\n            default:\n                return htmlspecialchars(trim($input), ENT_QUOTES, 'UTF-8');\n        }\n    }\n    \n    private function sanitizeText($text) {\n        // Allow basic HTML tags but sanitize\n        $allowedTags = '<p><br><strong><em><u><ol><ul><li><blockquote><code>';\n        $text = strip_tags($text, $allowedTags);\n        \n        // Remove dangerous attributes\n        $text = preg_replace('/on\\w+\\s*=/i', '', $text);\n        $text = preg_replace('/javascript:/i', '', $text);\n        $text = preg_replace('/<iframe[^>]*>/i', '', $text);\n        $text = preg_replace('/<object[^>]*>/i', '', $text);\n        $text = preg_replace('/<embed[^>]*>/i', '', $text);\n        \n        return $text;\n    }\n    \n    private function sanitizeName($name) {\n        // Remove HTML tags and special characters\n        return substr(preg_replace('/[^a-zA-Z0-9\\s]/', '', $name), 0, 50);\n    }\n    \n    public function validateComment($data) {\n        $errors = [];\n        \n        if (empty($data['content']) || strlen(trim($data['content'])) === 0) {\n            $errors[] = 'Comment content is required';\n        }\n        \n        if (strlen($data['content']) > 2000) {\n            $errors[] = 'Comment content too long';\n        }\n        \n        if (empty($data['author']) || strlen(trim($data['author'])) === 0) {\n            $errors[] = 'Author name is required';\n        }\n        \n        if (empty($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {\n            $errors[] = 'Valid email is required';\n        }\n        \n        // Check for XSS patterns\n        $xssPatterns = [\n            '/<script[^>]*>.*?<\\/script>/is',\n            '/javascript:/is',\n            '/on\\w+\\s*=/is',\n            '/<iframe[^>]*>/is',\n            '/<object[^>]*>/is',\n            '/<embed[^>]*>/is'\n        ];\n        \n        foreach ($xssPatterns as $pattern) {\n            if (preg_match($pattern, $data['content'])) {\n                $errors[] = 'Comment contains potentially dangerous content';\n                break;\n            }\n        }\n        \n        return $errors;\n    }\n    \n    public function createComment($postId, $data) {\n        // Validate post exists\n        $stmt = $this->pdo->prepare(\"SELECT id FROM posts WHERE id = ?\");\n        $stmt->execute([$postId]);\n        \n        if (!$stmt->fetch()) {\n            throw new Exception('Post not found');\n        }\n        \n        // Sanitize and validate input\n        $sanitizedData = [\n            'content' => $this->sanitizeInput($data['content'], 'text'),\n            'author' => $this->sanitizeInput($data['author'], 'name'),\n            'email' => $this->sanitizeInput($data['email'], 'email')\n        ];\n        \n        $errors = $this->validateComment($sanitizedData);\n        if (!empty($errors)) {\n            throw new Exception(implode(', ', $errors));\n        }\n        \n        // Insert comment with prepared statement\n        $stmt = $this->pdo->prepare(\"\n            INSERT INTO comments (post_id, author, email, content, ip_address, user_agent, approved, created_at) \n            VALUES (?, ?, ?, ?, ?, ?, 0, NOW())\n        \");\n        \n        return $stmt->execute([\n            $postId,\n            $sanitizedData['author'],\n            $sanitizedData['email'],\n            $sanitizedData['content'],\n            $_SERVER['REMOTE_ADDR'],\n            $_SERVER['HTTP_USER_AGENT']\n        ]);\n    }\n    \n    public function getComments($postId) {\n        $stmt = $this->pdo->prepare(\"\n            SELECT author, content, created_at \n            FROM comments \n            WHERE post_id = ? AND approved = 1 \n            ORDER BY created_at DESC\n        \");\n        \n        $stmt->execute([$postId]);\n        return $stmt->fetchAll(PDO::FETCH_ASSOC);\n    }\n}\n\n// API endpoint\nheader('Content-Type: application/json');\n\ntry {\n    $commentSystem = new CommentSystem($pdo);\n    \n    if ($_SERVER['REQUEST_METHOD'] === 'POST') {\n        $postId = $_POST['post_id'] ?? null;\n        \n        if (!$postId) {\n            throw new Exception('Post ID is required');\n        }\n        \n        $commentSystem->createComment($postId, $_POST);\n        \n        echo json_encode([\n            'message' => 'Comment submitted for moderation'\n        ]);\n        \n    } elseif ($_SERVER['REQUEST_METHOD'] === 'GET') {\n        $postId = $_GET['post_id'] ?? null;\n        \n        if (!$postId) {\n            throw new Exception('Post ID is required');\n        }\n        \n        $comments = $commentSystem->getComments($postId);\n        \n        echo json_encode([\n            'comments' => $comments\n        ]);\n    }\n    \n} catch (Exception $e) {\n    header('HTTP/1.1 400 Bad Request');\n    echo json_encode([\n        'error' => $e->getMessage()\n    ]);\n}\n?>\n\n<!-- ============= HTML TEMPLATE ============= -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Blog Post</title>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\">\n</head>\n<body>\n    <div class=\"post-content\">\n        <!-- Post content here -->\n    </div>\n    \n    <div class=\"comments-section\">\n        <h3>Comments</h3>\n        \n        <!-- Comment Form -->\n        <form id=\"comment-form\" method=\"POST\" action=\"/api/comments\">\n            <input type=\"hidden\" name=\"post_id\" value=\"<?php echo htmlspecialchars($postId, ENT_QUOTES, 'UTF-8'); ?>\">\n            \n            <div class=\"form-group\">\n                <textarea \n                    name=\"content\" \n                    placeholder=\"Write your comment...\" \n                    maxlength=\"2000\"\n                    required\n                ></textarea>\n            </div>\n            \n            <div class=\"form-row\">\n                <input \n                    type=\"text\" \n                    name=\"author\" \n                    placeholder=\"Your name\" \n                    maxlength=\"50\"\n                    pattern=\"[a-zA-Z0-9\\s]+\"\n                    required\n                >\n                \n                <input \n                    type=\"email\" \n                    name=\"email\" \n                    placeholder=\"Your email\" \n                    required\n                >\n            </div>\n            \n            <button type=\"submit\">Submit Comment</button>\n        </form>\n        \n        <!-- Comments Display -->\n        <div id=\"comments-list\">\n            <?php if (!empty($comments)): ?>\n                <?php foreach ($comments as $comment): ?>\n                    <div class=\"comment\">\n                        <div class=\"comment-header\">\n                            <h4><?php echo htmlspecialchars($comment['author'], ENT_QUOTES, 'UTF-8'); ?></h4>\n                            <span><?php echo htmlspecialchars($comment['created_at'], ENT_QUOTES, 'UTF-8'); ?></span>\n                        </div>\n                        <div class=\"comment-content\">\n                            <?php echo $comment['content']; // Already sanitized ?>\n                        </div>\n                    </div>\n                <?php endforeach; ?>\n            <?php else: ?>\n                <p>No comments yet.</p>\n            <?php endif; ?>\n        </div>\n    </div>\n</body>\n</html>\n\n// ============= SECURITY MONITORING AND MAINTENANCE =============\n\n/*\nADDITIONAL SECURITY MEASURES:\n\n1. CONTENT MODERATION SYSTEM:\n   - Implement comment approval workflow\n   - Use AI/ML for automated spam and malicious content detection\n   - Set up moderation queue for human review\n\n2. RATE LIMITING AND ABUSE PREVENTION:\n   - Implement IP-based rate limiting\n   - Use CAPTCHA for anonymous comments\n   - Track and block abusive IPs\n\n3. LOGGING AND MONITORING:\n   - Log all comment submissions with metadata\n   - Monitor for suspicious patterns\n   - Set up alerts for potential attacks\n\n4. DATABASE SECURITY:\n   - Use parameterized queries for all database operations\n   - Implement proper database user permissions\n   - Regular database backups\n\n5. REGULAR SECURITY AUDITS:\n   - Automated vulnerability scanning\n   - Manual penetration testing\n   - Code review for new features\n\n6. SECURITY HEADERS:\n   Content-Security-Policy: default-src 'self'; script-src 'self'\n   X-XSS-Protection: 1; mode=block\n   X-Content-Type-Options: nosniff\n   X-Frame-Options: DENY\n   Referrer-Policy: strict-origin-when-cross-origin\n\nIMPLEMENTATION PRIORITY:\n1. Input validation and sanitization (CRITICAL)\n2. Output encoding (CRITICAL)\n3. Content Security Policy (HIGH)\n4. Moderation system (HIGH)\n5. Rate limiting (MEDIUM)\n6. Monitoring and logging (MEDIUM)\n*/"
      }
    ]
  },
  {
    "pluginId": 40016,
    "title": "Cross Site Scripting (Persistent) - Prime",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Prime Cross Site Scripting is a sophisticated persistent XSS attack that uses a prime number-based payload generation technique to evade detection and maintain persistence.",
    "simplified_description": "Your website has a sophisticated security vulnerability that allows attackers to inject highly advanced malicious code that's designed to evade security detection. This is like having criminals use special codes that security cameras can't recognize - the attack can persist for long periods and compromise many users.",
    "solution": "Implement advanced XSS detection, strict input validation, comprehensive output encoding, content security policies, and regular security scanning.",
    "simplified_solution": "Deploy advanced web application firewalls, implement strict input validation that blocks suspicious patterns, use modern frameworks with built-in XSS protection, regularly scan for malicious content, and monitor for unusual user behavior patterns.",
    "references": [
      {
        "name": "Advanced XSS Prevention",
        "url": "https://portswigger.net/web-security/cross-site-scripting/advanced"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Advanced XSS Protection",
        "solution_description": "Advanced XSS protection including sophisticated pattern detection, content security policies, behavioral analysis, and real-time monitoring.",
        "affected_files": "Input validation filters, security middleware, monitoring systems, content processing pipelines",
        "code": "// ==========================\n// ADVANCED XSS DETECTION SERVICE\n// ==========================\n@Service\npublic class AdvancedXssDetectionService {\n    private static final Logger logger = LoggerFactory.getLogger(AdvancedXssDetectionService.class);\n    \n    // Advanced XSS patterns including obfuscation techniques\n    private static final Pattern[] XSS_PATTERNS = {\n        // Standard XSS patterns\n        Pattern.compile(\"<script[^>]*>.*?</script>\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL),\n        Pattern.compile(\"javascript:\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"on\\w+\\s*=\", Pattern.CASE_INSENSITIVE),\n        \n        // Obfuscation patterns\n        Pattern.compile(\"([\\x00-\\x20]+)*([\\x00-\\x20])*([\\x00-\\x20])*([\\x00-\\x20])*\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"eval\\\\s*\\\\(([^)]+)\\\\)\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"String\\\\.fromCharCode\\\\s*\\\\(([^)]+)\\\\)\", Pattern.CASE_INSENSITIVE),\n        \n        // Encoding patterns\n        Pattern.compile(\"%[0-9a-fA-F]{2}\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"&#x?[0-9a-fA-F]+;\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"\\\\\\\\u[0-9a-fA-F]{4}\", Pattern.CASE_INSENSITIVE),\n        \n        // Advanced payload patterns\n        Pattern.compile(\"(\\\\w+\\\\s*\\\\+\\\\s*)+\\\\w+\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"\\\\[\\\\s*'\\\\w+'\\\\s*\\\\]\", Pattern.CASE_INSENSITIVE),\n        \n        // Prime and mathematical pattern detection\n        Pattern.compile(\"(?:2|3|5|7|11|13|17|19|23|29|31|37){3,}\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"\\\\b(?:math|Math)\\\\\\\\s*\\\\.\\\\\\\\s*(?:random|floor|ceil|round|pow|sqrt)\", Pattern.CASE_INSENSITIVE)\n    };\n    \n    public XssAnalysisResult analyzeContent(String content) {\n        if (content == null || content.trim().isEmpty()) {\n            return new XssAnalysisResult(false, Collections.emptyList(), 0.0);\n        }\n        \n        List<String> detectedPatterns = new ArrayList<>();\n        double riskScore = 0.0;\n        \n        // Check against all XSS patterns\n        for (Pattern pattern : XSS_PATTERNS) {\n            Matcher matcher = pattern.matcher(content);\n            while (matcher.find()) {\n                String matchedPattern = matcher.group();\n                detectedPatterns.add(matchedPattern);\n                \n                // Calculate risk score based on pattern complexity\n                riskScore += calculatePatternRisk(pattern.pattern(), matchedPattern);\n            }\n        }\n        \n        // Check for suspicious character sequences\n        riskScore += analyzeCharacterSuspicion(content);\n        \n        // Check for entropy-based detection (high entropy often indicates obfuscation)\n        double entropy = calculateEntropy(content);\n        if (entropy > 6.0) { // High entropy threshold\n            riskScore += entropy;\n            detectedPatterns.add(\"High entropy content detected\");\n        }\n        \n        boolean isXss = riskScore > 10.0 || detectedPatterns.size() > 3;\n        \n        if (isXss) {\n            logger.warn(\"XSS detected - Risk score: {}, Patterns: {}\", riskScore, detectedPatterns);\n        }\n        \n        return new XssAnalysisResult(isXss, detectedPatterns, riskScore);\n    }\n    \n    private double calculatePatternRisk(String pattern, String match) {\n        // Base risk scores for different pattern types\n        if (pattern.contains(\"script\")) return 5.0;\n        if (pattern.contains(\"javascript:\")) return 4.0;\n        if (pattern.contains(\"eval\")) return 6.0;\n        if (pattern.contains(\"fromCharCode\")) return 7.0;\n        if (pattern.contains(\"%[0-9a-fA-F]{2}\")) return 3.0;\n        if (pattern.contains(\"encoding\")) return 2.0;\n        if (pattern.contains(\"prime\")) return 4.0;\n        \n        return 1.0; // Base risk for any detected pattern\n    }\n    \n    private double analyzeCharacterSuspicion(String content) {\n        double suspicionScore = 0.0;\n        \n        // Count suspicious characters\n        long specialCharCount = content.chars()\n            .filter(c -> !Character.isLetterOrDigit(c) && !Character.isWhitespace(c))\n            .count();\n        \n        double specialCharRatio = (double) specialCharCount / content.length();\n        if (specialCharRatio > 0.3) {\n            suspicionScore += specialCharRatio * 10;\n        }\n        \n        // Check for consecutive suspicious characters\n        if (content.matches(\".*[\\\\\\\\<>\\\\\"\\\\'&]+.*\")) {\n            suspicionScore += 3.0;\n        }\n        \n        return suspicionScore;\n    }\n    \n    private double calculateEntropy(String content) {\n        Map<Character, Integer> frequency = new HashMap<>();\n        \n        for (char c : content.toCharArray()) {\n            frequency.put(c, frequency.getOrDefault(c, 0) + 1);\n        }\n        \n        double entropy = 0.0;\n        int length = content.length();\n        \n        for (int count : frequency.values()) {\n            double probability = (double) count / length;\n            entropy -= probability * (Math.log(probability) / Math.log(2));\n        }\n        \n        return entropy;\n    }\n}\n\n// ==========================\n// BEHAVIORAL ANALYSIS SERVICE\n// ==========================\n@Service\npublic class BehavioralAnalysisService {\n    private final Map<String, UserBehavior> userBehaviors = new ConcurrentHashMap<>();\n    \n    @EventListener\n    public void handleUserAction(UserActionEvent event) {\n        String userId = event.getUserId();\n        String action = event.getAction();\n        String content = event.getContent();\n        \n        UserBehavior behavior = userBehaviors.computeIfAbsent(userId, k -> new UserBehavior());\n        \n        // Update behavior metrics\n        behavior.recordAction(action, content);\n        \n        // Check for suspicious patterns\n        if (isSuspiciousBehavior(behavior)) {\n            logger.warn(\"Suspicious behavior detected for user {}: {}\", userId, behavior);\n            // Trigger security measures\n            handleSuspiciousUser(userId, behavior);\n        }\n    }\n    \n    private boolean isSuspiciousBehavior(UserBehavior behavior) {\n        // High rate of content submission\n        if (behavior.getRecentSubmissionRate() > 10) { // More than 10 submissions per minute\n            return true;\n        }\n        \n        // Multiple failed submissions with similar content\n        if (behavior.getFailedSubmissionCount() > 5) {\n            return true;\n        }\n        \n        // Submissions with high-risk content patterns\n        if (behavior.getHighRiskContentCount() > 3) {\n            return true;\n        }\n        \n        // Submissions from multiple IP addresses in short time\n        if (behavior.getUniqueIpCount() > 5) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private void handleSuspiciousUser(String userId, UserBehavior behavior) {\n        // Increment risk score\n        behavior.incrementRiskScore(20);\n        \n        // If risk score is high, take action\n        if (behavior.getRiskScore() > 50) {\n            // Temporarily block user\n            blockUserTemporarily(userId);\n            \n            // Notify security team\n            notifySecurityTeam(userId, behavior);\n        }\n    }\n}\n\n// ==========================\n// ENHANCED CONTENT VALIDATION\n// ==========================\n@Component\npublic class EnhancedContentValidator {\n    private final AdvancedXssDetectionService xssDetector;\n    private final BehavioralAnalysisService behaviorAnalyzer;\n    \n    public ValidationResult validateContent(String content, String userId, String ipAddress) {\n        ValidationResult result = new ValidationResult();\n        \n        // Basic validation\n        if (!isBasicContentValid(content)) {\n            result.setValid(false);\n            result.addError(\"Content fails basic validation\");\n            return result;\n        }\n        \n        // Advanced XSS detection\n        XssAnalysisResult xssResult = xssDetector.analyzeContent(content);\n        if (xssResult.isXss()) {\n            result.setValid(false);\n            result.addError(\"XSS detected: \" + String.join(\", \", xssResult.getDetectedPatterns()));\n            \n            // Record suspicious activity\n            recordSuspiciousActivity(userId, ipAddress, \"XSS_ATTEMPT\", content);\n            return result;\n        }\n        \n        // Content quality checks\n        ContentQualityResult qualityResult = analyzeContentQuality(content);\n        if (qualityResult.getQualityScore() < 0.3) {\n            result.setValid(false);\n            result.addError(\"Content quality too low: \" + qualityResult.getReasons());\n            return result;\n        }\n        \n        result.setValid(true);\n        return result;\n    }\n    \n    private ContentQualityResult analyzeContentQuality(String content) {\n        ContentQualityResult result = new ContentQualityResult();\n        double score = 1.0;\n        List<String> reasons = new ArrayList<>();\n        \n        // Check for spam characteristics\n        if (isSpamLike(content)) {\n            score -= 0.4;\n            reasons.add(\"Spam-like content detected\");\n        }\n        \n        // Check for excessive repetition\n        if (hasExcessiveRepetition(content)) {\n            score -= 0.3;\n            reasons.add(\"Excessive repetition detected\");\n        }\n        \n        // Check for readable language (vs random text)\n        if (!isReadableText(content)) {\n            score -= 0.2;\n            reasons.add(\"Content appears to be non-readable\");\n        }\n        \n        result.setQualityScore(Math.max(0.0, score));\n        result.setReasons(reasons);\n        return result;\n    }\n}\n\n// ==========================\n// REAL-TIME MONITORING\n// ==========================\n@Component\npublic class XssMonitoringService {\n    private final MeterRegistry meterRegistry;\n    private final WebSocketHandler webSocketHandler;\n    \n    public void recordXssAttempt(String userId, String pattern, String content) {\n        // Record metrics\n        Counter.builder(\"xss.attempts\")\n            .tag(\"user\", userId)\n            .tag(\"pattern\", pattern)\n            .register(meterRegistry)\n            .increment();\n        \n        // Log security event\n        logger.warn(\"XSS attempt recorded - User: {}, Pattern: {}, Content: {}\", \n                   userId, pattern, content.substring(0, Math.min(100, content.length())));\n        \n        // Real-time notification\n        notifySecurityTeam(userId, pattern, content);\n        \n        // Update real-time dashboard\n        webSocketHandler.broadcastSecurityEvent(new SecurityEvent(\n            \"XSS_ATTEMPT\", userId, pattern, Instant.now()\n        ));\n    }\n    \n    @EventListener\n    public void handleHighVolumeXss(HighVolumeXssEvent event) {\n        // Implement emergency measures\n        logger.error(\"High volume XSS attack detected: {} attempts in {} minutes\", \n                    event.getAttemptCount(), event.getTimeWindowMinutes());\n        \n        // Enable stricter validation\n        enableStrictValidationMode();\n        \n        // Rate limit endpoints\n        enableRateLimiting();\n        \n        // Notify security team\n        emergencySecurityNotification(event);\n    }\n}\n\n// ==========================\n// CONFIGURATION\n// ==========================\n@Configuration\npublic class XssProtectionConfig {\n    \n    @Bean\n    public FilterRegistrationBean<XssProtectionFilter> xssProtectionFilter() {\n        FilterRegistrationBean<XssProtectionFilter> registration = new FilterRegistrationBean<>();\n        registration.setFilter(new XssProtectionFilter());\n        registration.addUrlPatterns(\"/*\");\n        registration.setOrder(1);\n        return registration;\n    }\n    \n    @Bean\n    public WebSecurityCustomizer webSecurityCustomizer() {\n        return (web) -> web.ignoring().requestMatchers(\"/static/**\", \"/css/**\", \"/js/**\", \"/images/**\");\n    }\n}\n\n// ==========================\n// DATABASE SECURITY AUDIT\n// ==========================\n/*\n-- Audit table for XSS attempts\nCREATE TABLE xss_attempts (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id VARCHAR(255),\n    ip_address VARCHAR(45),\n    user_agent TEXT,\n    content_snippet TEXT,\n    detected_patterns JSON,\n    risk_score DECIMAL(5,2),\n    blocked BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_user_attempts (user_id, created_at),\n    INDEX idx_ip_attempts (ip_address, created_at),\n    INDEX idx_risk_score (risk_score)\n);\n\n-- Content integrity table\nCREATE TABLE content_integrity (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    content_id VARCHAR(255),\n    content_hash VARCHAR(64),\n    original_content TEXT,\n    sanitized_content TEXT,\n    risk_score DECIMAL(5,2),\n    approved BOOLEAN DEFAULT FALSE,\n    approved_by VARCHAR(255),\n    approved_at TIMESTAMP NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_content_hash (content_hash),\n    INDEX idx_approval_status (approved, created_at)\n);\n*/"
      }
    ]
  },
  {
    "pluginId": 40017,
    "title": "Cross Site Scripting (Persistent) - Spider",
    "defaultRisk": "High",
    "cweid": "79",
    "description": "Spider-based Cross Site Scripting vulnerabilities occur when web crawlers or spiders trigger XSS payloads stored in the application, affecting automated systems and potentially spreading malware through crawling infrastructure.",
    "simplified_description": "Your website has a security vulnerability that affects not just human users but also automated search engine crawlers and other web spiders. This is like having a disease that can spread through both people and automated systems - attackers can compromise search engine results and spread malware through legitimate crawling activities.",
    "solution": "Implement bot detection, content validation for all user agents, secure spider access controls, and comprehensive output encoding.",
    "simplified_solution": "Implement proper detection and handling of web crawlers, validate and sanitize all content regardless of who accesses it, use secure robots.txt configurations, monitor crawler behavior, and ensure all content is safely encoded for display.",
    "references": [
      {
        "name": "Search Engine Security",
        "url": "https://support.google.com/webmasters/answer/35769"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Spider XSS Protection",
        "solution_description": "Comprehensive spider XSS protection including bot detection, secure content serving, and crawler access controls.",
        "affected_files": "Robot.txt files, crawler middleware, content delivery systems, user agent detection, security filters",
        "code": "// ==========================\n// SPIDER/BOT DETECTION SERVICE\n// ==========================\n@Service\npublic class BotDetectionService {\n    private static final Logger logger = LoggerFactory.getLogger(BotDetectionService.class);\n    \n    // Known legitimate bot user agents\n    private static final Set<String> LEGITIMATE_BOTS = Set.of(\n        \"googlebot\", \"bingbot\", \"slurp\", \"duckduckbot\", \"baiduspider\",\n        \"yandexbot\", \"facebookexternalhit\", \"twitterbot\", \"linkedinbot\",\n        \"whatsapp\", \"telegrambot\", \"applebot\", \"ia_archiver\", \"semrushbot\"\n    );\n    \n    // Suspicious bot patterns\n    private static final Pattern[] SUSPICIOUS_BOT_PATTERNS = {\n        Pattern.compile(\"bot.*\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"crawler.*\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"spider.*\", Pattern.CASE_INSENSITIVE),\n        Pattern.compile(\"scraper.*\", Pattern.CASE_INSENSITIVE)\n    };\n    \n    public BotAnalysisResult analyzeRequest(HttpServletRequest request) {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String ipAddress = getClientIpAddress(request);\n        String referer = request.getHeader(\"Referer\");\n        \n        BotAnalysisResult result = new BotAnalysisResult();\n        result.setUserAgent(userAgent);\n        result.setIpAddress(ipAddress);\n        \n        // Check if it's a legitimate bot\n        boolean isLegitimateBot = isLegitimateBot(userAgent);\n        result.setLegitimateBot(isLegitimateBot);\n        \n        // Check for suspicious bot characteristics\n        boolean isSuspiciousBot = isSuspiciousBot(userAgent, ipAddress, referer);\n        result.setSuspiciousBot(isSuspiciousBot);\n        \n        // Analyze behavior patterns\n        BotBehavior behavior = analyzeBotBehavior(request, ipAddress);\n        result.setBehavior(behavior);\n        \n        // Calculate bot risk score\n        double riskScore = calculateBotRiskScore(result);\n        result.setRiskScore(riskScore);\n        \n        if (riskScore > 7.0) {\n            logger.warn(\"High-risk bot detected: {} from {}\", userAgent, ipAddress);\n        }\n        \n        return result;\n    }\n    \n    private boolean isLegitimateBot(String userAgent) {\n        if (userAgent == null) return false;\n        \n        String lowerAgent = userAgent.toLowerCase();\n        return LEGITIMATE_BOTS.stream().anyMatch(lowerAgent::contains);\n    }\n    \n    private boolean isSuspiciousBot(String userAgent, String ipAddress, String referer) {\n        // Check for fake bot user agents\n        if (userAgent != null) {\n            String lowerAgent = userAgent.toLowerCase();\n            \n            // Claims to be Googlebot but doesn't verify\n            if (lowerAgent.contains(\"googlebot\") && !verifyGooglebot(ipAddress)) {\n                return true;\n            }\n            \n            // Suspicious bot patterns\n            for (Pattern pattern : SUSPICIOUS_BOT_PATTERNS) {\n                if (pattern.matcher(lowerAgent).matches() && !isLegitimateBot(lowerAgent)) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check for automated behavior indicators\n        if (referer == null && isHighFrequencyRequester(ipAddress)) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private boolean verifyGooglebot(String ipAddress) {\n        // Verify Googlebot by reverse DNS lookup\n        try {\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostName = addr.getHostName();\n            \n            // Check if hostname ends with googlebot.com or google.com\n            if (hostName.endsWith(\"googlebot.com\") || hostName.endsWith(\"google.com\")) {\n                // Verify forward lookup matches\n                InetAddress[] addresses = InetAddress.getAllByName(hostName);\n                return Arrays.stream(addresses)\n                    .anyMatch(a -> a.getHostAddress().equals(ipAddress));\n            }\n        } catch (Exception e) {\n            logger.debug(\"Googlebot verification failed for {}: {}\", ipAddress, e.getMessage());\n        }\n        \n        return false;\n    }\n    \n    private BotBehavior analyzeBotBehavior(HttpServletRequest request, String ipAddress) {\n        BotBehavior behavior = new BotBehavior();\n        \n        // Check request patterns\n        String uri = request.getRequestURI();\n        String method = request.getMethod();\n        \n        // Analyze URL patterns\n        if (uri.contains(\"admin\") || uri.contains(\"api/v1/\")) {\n            behavior.setAccessesSensitiveEndpoints(true);\n        }\n        \n        if (method.equals(\"POST\") || method.equals(\"PUT\") || method.equals(\"DELETE\")) {\n            behavior.setMakesStateChangingRequests(true);\n        }\n        \n        // Check request rate\n        int recentRequests = getRecentRequestCount(ipAddress);\n        behavior.setRequestRate(recentRequests);\n        \n        // Check for unusual headers\n        if (hasUnusualHeaders(request)) {\n            behavior.setHasUnusualHeaders(true);\n        }\n        \n        return behavior;\n    }\n    \n    private double calculateBotRiskScore(BotAnalysisResult result) {\n        double score = 0.0;\n        \n        if (result.isSuspiciousBot()) {\n            score += 5.0;\n        }\n        \n        BotBehavior behavior = result.getBehavior();\n        if (behavior.isAccessesSensitiveEndpoints()) {\n            score += 3.0;\n        }\n        \n        if (behavior.isMakesStateChangingRequests()) {\n            score += 4.0;\n        }\n        \n        if (behavior.getRequestRate() > 100) {\n            score += 2.0;\n        }\n        \n        if (behavior.isHasUnusualHeaders()) {\n            score += 1.0;\n        }\n        \n        return score;\n    }\n}\n\n// ==========================\n// BOT-AWARE XSS FILTER\n// ==========================\n@Component\npublic class BotAwareXssFilter implements Filter {\n    \n    private final BotDetectionService botDetector;\n    private final XssDetectionService xssDetector;\n    private final RequestCounterService requestCounter;\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Analyze the request\n        BotAnalysisResult botAnalysis = botDetector.analyzeRequest(httpRequest);\n        \n        // Apply different security measures based on bot analysis\n        if (botAnalysis.isLegitimateBot()) {\n            // Serve sanitized content to legitimate bots\n            serveSanitizedContentToBot(httpRequest, httpResponse, chain);\n        } else if (botAnalysis.getRiskScore() > 7.0) {\n            // Block high-risk bots\n            blockSuspiciousBot(httpRequest, httpResponse);\n        } else {\n            // Apply standard XSS protection\n            applyStandardXssProtection(httpRequest, httpResponse, chain);\n        }\n    }\n    \n    private void serveSanitizedContentToBot(HttpServletRequest request, HttpServletResponse response, \n                                          FilterChain chain) throws IOException, ServletException {\n        \n        // Create a wrapper to capture and sanitize response content\n        SanitizedResponseWrapper wrappedResponse = new SanitizedResponseWrapper(response);\n        \n        // Process the request\n        chain.doFilter(request, wrappedResponse);\n        \n        // Get the original content\n        String content = wrappedResponse.getContent();\n        \n        // Sanitize content for bot consumption\n        String sanitizedContent = sanitizeContentForBots(content);\n        \n        // Write sanitized content\n        response.setContentLength(sanitizedContent.length());\n        response.getWriter().write(sanitizedContent);\n        \n        // Add bot-specific headers\n        response.setHeader(\"X-Content-Served-To\", \"legitimate-bot\");\n        response.setHeader(\"X-Content-Sanitized\", \"true\");\n    }\n    \n    private String sanitizeContentForBots(String content) {\n        // Remove all potentially dangerous content for bots\n        String sanitized = content;\n        \n        // Remove script tags\n        sanitized = sanitized.replaceAll(\"(?i)<script[^>]*>.*?</script>\", \"\");\n        \n        // Remove event handlers\n        sanitized = sanitized.replaceAll(\"(?i)on\\w+\\s*=\\s*[\\\"'][^\\\"']*[\\\"']\", \"\");\n        sanitized = sanitized.replaceAll(\"(?i)on\\w+\\s*=\\s*[^\\s>]+\", \"\");\n        \n        // Remove JavaScript protocols\n        sanitized = sanitized.replaceAll(\"(?i)javascript:\", \"\");\n        sanitized = sanitized.replaceAll(\"(?i)vbscript:\", \"\");\n        sanitized = sanitized.replaceAll(\"(?i)data:text/html\", \"\");\n        \n        // Remove meta refresh tags that might be used for redirects\n        sanitized = sanitized.replaceAll(\"(?i)<meta[^>]*http-equiv[^>]*refresh[^>]*>\", \"\");\n        \n        return sanitized;\n    }\n    \n    private void blockSuspiciousBot(HttpServletRequest request, HttpServletResponse response) \n            throws IOException {\n        \n        logger.warn(\"Blocking suspicious bot: {} from {}\", \n                   request.getHeader(\"User-Agent\"), getClientIpAddress(request));\n        \n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        response.getWriter().write(\"Access denied\");\n        response.setHeader(\"X-Blocked-Reason\", \"suspicious-bot\");\n    }\n}\n\n// ==========================\n// SECURE ROBOTS.TXT CONFIGURATION\n// ==========================\n@Configuration\npublic class RobotsTxtConfig {\n    \n    @Bean\n    public WebMvcConfigurer webMvcConfigurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void addResourceHandlers(ResourceHandlerRegistry registry) {\n                registry.addResourceHandler(\"/robots.txt\")\n                    .addResourceLocations(\"classpath:/static/\")\n                    .setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS));\n            }\n        };\n    }\n}\n\n/* robots.txt content */\n/*\nUser-agent: *\nDisallow: /admin/\nDisallow: /api/\nDisallow: /user/\nDisallow: /profile/\nDisallow: /settings/\nDisallow: /search*\nDisallow: /*?*\nDisallow: /*.json$\nDisallow: /*.xml$\n\n# Allow legitimate bots to crawl specific paths\nUser-agent: Googlebot\nAllow: /public/\nAllow: /blog/\nAllow: /articles/\n\nUser-agent: Bingbot\nAllow: /public/\nAllow: /blog/\nAllow: /articles/\n\n# Block suspicious crawlers\nUser-agent: *\nDisallow: /\n\nCrawl-delay: 1\nSitemap: https://yourdomain.com/sitemap.xml\n*/\n\n// ==========================\n// CONTENT SECURITY FOR SPIDERS\n// ==========================\n@Service\npublic class SpiderContentSecurityService {\n    \n    public String prepareContentForSpider(String originalContent, String contentType) {\n        switch (contentType.toLowerCase()) {\n            case \"text/html\":\n                return prepareHtmlContent(originalContent);\n            case \"application/json\":\n                return prepareJsonContent(originalContent);\n            case \"text/xml\":\n            case \"application/xml\":\n                return prepareXmlContent(originalContent);\n            default:\n                return originalContent;\n        }\n    }\n    \n    private String prepareHtmlContent(String html) {\n        // Parse HTML and remove dangerous elements\n        Document doc = Jsoup.parse(html);\n        \n        // Remove all script tags\n        doc.select(\"script\").remove();\n        \n        // Remove elements with event handlers\n        doc.select(\"*[on\\\\w+]\").removeAttr(\"onclick\")\n                          .removeAttr(\"onload\")\n                          .removeAttr(\"onerror\")\n                          .removeAttr(\"onmouseover\")\n                          .removeAttr(\"onfocus\");\n        \n        // Remove dangerous protocols\n        doc.select(\"a[href^=javascript], a[href^=vbscript], a[href^=data]\").remove();\n        \n        // Add noindex to sensitive content\n        doc.select(\".sensitive\").attr(\"rel\", \"noindex\");\n        \n        return doc.html();\n    }\n    \n    private String prepareJsonContent(String json) {\n        try {\n            // Parse and sanitize JSON\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode rootNode = mapper.readTree(json);\n            \n            // Remove potentially dangerous fields\n            if (rootNode.isObject()) {\n                ObjectNode objNode = (ObjectNode) rootNode;\n                objNode.remove(\"script\");\n                objNode.remove(\"eval\");\n                objNode.remove(\"dangerous\");\n            }\n            \n            return mapper.writeValueAsString(rootNode);\n        } catch (Exception e) {\n            logger.error(\"Error sanitizing JSON content: {}\", e.getMessage());\n            return \"{}\";\n        }\n    }\n    \n    private String prepareXmlContent(String xml) {\n        // Parse XML and remove dangerous elements\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xml)));\n            \n            // Remove script elements\n            NodeList scriptNodes = doc.getElementsByTagName(\"script\");\n            for (int i = scriptNodes.getLength() - 1; i >= 0; i--) {\n                Node scriptNode = scriptNodes.item(i);\n                scriptNode.getParentNode().removeChild(scriptNode);\n            }\n            \n            // Convert back to string\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            StringWriter writer = new StringWriter();\n            transformer.transform(new DOMSource(doc), new StreamResult(writer));\n            \n            return writer.toString();\n        } catch (Exception e) {\n            logger.error(\"Error sanitizing XML content: {}\", e.getMessage());\n            return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><root></root>\";\n        }\n    }\n}\n\n// ==========================\n// MONITORING AND ANALYTICS\n// ==========================\n@Component\npublic class BotMonitoringService {\n    private final MeterRegistry meterRegistry;\n    \n    @EventListener\n    public void handleBotAccess(BotAccessEvent event) {\n        String botType = event.getBotType();\n        String endpoint = event.getEndpoint();\n        \n        // Record metrics\n        Counter.builder(\"bot.accesses\")\n            .tag(\"type\", botType)\n            .tag(\"endpoint\", endpoint)\n            .register(meterRegistry)\n            .increment();\n        \n        // Check for unusual patterns\n        if (isUnusualBotActivity(event)) {\n            logger.warn(\"Unusual bot activity: {} accessing {}\", botType, endpoint);\n            notifySecurityTeam(event);\n        }\n    }\n    \n    private boolean isUnusualBotActivity(BotAccessEvent event) {\n        // Legitimate bot accessing admin endpoints\n        if (event.isLegitimateBot() && event.getEndpoint().contains(\"/admin\")) {\n            return true;\n        }\n        \n        // High request rate from a single bot\n        if (event.getRequestsPerMinute() > 60) {\n            return true;\n        }\n        \n        // Bot accessing unusual content types\n        if (event.getContentType() != null && \n            (event.getContentType().contains(\"application/json\") || \n             event.getContentType().contains(\"application/xml\"))) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n\n// ==========================\n// DATABASE SCHEMA FOR BOT TRACKING\n// ==========================\n/*\n-- Bot access tracking table\nCREATE TABLE bot_access_log (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_agent TEXT,\n    ip_address VARCHAR(45),\n    bot_type VARCHAR(50), -- legitimate, suspicious, malicious\n    endpoint VARCHAR(500),\n    method VARCHAR(10),\n    status_code INT,\n    response_size BIGINT,\n    risk_score DECIMAL(5,2),\n    blocked BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_bot_type (bot_type, created_at),\n    INDEX idx_ip_address (ip_address, created_at),\n    INDEX idx_endpoint (endpoint, created_at)\n);\n\n-- Spider XSS attempts\nCREATE TABLE spider_xss_attempts (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_agent TEXT,\n    ip_address VARCHAR(45),\n    target_url VARCHAR(1000),\n    payload_snippet TEXT,\n    detected_patterns JSON,\n    content_type VARCHAR(100),\n    blocked BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_date (created_at),\n    INDEX idx_ip_address (ip_address)\n);\n*/"
      }
    ]
  },
  {
    "pluginId": 40018,
    "title": "SQL Injection",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "SQL Injection occurs when untrusted data is used to construct SQL queries without proper validation or parameterization. Attackers can manipulate SQL queries to bypass authentication, access unauthorized data, modify or delete database content, and in some cases execute system commands.",
    "simplified_description": "Your application has a critical security flaw that allows attackers to directly control your database queries. This is like giving strangers the ability to speak fluent 'database language' to your database - they can trick it into revealing all your sensitive information, modify your data, or even take complete control of your database. Attackers can steal passwords, user data, financial information, or delete your entire database.",
    "solution": "Use parameterized queries (prepared statements) for all database operations, implement proper input validation, and employ ORM frameworks that provide built-in SQL injection protection.",
    "simplified_solution": "Replace all raw SQL queries with parameterized statements or use secure database frameworks, validate all user input before using it in database operations, implement proper error handling that doesn't reveal database information, and use database access controls with minimal privileges.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Database Access with Parameterized Queries",
        "solution_description": "This solution demonstrates comprehensive SQL injection prevention through parameterized queries, input validation, secure database connection handling, and proper error management across multiple programming languages and database systems.",
        "affected_files": "Database connection files, API endpoints, authentication systems, search functionality, data access layers, ORM configurations",
        "code": "// ============= NODE.JS/EXPRESS - SECURE USER AUTHENTICATION =============\nconst express = require('express');\nconst mysql = require('mysql2/promise');\nconst bcrypt = require('bcrypt');\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\nconst validator = require('validator');\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(express.json());\n\n// Rate limiting for authentication endpoints\nconst authLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 5, // limit each IP to 5 requests per windowMs\n    message: 'Too many authentication attempts, please try again later.'\n});\n\n// Secure database connection with connection pooling\nconst pool = mysql.createPool({\n    host: process.env.DB_HOST,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_NAME,\n    waitForConnections: true,\n    connectionLimit: 10,\n    queueLimit: 0,\n    // Secure connection settings\n    ssl: {\n        rejectUnauthorized: true\n    },\n    charset: 'utf8mb4'\n});\n\n// Input validation class\nclass UserValidator {\n    static validateEmail(email) {\n        if (!email || typeof email !== 'string') {\n            throw new Error('Email is required');\n        }\n        \n        if (!validator.isEmail(email)) {\n            throw new Error('Invalid email format');\n        }\n        \n        if (email.length > 255) {\n            throw new Error('Email too long');\n        }\n        \n        return validator.normalizeEmail(email).toLowerCase();\n    }\n    \n    static validatePassword(password) {\n        if (!password || typeof password !== 'string') {\n            throw new Error('Password is required');\n        }\n        \n        if (password.length < 8) {\n            throw new Error('Password must be at least 8 characters');\n        }\n        \n        if (password.length > 128) {\n            throw new Error('Password too long');\n        }\n        \n        // Check for common weak patterns\n        if (/^(password|123456|qwerty|admin|letmein)/i.test(password)) {\n            throw new Error('Password is too common');\n        }\n        \n        return password;\n    }\n    \n    static validateUsername(username) {\n        if (!username || typeof username !== 'string') {\n            throw new Error('Username is required');\n        }\n        \n        if (!/^[a-zA-Z0-9_-]+$/.test(username)) {\n            throw new Error('Username can only contain letters, numbers, underscores, and hyphens');\n        }\n        \n        if (username.length < 3 || username.length > 50) {\n            throw new Error('Username must be between 3 and 50 characters');\n        }\n        \n        return username.toLowerCase();\n    }\n}\n\n// User model with secure database operations\nclass UserModel {\n    static async findByEmail(email) {\n        const connection = await pool.getConnection();\n        try {\n            // SECURE: Parameterized query prevents SQL injection\n            const [rows] = await connection.execute(\n                'SELECT id, email, password_hash, username, created_at, last_login FROM users WHERE email = ?',\n                [email]\n            );\n            return rows[0] || null;\n        } finally {\n            connection.release();\n        }\n    }\n    \n    static async findByUsername(username) {\n        const connection = await pool.getConnection();\n        try {\n            // SECURE: Parameterized query\n            const [rows] = await connection.execute(\n                'SELECT id, email, username FROM users WHERE username = ?',\n                [username]\n            );\n            return rows[0] || null;\n        } finally {\n            connection.release();\n        }\n    }\n    \n    static async create(userData) {\n        const connection = await pool.getConnection();\n        try {\n            // Hash password\n            const passwordHash = await bcrypt.hash(userData.password, 12);\n            \n            // SECURE: Parameterized query for user creation\n            const [result] = await connection.execute(\n                `INSERT INTO users (email, password_hash, username, created_at) \n                 VALUES (?, ?, ?, NOW())`,\n                [userData.email, passwordHash, userData.username]\n            );\n            \n            return result.insertId;\n        } finally {\n            connection.release();\n        }\n    }\n    \n    static async updateLastLogin(userId) {\n        const connection = await pool.getConnection();\n        try {\n            // SECURE: Parameterized query\n            await connection.execute(\n                'UPDATE users SET last_login = NOW() WHERE id = ?',\n                [userId]\n            );\n        } finally {\n            connection.release();\n        }\n    }\n    \n    static async searchUsers(searchTerm, limit = 10, offset = 0) {\n        const connection = await pool.getConnection();\n        try {\n            // SECURE: Parameterized query for search\n            const [rows] = await connection.execute(\n                `SELECT id, username, email, created_at \n                 FROM users \n                 WHERE username LIKE ? OR email LIKE ?\n                 ORDER BY username \n                 LIMIT ? OFFSET ?`,\n                [`%${searchTerm}%`, `%${searchTerm}%`, limit, offset]\n            );\n            return rows;\n        } finally {\n            connection.release();\n        }\n    }\n}\n\n// Authentication service\nclass AuthService {\n    static async login(email, password) {\n        try {\n            // Validate input\n            const cleanEmail = UserValidator.validateEmail(email);\n            const cleanPassword = UserValidator.validatePassword(password);\n            \n            // Find user by email\n            const user = await UserModel.findByEmail(cleanEmail);\n            \n            if (!user) {\n                throw new Error('Invalid credentials');\n            }\n            \n            // Verify password\n            const isValidPassword = await bcrypt.compare(cleanPassword, user.password_hash);\n            \n            if (!isValidPassword) {\n                throw new Error('Invalid credentials');\n            }\n            \n            // Update last login\n            await UserModel.updateLastLogin(user.id);\n            \n            // Return user data (excluding password)\n            return {\n                id: user.id,\n                email: user.email,\n                username: user.username,\n                lastLogin: user.last_login\n            };\n            \n        } catch (error) {\n            // Log security events\n            console.warn(`Login attempt failed for email: ${email}`, error.message);\n            throw error;\n        }\n    }\n    \n    static async register(userData) {\n        try {\n            // Validate input\n            const cleanEmail = UserValidator.validateEmail(userData.email);\n            const cleanPassword = UserValidator.validatePassword(userData.password);\n            const cleanUsername = UserValidator.validateUsername(userData.username);\n            \n            // Check if user already exists\n            const existingUser = await UserModel.findByEmail(cleanEmail);\n            if (existingUser) {\n                throw new Error('Email already registered');\n            }\n            \n            const existingUsername = await UserModel.findByUsername(cleanUsername);\n            if (existingUsername) {\n                throw new Error('Username already taken');\n            }\n            \n            // Create user\n            const userId = await UserModel.create({\n                email: cleanEmail,\n                password: cleanPassword,\n                username: cleanUsername\n            });\n            \n            return { id: userId };\n            \n        } catch (error) {\n            console.warn('Registration failed:', error.message);\n            throw error;\n        }\n    }\n}\n\n// Secure API endpoints\napp.post('/api/auth/login', authLimiter, async (req, res) => {\n    try {\n        const { email, password } = req.body;\n        \n        const user = await AuthService.login(email, password);\n        \n        // Generate JWT token (implementation not shown)\n        const token = generateJWT(user);\n        \n        res.json({\n            message: 'Login successful',\n            user: {\n                id: user.id,\n                email: user.email,\n                username: user.username\n            },\n            token: token\n        });\n        \n    } catch (error) {\n        res.status(401).json({ \n            error: 'Authentication failed',\n            message: error.message \n        });\n    }\n});\n\napp.post('/api/auth/register', authLimiter, async (req, res) => {\n    try {\n        const { email, password, username } = req.body;\n        \n        const result = await AuthService.register({ email, password, username });\n        \n        res.status(201).json({\n            message: 'Registration successful',\n            userId: result.id\n        });\n        \n    } catch (error) {\n        res.status(400).json({ \n            error: 'Registration failed',\n            message: error.message \n        });\n    }\n});\n\n// Secure search endpoint\napp.get('/api/users/search', async (req, res) => {\n    try {\n        const { q: searchTerm, limit = 10, offset = 0 } = req.query;\n        \n        // Validate search term\n        if (!searchTerm || typeof searchTerm !== 'string') {\n            return res.status(400).json({ error: 'Search term is required' });\n        }\n        \n        if (searchTerm.length > 100) {\n            return res.status(400).json({ error: 'Search term too long' });\n        }\n        \n        // Sanitize search term (remove potential injection patterns)\n        const cleanSearchTerm = validator.escape(searchTerm.substring(0, 100));\n        \n        const users = await UserModel.searchUsers(\n            cleanSearchTerm, \n            parseInt(limit), \n            parseInt(offset)\n        );\n        \n        res.json({ users });\n        \n    } catch (error) {\n        console.error('Search error:', error);\n        res.status(500).json({ error: 'Search failed' });\n    }\n});\n\n// ============= PYTHON/DJANGO SOLUTION =============\nfrom django.db import models, connection\nfrom django.contrib.auth.models import AbstractUser\nfrom django.core.validators import RegexValidator, EmailValidator\nfrom django.core.exceptions import ValidationError\nfrom django.contrib.auth.password_validation import validate_password\nimport re\nimport bcrypt\n\n# Models\nclass User(AbstractUser):\n    email = models.EmailField(unique=True)\n    username = models.CharField(\n        max_length=50, \n        unique=True,\n        validators=[\n            RegexValidator(\n                r'^[a-zA-Z0-9_-]+$',\n                'Username can only contain letters, numbers, underscores, and hyphens'\n            )\n        ]\n    )\n    last_login = models.DateTimeField(null=True, blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    USERNAME_FIELD = 'email'\n    REQUIRED_FIELDS = ['username']\n    \n    class Meta:\n        db_table = 'users'\n\n# Services\nclass UserService:\n    @staticmethod\n    def create_user(email, password, username):\n        # Validate email\n        if not email or not EmailValidator()(email):\n            raise ValidationError('Valid email is required')\n        \n        # Validate username\n        if not username or len(username) < 3 or len(username) > 50:\n            raise ValidationError('Username must be between 3 and 50 characters')\n        \n        # Validate password\n        validate_password(password)\n        \n        # Check for existing user\n        if User.objects.filter(email=email).exists():\n            raise ValidationError('Email already registered')\n        \n        if User.objects.filter(username=username).exists():\n            raise ValidationError('Username already taken')\n        \n        # Create user\n        user = User.objects.create_user(\n            email=email,\n            password=password,\n            username=username\n        )\n        \n        return user\n    \n    @staticmethod\n    def authenticate_user(email, password):\n        try:\n            user = User.objects.get(email=email)\n            \n            if user.check_password(password):\n                user.last_login = timezone.now()\n                user.save(update_fields=['last_login'])\n                return user\n            \n        except User.DoesNotExist:\n            pass\n        \n        return None\n    \n    @staticmethod\n    def search_users(search_term, limit=10, offset=0):\n        # SECURE: Django ORM automatically uses parameterized queries\n        users = User.objects.filter(\n            models.Q(username__icontains=search_term) |\n            models.Q(email__icontains=search_term)\n        ).order_by('username')[offset:offset+limit]\n        \n        return users.annotate(\n            email_hash=models.functions.Concat(\n                models.Value(''),\n                models.F('email')\n            )\n        ).values('id', 'username', 'email', 'created_at')\n\n# Views\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.http import require_http_methods\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom rest_framework_simplejwt.tokens import RefreshToken\n\n@method_decorator(csrf_protect, name='dispatch')\nclass AuthView(View):\n    def post(self, request, action):\n        try:\n            if action == 'login':\n                return self.login(request)\n            elif action == 'register':\n                return self.register(request)\n            else:\n                return JsonResponse({'error': 'Invalid action'}, status=400)\n                \n        except ValidationError as e:\n            return JsonResponse({'error': str(e)}, status=400)\n        except Exception as e:\n            return JsonResponse({'error': 'Internal server error'}, status=500)\n    \n    def login(self, request):\n        email = request.POST.get('email', '').strip().lower()\n        password = request.POST.get('password', '')\n        \n        user = UserService.authenticate_user(email, password)\n        \n        if not user:\n            return JsonResponse({'error': 'Invalid credentials'}, status=401)\n        \n        # Generate JWT token\n        refresh = RefreshToken.for_user(user)\n        \n        return JsonResponse({\n            'message': 'Login successful',\n            'user': {\n                'id': user.id,\n                'email': user.email,\n                'username': user.username\n            },\n            'token': str(refresh.access_token),\n            'refresh': str(refresh)\n        })\n    \n    def register(self, request):\n        email = request.POST.get('email', '').strip().lower()\n        password = request.POST.get('password', '')\n        username = request.POST.get('username', '').strip().lower()\n        \n        user = UserService.create_user(email, password, username)\n        \n        return JsonResponse({\n            'message': 'Registration successful',\n            'user_id': user.id\n        }, status=201)\n\n# ============= PHP SOLUTION =============\n<?php\n// Secure user authentication system with SQL injection prevention\n\nclass Database {\n    private static $instance = null;\n    private $pdo;\n    \n    private function __construct() {\n        $dsn = sprintf(\n            'mysql:host=%s;dbname=%s;charset=utf8mb4',\n            getenv('DB_HOST'),\n            getenv('DB_NAME')\n        );\n        \n        $options = [\n            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,\n            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,\n            PDO::ATTR_EMULATE_PREPARES => false,\n            PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT => true\n        ];\n        \n        $this->pdo = new PDO($dsn, getenv('DB_USER'), getenv('DB_PASSWORD'), $options);\n    }\n    \n    public static function getInstance() {\n        if (self::$instance === null) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    \n    public function getConnection() {\n        return $this->pdo;\n    }\n}\n\nclass UserValidator {\n    public static function validateEmail($email) {\n        if (empty($email)) {\n            throw new InvalidArgumentException('Email is required');\n        }\n        \n        $email = filter_var(trim($email), FILTER_SANITIZE_EMAIL);\n        \n        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {\n            throw new InvalidArgumentException('Invalid email format');\n        }\n        \n        if (strlen($email) > 255) {\n            throw new InvalidArgumentException('Email too long');\n        }\n        \n        return strtolower($email);\n    }\n    \n    public static function validatePassword($password) {\n        if (empty($password)) {\n            throw new InvalidArgumentException('Password is required');\n        }\n        \n        if (strlen($password) < 8) {\n            throw new InvalidArgumentException('Password must be at least 8 characters');\n        }\n        \n        if (strlen($password) > 128) {\n            throw new InvalidArgumentException('Password too long');\n        }\n        \n        // Check for common weak passwords\n        $weakPasswords = ['password', '123456', 'qwerty', 'admin', 'letmein'];\n        if (in_array(strtolower($password), $weakPasswords)) {\n            throw new InvalidArgumentException('Password is too common');\n        }\n        \n        return $password;\n    }\n    \n    public static function validateUsername($username) {\n        if (empty($username)) {\n            throw new InvalidArgumentException('Username is required');\n        }\n        \n        $username = trim($username);\n        \n        if (!preg_match('/^[a-zA-Z0-9_-]+$/', $username)) {\n            throw new InvalidArgumentException('Username can only contain letters, numbers, underscores, and hyphens');\n        }\n        \n        if (strlen($username) < 3 || strlen($username) > 50) {\n            throw new InvalidArgumentException('Username must be between 3 and 50 characters');\n        }\n        \n        return strtolower($username);\n    }\n}\n\nclass UserModel {\n    private $pdo;\n    \n    public function __construct() {\n        $this->pdo = Database::getInstance()->getConnection();\n    }\n    \n    public function findByEmail($email) {\n        // SECURE: Parameterized query prevents SQL injection\n        $stmt = $this->pdo->prepare(\n            'SELECT id, email, password_hash, username, created_at, last_login FROM users WHERE email = ?'\n        );\n        $stmt->execute([$email]);\n        return $stmt->fetch();\n    }\n    \n    public function findByUsername($username) {\n        // SECURE: Parameterized query\n        $stmt = $this->pdo->prepare(\n            'SELECT id, email, username FROM users WHERE username = ?'\n        );\n        $stmt->execute([$username]);\n        return $stmt->fetch();\n    }\n    \n    public function create($userData) {\n        // Hash password\n        $passwordHash = password_hash($userData['password'], PASSWORD_ARGON2ID);\n        \n        // SECURE: Parameterized query for user creation\n        $stmt = $this->pdo->prepare(\n            'INSERT INTO users (email, password_hash, username, created_at) VALUES (?, ?, ?, NOW())'\n        );\n        \n        $stmt->execute([\n            $userData['email'],\n            $passwordHash,\n            $userData['username']\n        ]);\n        \n        return $this->pdo->lastInsertId();\n    }\n    \n    public function updateLastLogin($userId) {\n        // SECURE: Parameterized query\n        $stmt = $this->pdo->prepare(\n            'UPDATE users SET last_login = NOW() WHERE id = ?'\n        );\n        $stmt->execute([$userId]);\n    }\n    \n    public function searchUsers($searchTerm, $limit = 10, $offset = 0) {\n        // SECURE: Parameterized query for search\n        $stmt = $this->pdo->prepare(\n            'SELECT id, username, email, created_at \n             FROM users \n             WHERE username LIKE ? OR email LIKE ?\n             ORDER BY username \n             LIMIT ? OFFSET ?'\n        );\n        \n        $stmt->execute([\n            '%' . $searchTerm . '%',\n            '%' . $searchTerm . '%',\n            $limit,\n            $offset\n        ]);\n        \n        return $stmt->fetchAll();\n    }\n}\n\nclass AuthService {\n    private $userModel;\n    \n    public function __construct() {\n        $this->userModel = new UserModel();\n    }\n    \n    public function login($email, $password) {\n        try {\n            // Validate input\n            $cleanEmail = UserValidator::validateEmail($email);\n            $cleanPassword = UserValidator::validatePassword($password);\n            \n            // Find user\n            $user = $this->userModel->findByEmail($cleanEmail);\n            \n            if (!$user) {\n                throw new Exception('Invalid credentials');\n            }\n            \n            // Verify password\n            if (!password_verify($cleanPassword, $user['password_hash'])) {\n                throw new Exception('Invalid credentials');\n            }\n            \n            // Update last login\n            $this->userModel->updateLastLogin($user['id']);\n            \n            // Return user data (excluding password)\n            return [\n                'id' => $user['id'],\n                'email' => $user['email'],\n                'username' => $user['username'],\n                'last_login' => $user['last_login']\n            ];\n            \n        } catch (Exception $e) {\n            error_log(\"Login attempt failed for email: {$email} - \" . $e->getMessage());\n            throw $e;\n        }\n    }\n    \n    public function register($userData) {\n        try {\n            // Validate input\n            $cleanEmail = UserValidator::validateEmail($userData['email']);\n            $cleanPassword = UserValidator::validatePassword($userData['password']);\n            $cleanUsername = UserValidator::validateUsername($userData['username']);\n            \n            // Check if user already exists\n            if ($this->userModel->findByEmail($cleanEmail)) {\n                throw new Exception('Email already registered');\n            }\n            \n            if ($this->userModel->findByUsername($cleanUsername)) {\n                throw new Exception('Username already taken');\n            }\n            \n            // Create user\n            $userId = $this->userModel->create([\n                'email' => $cleanEmail,\n                'password' => $cleanPassword,\n                'username' => $cleanUsername\n            ]);\n            \n            return ['id' => $userId];\n            \n        } catch (Exception $e) {\n            error_log('Registration failed: ' . $e->getMessage());\n            throw $e;\n        }\n    }\n}\n\n// API endpoint implementation\nheader('Content-Type: application/json');\n\ntry {\n    $authService = new AuthService();\n    \n    if ($_SERVER['REQUEST_METHOD'] === 'POST') {\n        $action = $_GET['action'] ?? '';\n        \n        switch ($action) {\n            case 'login':\n                $input = json_decode(file_get_contents('php://input'), true);\n                $user = $authService->login($input['email'], $input['password']);\n                \n                // Generate JWT token (implementation not shown)\n                $token = generateJWT($user);\n                \n                echo json_encode([\n                    'message' => 'Login successful',\n                    'user' => [\n                        'id' => $user['id'],\n                        'email' => $user['email'],\n                        'username' => $user['username']\n                    ],\n                    'token' => $token\n                ]);\n                break;\n                \n            case 'register':\n                $input = json_decode(file_get_contents('php://input'), true);\n                $result = $authService->register([\n                    'email' => $input['email'],\n                    'password' => $input['password'],\n                    'username' => $input['username']\n                ]);\n                \n                echo json_encode([\n                    'message' => 'Registration successful',\n                    'user_id' => $result['id']\n                ], JSON_UNESCAPED_UNICODE);\n                break;\n                \n            default:\n                throw new Exception('Invalid action');\n        }\n    } elseif ($_SERVER['REQUEST_METHOD'] === 'GET' && $_GET['action'] === 'search') {\n        $userModel = new UserModel();\n        \n        $searchTerm = $_GET['q'] ?? '';\n        $limit = min((int)($_GET['limit'] ?? 10), 100);\n        $offset = max((int)($_GET['offset'] ?? 0), 0);\n        \n        if (empty($searchTerm)) {\n            throw new Exception('Search term is required');\n        }\n        \n        if (strlen($searchTerm) > 100) {\n            throw new Exception('Search term too long');\n        }\n        \n        $users = $userModel->searchUsers($searchTerm, $limit, $offset);\n        \n        echo json_encode(['users' => $users]);\n    }\n    \n} catch (Exception $e) {\n    $statusCode = strpos($e->getMessage(), 'Invalid') !== false ? 400 : 500;\n    http_response_code($statusCode);\n    \n    echo json_encode([\n        'error' => $e->getMessage()\n    ]);\n}\n?>\n\n// ============= SECURITY BEST PRACTICES AND MONITORING =============\n\n/*\nSQL INJECTION PREVENTION STRATEGIES:\n\n1. ALWAYS USE PARAMETERIZED QUERIES:\n   - Never concatenate user input into SQL queries\n   - Use prepared statements for all database operations\n   - Let the database driver handle proper escaping\n\n2. INPUT VALIDATION:\n   - Validate all user input before database operations\n   - Use whitelist validation (allow only known good input)\n   - Implement length limits and character restrictions\n   - Validate data types and formats\n\n3. ORM FRAMEWORKS:\n   - Use Django ORM, SQLAlchemy, Entity Framework, etc.\n   - ORMs automatically use parameterized queries\n   - Provide additional security layers\n\n4. DATABASE SECURITY:\n   - Use least privilege principle for database users\n   - Separate read/write permissions\n   - Regular database access audits\n   - Enable database query logging\n\n5. ERROR HANDLING:\n   - Don't expose database errors to users\n   - Use generic error messages\n   - Log detailed errors for administrators\n   - Implement proper exception handling\n\n6. MONITORING AND DETECTION:\n   - Monitor for unusual query patterns\n   - Log all database operations\n   - Implement rate limiting for sensitive operations\n   - Use Web Application Firewalls (WAF)\n\nIMPLEMENTATION PRIORITY:\n1. Parameterized queries (CRITICAL)\n2. Input validation (CRITICAL)\n3. Error handling (HIGH)\n4. Database access controls (HIGH)\n5. Monitoring and logging (MEDIUM)\n6. WAF implementation (LOW)\n\nDATABASE-SPECIFIC CONSIDERATIONS:\n- MySQL: Use mysqli or PDO with prepared statements\n- PostgreSQL: Use pg_query_params() or PDO\n- SQL Server: Use SQLSRV with parameter binding\n- Oracle: Use OCI8 with bind variables\n- SQLite: Use SQLite3 with prepared statements\n*/"
      }
    ]
  },
  {
    "pluginId": 40019,
    "title": "SQL Injection - MySQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "MySQL SQL Injection occurs when untrusted user input is directly concatenated into MySQL SQL queries without proper parameterization or sanitization. Attackers can manipulate MySQL-specific syntax including UNION queries, comment sequences (--, /* */), MySQL functions like LOAD_FILE(), INTO OUTFILE, information_schema queries, and bypass authentication techniques to extract sensitive data, modify database content, or achieve remote code execution through MySQL's file system operations.",
    "simplified_description": "Your application has a critical MySQL database security flaw that allows attackers to speak directly to your MySQL database in its native language. This is like giving strangers a master key to your filing cabinet - they can read all your sensitive customer data, steal passwords, modify business records, and even use MySQL's special file operations to access files on your server or take complete control of your database systems.",
    "solution": "Implement parameterized queries using prepared statements for all MySQL operations, use ORM frameworks with MySQL-specific protections, enable MySQL strict mode, validate all inputs, implement least privilege database access, and use MySQL-specific security features.",
    "simplified_solution": "Replace all string concatenation in SQL queries with prepared statements using bind parameters. Use reputable ORM frameworks like Hibernate, Entity Framework, or SQLAlchemy. Enable MySQL's strict SQL mode and NO_AUTO_CREATE_USER. Validate all inputs with type checking and length limits. Create dedicated database users with minimal required permissions only. Use stored procedures for complex operations and keep MySQL updated with latest security patches.",
    "references": [
      {
        "name": "OWASP SQL Injection Prevention Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "MySQL Security Guidelines",
        "url": "https://dev.mysql.com/doc/refman/8.0/en/general-security-issues.html"
      },
      {
        "name": "CWE-89: SQL Injection",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      },
      {
        "name": "OWASP Top Ten A03:2021 - Injection",
        "url": "https://owasp.org/Top10/A03_2021-Injection/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "PHP MySQL Implementation",
        "solution_description": "Secure MySQL database operations using PDO with prepared statements, MySQL-specific configuration, and comprehensive input validation. This solution demonstrates proper parameter binding, error handling, connection security, and MySQL 8.0+ authentication features including SSL/TLS enforcement and prepared statement caching.",
        "affected_files": "Database connection scripts (db.php, database.php), user authentication files (login.php, auth.php), data retrieval scripts (search.php, reports.php), API endpoints (api/*.php), configuration files (config.php)",
        "code": "<?php\n// ============================================\n// SECURE MYSQL DATABASE CONNECTION CLASS\n// ============================================\n\nclass SecureMySQLConnection {\n    private $pdo;\n    private $stmt;\n    \n    // MySQL 8.0+ Secure Connection Configuration\n    private $config = [\n        'host' => 'localhost',\n        'port' => 3306,\n        'dbname' => 'secure_app',\n        'charset' => 'utf8mb4',\n        'username' => 'app_user', // Least privilege user\n        'password' => 'secure_password',\n        'options' => [\n            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,\n            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,\n            PDO::ATTR_EMULATE_PREPARES => false, // Real prepared statements\n            PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT => true,\n            PDO::MYSQL_ATTR_MULTI_STATEMENTS => false, // Prevent SQL stacking\n            PDO::MYSQL_ATTR_INIT_COMMAND => \"SET \n                sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO',\n                session sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO'\"\n        ]\n    ];\n    \n    public function __construct() {\n        $this->connect();\n    }\n    \n    private function connect() {\n        try {\n            // Data Source Name with SSL/TLS enforcement\n            $dsn = sprintf(\n                'mysql:host=%s;port=%d;dbname=%s;charset=%s',\n                $this->config['host'],\n                $this->config['port'],\n                $this->config['dbname'],\n                $this->config['charset']\n            );\n            \n            $this->pdo = new PDO($dsn, $this->config['username'], $this->config['password'], $this->config['options']);\n            \n            // Enable MySQL strict security mode\n            $this->pdo->exec(\"\n                SET SESSION \n                sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_DIVISION',\n                innodb_strict_mode = ON\n            \");\n            \n        } catch (PDOException $e) {\n            // Log error without exposing connection details\n            error_log('Database connection failed: ' . $e->getMessage());\n            throw new Exception('Database service unavailable');\n        }\n    }\n    \n    // Secure Query Execution with Parameter Binding\n    public function executeQuery($sql, $params = []) {\n        try {\n            $this->stmt = $this->pdo->prepare($sql);\n            \n            // Bind parameters with explicit type specification\n            foreach ($params as $key => $value) {\n                $paramType = $this->getParamType($value);\n                if (is_int($key)) {\n                    // Positional parameters (1-based)\n                    $this->stmt->bindValue($key + 1, $value, $paramType);\n                } else {\n                    // Named parameters\n                    $this->stmt->bindValue(':' . $key, $value, $paramType);\n                }\n            }\n            \n            $this->stmt->execute();\n            return $this->stmt;\n            \n        } catch (PDOException $e) {\n            error_log('Query execution failed: ' . $e->getMessage());\n            throw new Exception('Database operation failed');\n        }\n    }\n    \n    // Input validation helper\n    public function validateInput($input, $type, $maxLength = null) {\n        if ($input === null) return null;\n        \n        // Type-specific validation\n        switch ($type) {\n            case 'int':\n                return filter_var($input, FILTER_VALIDATE_INT);\n            case 'email':\n                return filter_var($input, FILTER_VALIDATE_EMAIL);\n            case 'string':\n                $clean = trim($input);\n                if ($maxLength && strlen($clean) > $maxLength) {\n                    throw new InvalidArgumentException('Input too long');\n                }\n                // Remove potential SQL injection patterns\n                return preg_replace('/[\\x00-\\x1F\\x7F\\\\]/', '', $clean);\n            default:\n                throw new InvalidArgumentException('Unknown validation type');\n        }\n    }\n    \n    private function getParamType($value) {\n        if (is_int($value)) return PDO::PARAM_INT;\n        if (is_bool($value)) return PDO::PARAM_BOOL;\n        if (is_null($value)) return PDO::PARAM_NULL;\n        return PDO::PARAM_STR;\n    }\n}\n\n// ============================================\n// SECURE USER AUTHENTICATION EXAMPLE\n// ============================================\n\nclass SecureUserService {\n    private $db;\n    \n    public function __construct(SecureMySQLConnection $db) {\n        $this->db = $db;\n    }\n    \n    // Secure user login with prepared statements\n    public function authenticateUser($username, $password) {\n        // Input validation\n        $username = $this->db->validateInput($username, 'string', 50);\n        $password = $this->db->validateInput($password, 'string', 255);\n        \n        if (!$username || !$password) {\n            throw new InvalidArgumentException('Invalid credentials');\n        }\n        \n        // Secure query with prepared statement\n        $sql = \"\n            SELECT id, username, password_hash, email, role, last_login, failed_attempts\n            FROM users \n            WHERE username = :username \n            AND is_active = 1 \n            AND locked_until < NOW()\n            LIMIT 1\n        \";\n        \n        try {\n            $stmt = $this->db->executeQuery($sql, ['username' => $username]);\n            $user = $stmt->fetch();\n            \n            if (!$user) {\n                $this->recordFailedLogin($username);\n                return false;\n            }\n            \n            // Verify password securely\n            if (!password_verify($password, $user['password_hash'])) {\n                $this->recordFailedLogin($username);\n                $this->incrementFailedAttempts($user['id']);\n                return false;\n            }\n            \n            // Reset failed attempts on successful login\n            $this->resetFailedAttempts($user['id']);\n            $this->updateLastLogin($user['id']);\n            \n            // Remove sensitive data from returned user object\n            unset($user['password_hash']);\n            return $user;\n            \n        } catch (Exception $e) {\n            error_log('Authentication failed for user: ' . $username);\n            return false;\n        }\n    }\n    \n    // Secure user registration\n    public function createUser($userData) {\n        // Validate all inputs\n        $username = $this->db->validateInput($userData['username'], 'string', 50);\n        $email = $this->db->validateInput($userData['email'], 'email');\n        $password = $userData['password'];\n        \n        // Additional validation\n        if (strlen($password) < 8) {\n            throw new InvalidArgumentException('Password too short');\n        }\n        \n        // Check if user exists\n        if ($this->userExists($username, $email)) {\n            throw new InvalidArgumentException('User already exists');\n        }\n        \n        // Hash password securely\n        $passwordHash = password_hash($password, PASSWORD_ARGON2ID, [\n            'memory_cost' => 65536,\n            'time_cost' => 4,\n            'threads' => 3\n        ]);\n        \n        // Insert user with prepared statement\n        $sql = \"\n            INSERT INTO users (username, email, password_hash, created_at, is_active) \n            VALUES (:username, :email, :password_hash, NOW(), 1)\n        \";\n        \n        $params = [\n            'username' => $username,\n            'email' => $email,\n            'password_hash' => $passwordHash\n        ];\n        \n        try {\n            $this->db->executeQuery($sql, $params);\n            return $this->db->pdo->lastInsertId();\n        } catch (PDOException $e) {\n            error_log('User creation failed: ' . $e->getMessage());\n            throw new Exception('Unable to create user');\n        }\n    }\n    \n    // Secure data retrieval example\n    public function getUserOrders($userId, $limit = 10, $offset = 0) {\n        $userId = $this->db->validateInput($userId, 'int');\n        $limit = $this->db->validateInput($limit, 'int');\n        $offset = $this->db->validateInput($offset, 'int');\n        \n        // Prevent unauthorized access\n        if (!$userId || $limit > 100 || $limit < 1) {\n            throw new InvalidArgumentException('Invalid parameters');\n        }\n        \n        $sql = \"\n            SELECT o.id, o.order_date, o.total_amount, o.status,\n                   JSON_ARRAYAGG(\n                       JSON_OBJECT(\n                           'product_name', p.name,\n                           'quantity', oi.quantity,\n                           'price', oi.price\n                       )\n                   ) as items\n            FROM orders o\n            JOIN order_items oi ON o.id = oi.order_id\n            JOIN products p ON oi.product_id = p.id\n            WHERE o.user_id = :user_id\n            GROUP BY o.id\n            ORDER BY o.order_date DESC\n            LIMIT :limit OFFSET :offset\n        \";\n        \n        $stmt = $this->db->executeQuery($sql, [\n            'user_id' => $userId,\n            'limit' => $limit,\n            'offset' => $offset\n        ]);\n        \n        return $stmt->fetchAll();\n    }\n    \n    private function userExists($username, $email) {\n        $sql = \"\n            SELECT 1 FROM users \n            WHERE username = :username OR email = :email \n            LIMIT 1\n        \";\n        \n        $stmt = $this->db->executeQuery($sql, [\n            'username' => $username,\n            'email' => $email\n        ]);\n        \n        return (bool)$stmt->fetch();\n    }\n}\n\n// ============================================\n// USAGE EXAMPLES\n// ============================================\n\ntry {\n    // Initialize secure database connection\n    $db = new SecureMySQLConnection();\n    $userService = new SecureUserService($db);\n    \n    // Secure user authentication\n    if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['login'])) {\n        $username = $_POST['username'] ?? '';\n        $password = $_POST['password'] ?? '';\n        \n        $user = $userService->authenticateUser($username, $password);\n        \n        if ($user) {\n            // Start secure session\n            session_start([\n                'cookie_httponly' => true,\n                'cookie_secure' => true,\n                'cookie_samesite' => 'Strict',\n                'use_strict_mode' => true\n            ]);\n            \n            $_SESSION['user_id'] = $user['id'];\n            $_SESSION['username'] = $user['username'];\n            $_SESSION['role'] = $user['role'];\n            \n            // Regenerate session ID\n            session_regenerate_id(true);\n            \n            header('Location: dashboard.php');\n            exit;\n        } else {\n            $error = 'Invalid username or password';\n        }\n    }\n    \n    // Secure user creation\n    if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['register'])) {\n        $userData = [\n            'username' => $_POST['username'],\n            'email' => $_POST['email'],\n            'password' => $_POST['password']\n        ];\n        \n        $userId = $userService->createUser($userData);\n        // Handle successful registration\n    }\n    \n} catch (Exception $e) {\n    error_log('Application error: ' . $e->getMessage());\n    // Handle application errors gracefully\n}\n\n?>\n\n<!-- ============================================ -->\n<!-- MYSQL DATABASE CONFIGURATION -->\n<!-- ============================================ -->\n\n/*\nMySQL 8.0+ Secure Configuration (my.cnf/my.ini):\n\n[mysqld]\n# Security Settings\nsql-mode=\"STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\ninnodb_strict_mode=1\nlocal-infile=0\nsecure_file_priv=\"\"  # Disable LOAD_FILE/OUTFILE\n\n# SSL/TLS Configuration\nrequire_secure_transport=ON\nssl-ca=/path/to/ca.pem\nssl-cert=/path/to/server-cert.pem\nssl-key=/path/to/server-key.pem\n\n# Logging and Monitoring\nlog_error=/var/log/mysql/error.log\nslow_query_log=1\nslow_query_log_file=/var/log/mysql/slow.log\nlong_query_time=2\n\n# Connection Limits\nmax_connections=100\nmax_user_connections=20\nconnect_timeout=10\nwait_timeout=600\n\n# Character Set\ncharacter-set-server=utf8mb4\ncollation-server=utf8mb4_unicode_ci\n\n# Disable MySQL history file\n[mysql]\ndisable-auto-rehash\nno-auto-rehash\n\n# MariaDB equivalent secure settings:\n[mysqld]\nsql_mode=\"STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\ninnodb_strict_mode=1\nlocal_infile=0\nsecure_file_priv=NULL\n*/\n\n<!-- ============================================ -->\n<!-- SQLALCHEMY PYTHON IMPLEMENTATION -->\n<!-- ============================================ -->\n\n'''\n# SQLAlchemy ORM with MySQL security\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, scoped_session\nfrom sqlalchemy.pool import QueuePool\nimport datetime\nimport bcrypt\nfrom typing import Optional\n\n# Secure MySQL connection with SQLAlchemy\nDATABASE_URL = \"mysql+pymysql://app_user:secure_password@localhost:3306/secure_app?charset=utf8mb4\"\n\nengine = create_engine(\n    DATABASE_URL,\n    \n    # Connection security\n    connect_args={\n        'charset': 'utf8mb4',\n        'ssl': {'ssl_ca': '/path/to/ca.pem'},\n        'autocommit': False,\n        'sql_mode': 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_DIVISION'\n    },\n    \n    # Connection pooling\n    poolclass=QueuePool,\n    pool_size=10,\n    max_overflow=20,\n    pool_pre_ping=True,\n    pool_recycle=3600,\n    \n    # Security settings\n    echo=False,  # Disable query logging in production\n    future=True  # Use SQLAlchemy 2.0 style\n)\n\n# Thread-safe session factory\nSessionLocal = scoped_session(sessionmaker(\n    bind=engine,\n    autocommit=False,\n    autoflush=False,\n    future=True\n))\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    is_active = Column(Boolean, default=True)\n    role = Column(String(20), default='user')\n    created_at = Column(DateTime, default=datetime.datetime.utcnow)\n    last_login = Column(DateTime, nullable=True)\n    failed_attempts = Column(Integer, default=0)\n    locked_until = Column(DateTime, nullable=True)\n\nclass UserService:\n    def __init__(self):\n        self.db = SessionLocal()\n    \n    def authenticate_user(self, username: str, password: str) -> Optional[User]:\n        # Parameterized query through ORM\n        user = self.db.query(User).filter(\n            User.username == username,\n            User.is_active == True\n        ).first()\n        \n        if not user:\n            return None\n        \n        # Verify password securely\n        if bcrypt.checkpw(password.encode('utf-8'), user.password_hash.encode('utf-8')):\n            # Update last login\n            user.last_login = datetime.datetime.utcnow()\n            user.failed_attempts = 0\n            self.db.commit()\n            return user\n        else:\n            # Increment failed attempts\n            user.failed_attempts += 1\n            if user.failed_attempts >= 5:\n                # Lock account for 1 hour\n                user.locked_until = datetime.datetime.utcnow() + datetime.timedelta(hours=1)\n            self.db.commit()\n            return None\n    \n    def create_user(self, username: str, email: str, password: str) -> User:\n        # Hash password securely\n        password_hash = bcrypt.hashpw(\n            password.encode('utf-8'), \n            bcrypt.gensalt(rounds=12)\n        ).decode('utf-8')\n        \n        # Create user with ORM protection\n        user = User(\n            username=username,\n            email=email,\n            password_hash=password_hash\n        )\n        \n        self.db.add(user)\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n    \n    def get_user_orders(self, user_id: int, limit: int = 10, offset: int = 0):\n        # Secure query with parameter binding\n        orders = self.db.query(Order).filter(\n            Order.user_id == user_id\n        ).order_by(\n            Order.created_at.desc()\n        ).limit(limit).offset(offset).all()\n        \n        return orders\n    \n    def __del__(self):\n        self.db.close()\n\n# FastAPI Integration Example\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Could not validate credentials\"\n            )\n    except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\"\n        )\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n'''\n\n<!-- ============================================ -->\n<!-- NODE.JS MYSQL IMPLEMENTATION -->\n<!-- ============================================ -->\n\n/*\n// Secure MySQL implementation with Node.js\nconst mysql = require('mysql2/promise');\nconst bcrypt = require('bcrypt');\nconst { body, validationResult } = require('express-validator');\n\nclass SecureMySQLService {\n    constructor() {\n        this.pool = mysql.createPool({\n            host: 'localhost',\n            port: 3306,\n            user: 'app_user',\n            password: 'secure_password',\n            database: 'secure_app',\n            charset: 'utf8mb4',\n            \n            // Security settings\n            ssl: {\n                rejectUnauthorized: true,\n                ca: fs.readFileSync('/path/to/ca.pem')\n            },\n            \n            // Connection pooling\n            connectionLimit: 10,\n            acquireTimeout: 60000,\n            timeout: 60000,\n            \n            // MySQL strict mode\n            initCommand: \"SET SESSION sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_DIVISION'\",\n            \n            // Named placeholders\n            namedPlaceholders: true,\n            \n            // Multiple statements disabled\n            multipleStatements: false\n        });\n    }\n    \n    // Input validation middleware\n    static validateUserInput() {\n        return [\n            body('username')\n                .trim()\n                .isLength({ min: 3, max: 50 })\n                .matches(/^[a-zA-Z0-9_]+$/)\n                .escape(),\n            body('password')\n                .isLength({ min: 8 })\n                .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/),\n            body('email')\n                .isEmail()\n                .normalizeEmail()\n        ];\n    }\n    \n    // Secure user authentication\n    async authenticateUser(username, password) {\n        const connection = await this.pool.getConnection();\n        \n        try {\n            // Use prepared statements with named placeholders\n            const [rows] = await connection.execute(`\n                SELECT id, username, password_hash, email, role, \n                       failed_attempts, locked_until\n                FROM users \n                WHERE username = :username \n                AND is_active = 1\n                LIMIT 1\n            `, { username });\n            \n            const user = rows[0];\n            if (!user) {\n                await this.recordFailedLogin(connection, username);\n                return null;\n            }\n            \n            // Check if account is locked\n            if (user.locked_until && new Date(user.locked_until) > new Date()) {\n                throw new Error('Account temporarily locked');\n            }\n            \n            // Verify password\n            const isValidPassword = await bcrypt.compare(password, user.password_hash);\n            \n            if (!isValidPassword) {\n                await this.incrementFailedAttempts(connection, user.id);\n                return null;\n            }\n            \n            // Reset failed attempts on success\n            await this.resetFailedAttempts(connection, user.id);\n            await this.updateLastLogin(connection, user.id);\n            \n            // Return user without sensitive data\n            const { password_hash, ...safeUser } = user;\n            return safeUser;\n            \n        } finally {\n            connection.release();\n        }\n    }\n    \n    // Secure user creation\n    async createUser(userData) {\n        const connection = await this.pool.getConnection();\n        \n        try {\n            // Hash password securely\n            const passwordHash = await bcrypt.hash(userData.password, 12);\n            \n            // Insert user with prepared statement\n            const [result] = await connection.execute(`\n                INSERT INTO users (username, email, password_hash, created_at) \n                VALUES (:username, :email, :password_hash, NOW())\n            `, {\n                username: userData.username,\n                email: userData.email,\n                password_hash: passwordHash\n            });\n            \n            return result.insertId;\n            \n        } catch (error) {\n            if (error.code === 'ER_DUP_ENTRY') {\n                throw new Error('Username or email already exists');\n            }\n            throw error;\n        } finally {\n            connection.release();\n        }\n    }\n    \n    // Secure data retrieval with pagination\n    async getUserOrders(userId, limit = 10, offset = 0) {\n        const connection = await this.pool.getConnection();\n        \n        try {\n            // Validate parameters\n            if (limit > 100 || limit < 1) {\n                throw new Error('Invalid limit parameter');\n            }\n            \n            const [rows] = await connection.execute(`\n                SELECT o.id, o.order_date, o.total_amount, o.status,\n                       JSON_ARRAYAGG(\n                           JSON_OBJECT(\n                               'product_name', p.name,\n                               'quantity', oi.quantity,\n                               'price', oi.price\n                           )\n                       ) as items\n                FROM orders o\n                JOIN order_items oi ON o.id = oi.order_id\n                JOIN products p ON oi.product_id = p.id\n                WHERE o.user_id = :user_id\n                GROUP BY o.id\n                ORDER BY o.order_date DESC\n                LIMIT :limit OFFSET :offset\n            `, {\n                user_id: userId,\n                limit: parseInt(limit),\n                offset: parseInt(offset)\n            });\n            \n            return rows;\n            \n        } finally {\n            connection.release();\n        }\n    }\n    \n    async recordFailedLogin(connection, username) {\n        // Log failed login attempts for monitoring\n        await connection.execute(`\n            INSERT INTO failed_logins (username, ip_address, user_agent, created_at)\n            VALUES (:username, :ip_address, :user_agent, NOW())\n        `, {\n            username: username,\n            ip_address: '192.168.1.1', // Get from request\n            user_agent: 'Mozilla/5.0...' // Get from request\n        });\n    }\n    \n    async incrementFailedAttempts(connection, userId) {\n        await connection.execute(`\n            UPDATE users \n            SET failed_attempts = failed_attempts + 1,\n                locked_until = CASE \n                    WHEN failed_attempts >= 4 THEN DATE_ADD(NOW(), INTERVAL 1 HOUR)\n                    ELSE locked_until \n                END\n            WHERE id = :user_id\n        `, { user_id: userId });\n    }\n}\n\n// Express.js route example\nconst express = require('express');\nconst app = express();\nconst userService = new SecureMySQLService();\n\n// Login route with validation\napp.post('/api/login', \n    SecureMySQLService.validateUserInput(),\n    async (req, res) => {\n        try {\n            const errors = validationResult(req);\n            if (!errors.isEmpty()) {\n                return res.status(400).json({ errors: errors.array() });\n            }\n            \n            const { username, password } = req.body;\n            const user = await userService.authenticateUser(username, password);\n            \n            if (user) {\n                // Generate secure JWT token\n                const token = jwt.sign(\n                    { userId: user.id, username: user.username, role: user.role },\n                    process.env.JWT_SECRET,\n                    { expiresIn: '1h' }\n                );\n                \n                res.json({ user, token });\n            } else {\n                res.status(401).json({ error: 'Invalid credentials' });\n            }\n        } catch (error) {\n            console.error('Login error:', error);\n            res.status(500).json({ error: 'Authentication failed' });\n        }\n    }\n);\n*/\n\n<!-- ============================================ -->\n<!-- SECURITY TESTING AND VALIDATION -->\n<!-- ============================================ -->\n\n/*\nMySQL SQL Injection Testing Checklist:\n\n1. Input Validation Testing:\n   - Test with SQL injection payloads: ' OR '1'='1\n   - Test MySQL comments: ', --, /* */\n   - Test MySQL functions: LOAD_FILE(), INTO OUTFILE\n   - Test UNION queries: UNION SELECT 1,2,3\n   - Test Boolean-based blind injection: ' AND 1=1\n\n2. Parameterized Query Verification:\n   - Verify all dynamic SQL uses prepared statements\n   - Check for string concatenation in queries\n   - Ensure proper parameter binding\n\n3. MySQL Configuration Security:\n   - Verify strict SQL mode is enabled\n   - Check local_infile is disabled\n   - Confirm secure_file_priv is restricted\n   - Validate SSL/TLS is enforced\n\n4. Access Control Testing:\n   - Test least privilege database users\n   - Verify restricted file system access\n   - Check for excessive database permissions\n\n5. Error Handling Testing:\n   - Verify database errors are not exposed\n   - Test error messages don't reveal schema\n   - Check stack trace protection\n\n6. Monitoring and Logging:\n   - Enable MySQL general query log for testing\n   - Monitor for suspicious query patterns\n   - Set up alerts for failed login attempts\n\nAutomated Security Testing:\n```sql\n-- Test for SQL injection vulnerabilities\nSELECT * FROM users WHERE username = ''' OR 1=1 --';\n\n-- Test MySQL functions\nSELECT LOAD_FILE('/etc/passwd');\n\n-- Test information_schema access\nSELECT table_name FROM information_schema.tables;\n\n-- Test file operations\nSELECT 'test' INTO OUTFILE '/tmp/test.txt';\n```\n\n7. Performance Testing:\n   - Test query performance with prepared statements\n   - Monitor connection pool efficiency\n   - Validate SSL/TLS overhead is acceptable\n\n8. Compliance Validation:\n   - OWASP ASVS Level 2 compliance\n   - PCI DSS requirements for database security\n   - GDPR data protection compliance\n*/"
      }
    ]
  },
  {
    "pluginId": 40020,
    "title": "SQL Injection - Hypersonic SQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "HSQLDB (Hypersonic SQL) Injection occurs when untrusted input is concatenated into HSQLDB SQL queries without proper parameterization. HSQLDB has specific syntax vulnerabilities including Java method calls, INFORMATION_SCHEMA access, system function calls, and in-memory database features that attackers can exploit to bypass authentication, access sensitive data, or execute arbitrary Java code through the database engine.",
    "simplified_description": "Your application has a critical security flaw in the HSQLDB database layer that allows attackers to inject malicious SQL commands. HSQLDB is like a sophisticated filing system that understands both database commands and Java programming - attackers can exploit this dual capability to not only read your data but also execute Java code on your server, potentially taking complete control of your application.",
    "solution": "Implement parameterized queries using HSQLDB prepared statements, disable Java method execution, use connection pooling with security restrictions, validate all inputs, and employ HSQLDB-specific security configurations.",
    "simplified_solution": "Replace all SQL string concatenation with HSQLDB prepared statements using parameter binding. Disable HSQLDB's Java method execution capability. Configure HSQLDB to run in restricted mode without file system access. Use HSQLDB's built-in SQL standard mode and disable database management functions. Validate all user inputs with strict type checking and length limits. Implement proper connection security with minimal database privileges.",
    "references": [
      {
        "name": "HSQLDB Security Documentation",
        "url": "http://hsqldb.org/doc/guide/sessions.html"
      },
      {
        "name": "OWASP SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "CWE-89: SQL Injection",
        "url": "https://cwe.mitre.org/data/definitions/89.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Java HSQLDB Secure Implementation",
        "solution_description": "Secure HSQLDB implementation using JDBC prepared statements, connection pooling with HikariCP, and comprehensive input validation. Includes HSQLDB-specific security configurations to prevent Java method execution and file system access.",
        "affected_files": "Database configuration files (application.properties, hsqldb.properties), data access objects (DAO classes), service layer classes, connection pool configuration, security configuration files",
        "code": "// ============================================\n// SECURE HSQLDB CONNECTION CONFIGURATION\n// ============================================\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport javax.sql.DataSource;\nimport java.sql.*;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class SecureHSQLDBConfig {\n    \n    // HSQLDB Secure DataSource Configuration\n    public static DataSource createSecureDataSource() {\n        HikariConfig config = new HikariConfig();\n        \n        // HSQLDB JDBC URL with security settings\n        config.setJdbcUrl(\"jdbc:hsqldb:mem:securedb;sql.syntax_mys=true;sql.enforce_size=true;sql.enforce_names=true\");\n        config.setUsername(\"app_user\");\n        config.setPassword(\"secure_password\");\n        \n        // HSQLDB-specific connection properties\n        config.addDataSourceProperty(\"cache_size\", \"1024\");\n        config.addDataSourceProperty(\"cache_file_scale\", \"8\");\n        config.addDataSourceProperty(\"runtime.gc_interval\", \"5000\");\n        \n        // Security: Disable database management functions\n        config.addDataSourceProperty(\"hsqldb.system_file\", \"false\");\n        config.addDataSourceProperty(\"hsqldb.log_data\", \"false\");\n        config.addDataSourceProperty(\"hsqldb.script_format\", \"0\"); // Disable script execution\n        \n        // Connection pool security settings\n        config.setMaximumPoolSize(20);\n        config.setMinimumIdle(5);\n        config.setConnectionTimeout(30000);\n        config.setIdleTimeout(600000);\n        config.setMaxLifetime(1800000);\n        config.setLeakDetectionThreshold(60000);\n        \n        // Additional security\n        config.setConnectionTestQuery(\"SELECT 1\");\n        config.setPoolName(\"SecureHSQLDBPool\");\n        \n        return new HikariDataSource(config);\n    }\n    \n    // HSQLDB initialization with security constraints\n    public static void initializeDatabase(DataSource dataSource) {\n        try (Connection conn = dataSource.getConnection();\n             Statement stmt = conn.createStatement()) {\n            \n            // Set HSQLDB security properties\n            stmt.execute(\"SET DATABASE SQL SECURITY TRUE\");\n            stmt.execute(\"SET DATABASE TRANSACTION CONTROL LOCKS\");\n            stmt.execute(\"SET DATABASE DEFAULT TABLE TYPE CACHED\");\n            stmt.execute(\"SET DATABASE SQL REGULAR NAMES TRUE\");\n            stmt.execute(\"SET DATABASE SQL REFERENCES TRUE\");\n            stmt.execute(\"SET DATABASE SQL SIZE TRUE\");\n            stmt.execute(\"SET DATABASE SQL NAMES FALSE\"); // Prevent special characters\n            \n            // Disable dangerous HSQLDB features\n            stmt.execute(\"SET FILES SPACE TRUE\"); // Restrict file operations\n            stmt.execute(\"SET FILES LOB SCALE 32\");\n            stmt.execute(\"SET FILES LOG SIZE 200\");\n            \n            // Create secure user tables\n            stmt.execute(\"\"\n                + \"CREATE TABLE users (\"\n                + \"    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\"\n                + \"    username VARCHAR(50) NOT NULL UNIQUE,\"\n                + \"    email VARCHAR(255) NOT NULL UNIQUE,\"\n                + \"    password_hash VARCHAR(255) NOT NULL,\"\n                + \"    role VARCHAR(20) DEFAULT 'USER',\"\n                + \"    is_active BOOLEAN DEFAULT TRUE,\"\n                + \"    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\"\n                + \"    last_login TIMESTAMP,\"\n                + \"    failed_attempts INTEGER DEFAULT 0,\"\n                + \"    locked_until TIMESTAMP\"\n                + \")\");\n            \n            // Create secure user roles\n            stmt.execute(\"\"\n                + \"CREATE TABLE user_roles (\"\n                + \"    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\"\n                + \"    user_id BIGINT NOT NULL REFERENCES users(id),\"\n                + \"    role_name VARCHAR(50) NOT NULL,\"\n                + \"    CONSTRAINT unique_user_role UNIQUE (user_id, role_name)\"\n                + \")\");\n            \n            // Create secure audit log\n            stmt.execute(\"\"\n                + \"CREATE TABLE audit_log (\"\n                + \"    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\"\n                + \"    user_id BIGINT REFERENCES users(id),\"\n                + \"    action VARCHAR(100) NOT NULL,\"\n                + \"    table_name VARCHAR(100),\"\n                + \"    record_id BIGINT,\"\n                + \"    ip_address VARCHAR(45),\"\n                + \"    user_agent VARCHAR(500),\"\n                + \"    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\"\n                + \")\");\n            \n            // Create indexes for performance and security\n            stmt.execute(\"CREATE INDEX idx_users_username ON users(username)\");\n            stmt.execute(\"CREATE INDEX idx_users_email ON users(email)\");\n            stmt.execute(\"CREATE INDEX idx_users_active ON users(is_active)\");\n            stmt.execute(\"CREATE INDEX idx_audit_user ON audit_log(user_id)\");\n            stmt.execute(\"CREATE INDEX idx_audit_created ON audit_log(created_at)\");\n            \n            // Insert default admin user with secure password\n            BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);\n            String adminPasswordHash = encoder.encode(\"adminSecurePassword123!\");\n            \n            PreparedStatement pstmt = conn.prepareStatement(\"\"\n                + \"INSERT INTO users (username, email, password_hash, role) VALUES (?, ?, ?, ?)\"\n            );\n            pstmt.setString(1, \"admin\");\n            pstmt.setString(2, \"admin@example.com\");\n            pstmt.setString(3, adminPasswordHash);\n            pstmt.setString(4, \"ADMIN\");\n            pstmt.executeUpdate();\n            pstmt.close();\n            \n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to initialize secure database\", e);\n        }\n    }\n}\n\n// ============================================\n// SECURE USER SERVICE WITH HSQLDB\n// ============================================\n\n@Service\npublic class SecureUserService {\n    private final JdbcTemplate jdbcTemplate;\n    private final BCryptPasswordEncoder passwordEncoder;\n    private final AuditService auditService;\n    \n    public SecureUserService(DataSource dataSource, AuditService auditService) {\n        this.jdbcTemplate = new JdbcTemplate(dataSource);\n        this.passwordEncoder = new BCryptPasswordEncoder(12);\n        this.auditService = auditService;\n    }\n    \n    // Secure user authentication with prepared statements\n    public Optional<User> authenticateUser(String username, String password, String ipAddress, String userAgent) {\n        // Input validation\n        if (!isValidUsername(username) || !isValidPassword(password)) {\n            auditService.logFailedLogin(null, \"AUTHENTICATION\", \"Invalid input format\", ipAddress);\n            return Optional.empty();\n        }\n        \n        // Secure query with prepared statement\n        String sql = \"\"\n            + \"SELECT id, username, email, password_hash, role, is_active, \"\n            + \"       failed_attempts, locked_until \"\n            + \"FROM users \"\n            + \"WHERE username = ? AND is_active = TRUE\";\n        \n        try {\n            List<User> users = jdbcTemplate.query(sql, new Object[]{username}, this::mapUser);\n            \n            if (users.isEmpty()) {\n                auditService.logFailedLogin(null, \"AUTHENTICATION\", \"User not found\", ipAddress);\n                return Optional.empty();\n            }\n            \n            User user = users.get(0);\n            \n            // Check account lock\n            if (user.getLockedUntil() != null && user.getLockedUntil().after(new Date())) {\n                auditService.logFailedLogin(user.getId(), \"AUTHENTICATION\", \"Account locked\", ipAddress);\n                return Optional.empty();\n            }\n            \n            // Verify password\n            if (!passwordEncoder.matches(password, user.getPasswordHash())) {\n                incrementFailedAttempts(user.getId());\n                auditService.logFailedLogin(user.getId(), \"AUTHENTICATION\", \"Invalid password\", ipAddress);\n                return Optional.empty();\n            }\n            \n            // Successful authentication\n            resetFailedAttempts(user.getId());\n            updateLastLogin(user.getId());\n            auditService.logSuccess(user.getId(), \"AUTHENTICATION\", \"User logged in\", ipAddress);\n            \n            // Return user without sensitive data\n            user.setPasswordHash(null);\n            return Optional.of(user);\n            \n        } catch (Exception e) {\n            auditService.logFailedLogin(null, \"AUTHENTICATION\", \"Database error\", ipAddress);\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n    \n    // Secure user creation with comprehensive validation\n    @Transactional\n    public User createUser(UserRegistrationDTO registration, String ipAddress) {\n        // Validate input\n        if (!isValidUsername(registration.getUsername()) ||\n            !isValidEmail(registration.getEmail()) ||\n            !isValidPassword(registration.getPassword())) {\n            throw new IllegalArgumentException(\"Invalid user data\");\n        }\n        \n        // Check if user exists\n        if (userExists(registration.getUsername(), registration.getEmail())) {\n            throw new IllegalArgumentException(\"User already exists\");\n        }\n        \n        try {\n            // Hash password securely\n            String passwordHash = passwordEncoder.encode(registration.getPassword());\n            \n            // Insert user with prepared statement\n            String sql = \"\"\n                + \"INSERT INTO users (username, email, password_hash, role) VALUES (?, ?, ?, ?)\";\n            \n            KeyHolder keyHolder = new GeneratedKeyHolder();\n            jdbcTemplate.update(connection -> {\n                PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                ps.setString(1, registration.getUsername());\n                ps.setString(2, registration.getEmail());\n                ps.setString(3, passwordHash);\n                ps.setString(4, \"USER\");\n                return ps;\n            }, keyHolder);\n            \n            Long userId = keyHolder.getKey().longValue();\n            \n            // Log user creation\n            auditService.logSuccess(userId, \"USER_CREATION\", \"New user created\", ipAddress);\n            \n            // Create and return user\n            User user = new User();\n            user.setId(userId);\n            user.setUsername(registration.getUsername());\n            user.setEmail(registration.getEmail());\n            user.setRole(\"USER\");\n            user.setActive(true);\n            \n            return user;\n            \n        } catch (DataAccessException e) {\n            auditService.logFailedLogin(null, \"USER_CREATION\", \"Database error: \" + e.getMessage(), ipAddress);\n            throw new RuntimeException(\"Failed to create user\", e);\n        }\n    }\n    \n    // Secure data retrieval with pagination and authorization\n    public Page<UserOrdersDTO> getUserOrders(Long userId, int page, int size, Long requestingUserId) {\n        // Authorization check\n        if (!userId.equals(requestingUserId) && !hasAdminRole(requestingUserId)) {\n            throw new AccessDeniedException(\"Unauthorized access\");\n        }\n        \n        // Validate pagination parameters\n        if (page < 0 || size < 1 || size > 100) {\n            throw new IllegalArgumentException(\"Invalid pagination parameters\");\n        }\n        \n        // Count total orders\n        String countSql = \"SELECT COUNT(*) FROM orders WHERE user_id = ?\";\n        Long totalCount = jdbcTemplate.queryForObject(countSql, new Object[]{userId}, Long.class);\n        \n        // Get paginated orders with secure prepared statement\n        String sql = \"\"\n            + \"SELECT o.id, o.order_date, o.total_amount, o.status, \"\n            + \"       GROUP_CONCAT(p.name || ':' || oi.quantity) as items \"\n            + \"FROM orders o \"\n            + \"JOIN order_items oi ON o.id = oi.order_id \"\n            + \"JOIN products p ON oi.product_id = p.id \"\n            + \"WHERE o.user_id = ? \"\n            + \"GROUP BY o.id \"\n            + \"ORDER BY o.order_date DESC \"\n            + \"LIMIT ? OFFSET ?\";\n        \n        int offset = page * size;\n        List<Order> orders = jdbcTemplate.query(sql, new Object[]{userId, size, offset}, this::mapOrder);\n        \n        return new Page<>(orders, totalCount, page, size);\n    }\n    \n    // Input validation methods\n    private boolean isValidUsername(String username) {\n        return username != null && \n               username.matches(\"^[a-zA-Z0-9_]{3,50}$\");\n    }\n    \n    private boolean isValidEmail(String email) {\n        return email != null && \n               email.matches(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n    }\n    \n    private boolean isValidPassword(String password) {\n        return password != null && \n               password.length() >= 8 &&\n               password.matches(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\");\n    }\n    \n    private boolean userExists(String username, String email) {\n        String sql = \"SELECT COUNT(*) FROM users WHERE username = ? OR email = ?\";\n        Long count = jdbcTemplate.queryForObject(sql, new Object[]{username, email}, Long.class);\n        return count != null && count > 0;\n    }\n    \n    private void incrementFailedAttempts(Long userId) {\n        String sql = \"\"\n            + \"UPDATE users SET failed_attempts = failed_attempts + 1, \"\n            + \"locked_until = CASE WHEN failed_attempts >= 4 THEN DATEADD('HOUR', 1, CURRENT_TIMESTAMP) ELSE locked_until END \"\n            + \"WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private void resetFailedAttempts(Long userId) {\n        String sql = \"UPDATE users SET failed_attempts = 0, locked_until = NULL WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private void updateLastLogin(Long userId) {\n        String sql = \"UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private boolean hasAdminRole(Long userId) {\n        String sql = \"SELECT role FROM users WHERE id = ?\";\n        String role = jdbcTemplate.queryForObject(sql, new Object[]{userId}, String.class);\n        return \"ADMIN\".equals(role);\n    }\n    \n    // Row mappers\n    private User mapUser(ResultSet rs) throws SQLException {\n        User user = new User();\n        user.setId(rs.getLong(\"id\"));\n        user.setUsername(rs.getString(\"username\"));\n        user.setEmail(rs.getString(\"email\"));\n        user.setPasswordHash(rs.getString(\"password_hash\"));\n        user.setRole(rs.getString(\"role\"));\n        user.setActive(rs.getBoolean(\"is_active\"));\n        user.setFailedAttempts(rs.getInt(\"failed_attempts\"));\n        user.setLockedUntil(rs.getTimestamp(\"locked_until\"));\n        user.setCreatedAt(rs.getTimestamp(\"created_at\"));\n        user.setLastLogin(rs.getTimestamp(\"last_login\"));\n        return user;\n    }\n    \n    private Order mapOrder(ResultSet rs) throws SQLException {\n        Order order = new Order();\n        order.setId(rs.getLong(\"id\"));\n        order.setOrderDate(rs.getTimestamp(\"order_date\"));\n        order.setTotalAmount(rs.getBigDecimal(\"total_amount\"));\n        order.setStatus(rs.getString(\"status\"));\n        // Parse items string into list\n        return order;\n    }\n}\n\n// ============================================\n// SECURITY CONFIGURATION FOR SPRING BOOT\n// ============================================\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -> csrf.disable()) // Disable for API, enable for web forms\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                .maximumSessions(1)\n                .maxSessionsPreventsLogin(true)\n            )\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider()), UsernamePasswordAuthenticationFilter.class);\n        \n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12);\n    }\n    \n    @Bean\n    public DataSource dataSource() {\n        return SecureHSQLDBConfig.createSecureDataSource();\n    }\n}\n\n// ============================================\n// HSQLDB APPLICATION PROPERTIES\n// ============================================\n\n/*\n# application.properties - HSQLDB Security Configuration\n\n# HSQLDB Database Configuration\nspring.datasource.url=jdbc:hsqldb:mem:securedb;sql.syntax_mys=true;sql.enforce_size=true;sql.enforce_names=true\nspring.datasource.username=app_user\nspring.datasource.password=secure_password\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\n\n# HSQLDB Security Settings\nspring.datasource.hikari.maximum-pool-size=20\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.connection-timeout=30000\nspring.datasource.hikari.idle-timeout=600000\nspring.datasource.hikari.max-lifetime=1800000\nspring.datasource.hikari.leak-detection-threshold=60000\n\n# HSQLDB Custom Properties\nspring.datasource.properties.cache_size=1024\nspring.datasource.properties.cache_file_scale=8\nspring.datasource.properties.runtime.gc_interval=5000\nspring.datasource.properties.hsqldb.system_file=false\nspring.datasource.properties.hsqldb.log_data=false\nspring.datasource.properties.hsqldb.script_format=0\n\n# JPA/Hibernate Configuration with HSQLDB\nspring.jpa.hibernate.ddl-auto=none\nspring.jpa.show-sql=false\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.HSQLDialect\nspring.jpa.properties.hibernate.jdbc.batch_size=20\nspring.jpa.properties.hibernate.order_inserts=true\nspring.jpa.properties.hibernate.order_updates=true\nspring.jpa.properties.hibernate.jdbc.batch_versioned_data=true\n\n# Security Settings\nserver.servlet.session.cookie.http-only=true\nserver.servlet.session.cookie.secure=true\nserver.servlet.session.cookie.same-site=strict\nserver.servlet.session.timeout=30m\n\n# Logging\nlogging.level.org.springframework.security=DEBUG\nlogging.level.com.yourapp.audit=INFO\nlogging.level.org.hsqldb=WARN\n*/\n\n<!-- ============================================ -->\n<!-- PERSISTENCE.XML FOR HSQLDB -->\n<!-- ============================================ -->\n\n/*\n<persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"\n             version=\"2.2\">\n    <persistence-unit name=\"securePersistenceUnit\">\n        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>\n        \n        <!-- HSQLDB Secure Configuration -->\n        <class>com.yourapp.model.User</class>\n        <class>com.yourapp.model.Order</class>\n        <class>com.yourapp.model.AuditLog</class>\n        \n        <properties>\n            <!-- HSQLDB Connection -->\n            <property name=\"javax.persistence.jdbc.driver\" value=\"org.hsqldb.jdbc.JDBCDriver\" />\n            <property name=\"javax.persistence.jdbc.url\" value=\"jdbc:hsqldb:mem:securedb;sql.syntax_mys=true;sql.enforce_size=true\" />\n            <property name=\"javax.persistence.jdbc.user\" value=\"app_user\" />\n            <property name=\"javax.persistence.jdbc.password\" value=\"secure_password\" />\n            \n            <!-- Hibernate Security Settings -->\n            <property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.HSQLDialect\" />\n            <property name=\"hibernate.hbm2ddl.auto\" value=\"validate\" />\n            <property name=\"hibernate.show_sql\" value=\"false\" />\n            <property name=\"hibernate.format_sql\" value=\"false\" />\n            <property name=\"hibernate.use_sql_comments\" value=\"false\" />\n            \n            <!-- Performance and Security -->\n            <property name=\"hibernate.jdbc.batch_size\" value=\"20\" />\n            <property name=\"hibernate.order_inserts\" value=\"true\" />\n            <property name=\"hibernate.order_updates\" value=\"true\" />\n            <property name=\"hibernate.jdbc.batch_versioned_data\" value=\"true\" />\n            <property name=\"hibernate.connection.provider_disables_autocommit\" value=\"true\" />\n            \n            <!-- Validation -->\n            <property name=\"javax.persistence.validation.mode\" value=\"none\" />\n        </properties>\n    </persistence-unit>\n</persistence>\n*/"
      }
    ]
  },
  {
    "pluginId": 40021,
    "title": "SQL Injection - Oracle",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "Oracle SQL Injection occurs when untrusted input is concatenated into Oracle SQL queries without proper parameterization. Oracle databases have specific injection vulnerabilities including PL/SQL block execution, cursor injection, function injection, UTL_HTTP package exploitation, and Oracle-specific syntax like comments (--), string concatenation (||), and UNION queries that can bypass authentication, access sensitive data, or execute system commands through Oracle packages.",
    "simplified_description": "Your application has a critical Oracle database security flaw that allows attackers to inject malicious Oracle SQL commands. Oracle databases are like powerful information vaults with their own programming language - attackers can exploit this to not only read your data but also execute Oracle's built-in functions to access files, make network requests, or even take control of your database server. This can lead to complete data theft or system compromise.",
    "solution": "Implement Oracle parameterized queries using bind variables, disable PL/SQL injection, use Oracle's least privilege model, implement Virtual Private Database (VPD), validate all inputs, and employ Oracle-specific security features like Database Vault and Real Application Security.",
    "simplified_solution": "Replace all SQL string concatenation with Oracle bind variables and prepared statements. Use Oracle Application Express (APEX) or Oracle JDBC/ODBC drivers with parameter binding. Create database users with minimal required privileges using Oracle's fine-grained access control. Implement Virtual Private Database policies for data access control. Enable Oracle Database Vault for sensitive data protection. Use Oracle Label Security for mandatory access control. Regularly apply Oracle Critical Patch Updates (CPU).",
    "references": [
      {
        "name": "Oracle Database Security Guide",
        "url": "https://docs.oracle.com/en/database/oracle/oracle-database/19/tgdb/"
      },
      {
        "name": "OWASP Oracle SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "Oracle Database Vault Documentation",
        "url": "https://docs.oracle.com/en/database/oracle/oracle-database/19/dvcon/"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Java Oracle Secure Implementation",
        "solution_description": "Secure Oracle database implementation using JDBC bind variables, Oracle's Virtual Private Database (VPD), connection pooling with Oracle UCP, and comprehensive security controls including Database Vault integration and fine-grained access control.",
        "affected_files": "Oracle connection configuration (ucp.properties, tnsnames.ora), data access objects (DAO classes), security policies (VPD policies), PL/SQL packages, Oracle RAC configuration files",
        "code": "// ============================================\n// SECURE ORACLE DATABASE CONFIGURATION\n// ============================================\n\nimport oracle.ucp.jdbc.PoolDataSource;\nimport oracle.ucp.jdbc.PoolDataSourceFactory;\nimport oracle.jdbc.pool.OracleDataSource;\nimport oracle.jdbc.OracleConnection;\nimport oracle.security.xs.Principal;\nimport java.sql.*;\nimport java.util.Properties;\nimport javax.sql.DataSource;\n\npublic class SecureOracleConfig {\n    \n    // Oracle UCP (Universal Connection Pool) with security\n    public static PoolDataSource createSecureOracleDataSource() throws SQLException {\n        PoolDataSource poolDataSource = PoolDataSourceFactory.getPoolDataSource();\n        \n        // Oracle connection details\n        poolDataSource.setConnectionFactoryClassName(\"oracle.jdbc.pool.OracleDataSource\");\n        poolDataSource.setURL(\"jdbc:oracle:thin:@//oracle-host:1521/SERVICE_NAME\");\n        poolDataSource.setUser(\"APP_USER\");\n        poolDataSource.setPassword(\"secure_password\");\n        \n        // Connection Pool Security Settings\n        poolDataSource.setInitialPoolSize(5);\n        poolDataSource.setMinPoolSize(5);\n        poolDataSource.setMaxPoolSize(20);\n        poolDataSource.setValidateConnectionOnBorrow(true);\n        poolDataSource.setAbandonedConnectionTimeout(300);\n        poolDataSource.setTimeToLiveConnectionTimeout(1200);\n        poolDataSource.setConnectionPoolName(\"SecureOraclePool\");\n        \n        // Oracle-specific properties\n        poolDataSource.setConnectionProperty(\"oracle.net.CONNECT_TIMEOUT\", \"5000\");\n        poolDataSource.setConnectionProperty(\"oracle.jdbc.ReadTimeout\", \"30000\");\n        poolDataSource.setConnectionProperty(\"oracle.net.encryptTypes\", \"(AES256)\");\n        poolDataSource.setConnectionProperty(\"oracle.net.crypto_checksum_client\", \"REQUIRED\");\n        poolDataSource.setConnectionProperty(\"oracle.net.crypto_checksum_server\", \"REQUIRED\");\n        poolDataSource.setConnectionProperty(\"oracle.net.encryption_client\", \"REQUIRED\");\n        poolDataSource.setConnectionProperty(\"oracle.net.encryption_server\", \"REQUIRED\");\n        \n        // Performance and security\n        poolDataSource.setConnectionProperty(\"defaultRowPrefetch\", \"50\");\n        poolDataSource.setConnectionProperty(\"defaultBatchValue\", \"25\");\n        poolDataSource.setConnectionProperty(\"oracle.jdbc.defaultNChar\", \"true\");\n        \n        return poolDataSource;\n    }\n    \n    // Oracle connection with enhanced security\n    public static Connection createSecureConnection(DataSource dataSource) throws SQLException {\n        OracleConnection connection = (OracleConnection) dataSource.getConnection();\n        \n        // Set Oracle session security properties\n        Properties sessionProps = new Properties();\n        sessionProps.setProperty(\"_oracle_jdbc_protocolN\", \"true\");\n        sessionProps.setProperty(\"oracle.jdbc.defaultNChar\", \"true\");\n        sessionProps.setProperty(\"oracle.jdbc.fanEnabled\", \"true\");\n        \n        // Enable Oracle Advanced Security\n        connection.setClientInfo(sessionProps);\n        \n        // Set secure session parameters\n        try (CallableStatement stmt = connection.prepareCall(\n            \"BEGIN DBMS_SESSION.SET_IDENTIFIER(?); END;\")) {\n            stmt.setString(1, \"SecureAppSession\");\n            stmt.execute();\n        }\n        \n        // Enable Oracle Label Security (if configured)\n        try (CallableStatement stmt = connection.prepareCall(\n            \"BEGIN DBMS_RLS.ENABLE_POLICY(?, ?, ?); END;\")) {\n            stmt.setString(1, \"USERS\");\n            stmt.setString(2, \"USER_ACCESS_POLICY\");\n            stmt.setString(3, \"SELECT\");\n            stmt.execute();\n        } catch (SQLException e) {\n            // Policy may not exist, log and continue\n            System.err.println(\"RLS policy not available: \" + e.getMessage());\n        }\n        \n        return connection;\n    }\n    \n    // Initialize Oracle database with security constraints\n    public static void initializeOracleDatabase(DataSource dataSource) {\n        try (Connection conn = dataSource.getConnection()) {\n            \n            // Create secure user table with Oracle-specific features\n            try (Statement stmt = conn.createStatement()) {\n                \n                // Drop existing objects if they exist\n                stmt.execute(\"BEGIN EXECUTE IMMEDIATE 'DROP TABLE users CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;\");\n                stmt.execute(\"BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE user_seq'; EXCEPTION WHEN OTHERS THEN NULL; END;\");\n                stmt.execute(\"BEGIN EXECUTE IMMEDIATE 'DROP TRIGGER user_trigger'; EXCEPTION WHEN OTHERS THEN NULL; END;\");\n                \n                // Create sequence for primary keys\n                stmt.execute(\"\"\n                    + \"CREATE SEQUENCE user_seq \"\n                    + \"START WITH 1000 \"\n                    + \"INCREMENT BY 1 \"\n                    + \"NOCACHE \"\n                    + \"NOCYCLE\"\n                );\n                \n                // Create secure users table with Oracle security features\n                stmt.execute(\"\"\n                    + \"CREATE TABLE users (\"\n                    + \"    id NUMBER(19) PRIMARY KEY,\"\n                    + \"    username VARCHAR2(50) NOT NULL UNIQUE,\"\n                    + \"    email VARCHAR2(255) NOT NULL UNIQUE,\"\n                    + \"    password_hash VARCHAR2(4000) NOT NULL,\"\n                    + \"    role VARCHAR2(20) DEFAULT 'USER',\"\n                    + \"    is_active CHAR(1) DEFAULT 'Y',\"\n                    + \"    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,\"\n                    + \"    last_login TIMESTAMP,\"\n                    + \"    failed_attempts NUMBER(3) DEFAULT 0,\"\n                    + \"    locked_until TIMESTAMP,\"\n                    + \"    CONSTRAINT chk_role CHECK (role IN ('USER', 'ADMIN', 'MANAGER')),\"\n                    + \"    CONSTRAINT chk_is_active CHECK (is_active IN ('Y', 'N')),\"\n                    + \"    CONSTRAINT chk_failed_attempts CHECK (failed_attempts >= 0 AND failed_attempts <= 10)\"\n                    + \")\"\n                    + \"TABLESPACE users_ts\"\n                    + \"STORAGE (INITIAL 64K NEXT 64K PCTINCREASE 0)\"\n                );\n                \n                // Create trigger for auto-increment ID\n                stmt.execute(\"\"\n                    + \"CREATE OR REPLACE TRIGGER user_trigger \"\n                    + \"BEFORE INSERT ON users \"\n                    + \"FOR EACH ROW \"\n                    + \"BEGIN \"\n                    + \"    :NEW.id := user_seq.NEXTVAL; \"\n                    + \"END user_trigger;\"\n                );\n                \n                // Create audit table with Oracle audit features\n                stmt.execute(\"\"\n                    + \"CREATE TABLE audit_log (\"\n                    + \"    audit_id NUMBER(19) PRIMARY KEY,\"\n                    + \"    user_id NUMBER(19),\"\n                    + \"    action VARCHAR2(100) NOT NULL,\"\n                    + \"    table_name VARCHAR2(100),\"\n                    + \"    record_id NUMBER(19),\"\n                    + \"    ip_address VARCHAR2(45),\"\n                    + \"    user_agent VARCHAR2(4000),\"\n                    + \"    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,\"\n                    + \"    session_id VARCHAR2(100),\"\n                    + \"    CONSTRAINT fk_audit_user FOREIGN KEY (user_id) REFERENCES users(id)\"\n                    + \")\"\n                    + \"TABLESPACE audit_ts\"\n                );\n                \n                // Create sequence for audit\n                stmt.execute(\"\"\n                    + \"CREATE SEQUENCE audit_seq \"\n                    + \"START WITH 1000 \"\n                    + \"INCREMENT BY 1 \"\n                    + \"NOCACHE\"\n                );\n                \n                // Create VPD (Virtual Private Database) policy function\n                stmt.execute(\"\"\n                    + \"CREATE OR REPLACE FUNCTION user_access_policy(\"\n                    + \"    schema_name VARCHAR2,\"\n                    + \"    table_name VARCHAR2\"\n                    + \") RETURN VARCHAR2 IS \"\n                    + \"    user_id_str VARCHAR2(100);\"\n                    + \"BEGIN \"\n                    + \"    user_id_str := SYS_CONTEXT('USERENV', 'SESSION_USERID');\"\n                    + \"    RETURN 'id = ' || user_id_str OR '1=1';\"\n                    + \"END user_access_policy;\"\n                );\n                \n                // Apply VPD policy to users table\n                stmt.execute(\"\"\n                    + \"BEGIN DBMS_RLS.ADD_POLICY(\"\n                    + \"    object_schema => 'APP_USER',\"\n                    + \"    object_name => 'USERS',\"\n                    + \"    policy_name => 'USER_ACCESS_POLICY',\"\n                    + \"    function_schema => 'APP_USER',\"\n                    + \"    policy_function => 'USER_ACCESS_POLICY',\"\n                    + \"    statement_types => 'SELECT, UPDATE, DELETE',\"\n                    + \"    update_check => TRUE\"\n                    + \"); END;\"\n                );\n                \n                // Create indexes for performance and security\n                stmt.execute(\"CREATE INDEX idx_users_username ON users(username) TABLESPACE index_ts\");\n                stmt.execute(\"CREATE INDEX idx_users_email ON users(email) TABLESPACE index_ts\");\n                stmt.execute(\"CREATE INDEX idx_users_active ON users(is_active) TABLESPACE index_ts\");\n                stmt.execute(\"CREATE INDEX idx_audit_user ON audit_log(user_id) TABLESPACE index_ts\");\n                stmt.execute(\"CREATE INDEX idx_audit_created ON audit_log(created_at) TABLESPACE index_ts\");\n                \n                // Create secure procedure for user authentication\n                stmt.execute(\"\"\n                    + \"CREATE OR REPLACE PROCEDURE authenticate_user_proc(\"\n                    + \"    p_username IN VARCHAR2,\"\n                    + \"    p_password IN VARCHAR2,\"\n                    + \"    p_ip_address IN VARCHAR2,\"\n                    + \"    p_user_agent IN VARCHAR2,\"\n                    + \"    p_result OUT NUMBER,\"\n                    + \"    p_user_id OUT NUMBER\"\n                    + \") IS \"\n                    + \"    v_password_hash VARCHAR2(4000);\"\n                    + \"    v_user_id NUMBER;\"\n                    + \"    v_failed_attempts NUMBER;\"\n                    + \"    v_locked_until TIMESTAMP;\"\n                    + \"BEGIN \"\n                    + \"    -- Get user data with bind variables (secure)\"\n                    + \"    SELECT id, password_hash, failed_attempts, locked_into \"\n                    + \"    INTO v_user_id, v_password_hash, v_failed_attempts, v_locked_into \"\n                    + \"    FROM users \"\n                    + \"    WHERE username = p_username AND is_active = 'Y';\"\n                    + \"    \"\n                    + \"    IF v_user_id IS NULL THEN\"\n                    + \"        p_result := -1; -- User not found\"\n                    + \"        RETURN;\"\n                    + \"    END IF;\"\n                    + \"    \"\n                    + \"    -- Check account lock\"\n                    + \"    IF v_locked_until > SYSTIMESTAMP THEN\"\n                    + \"        p_result := -2; -- Account locked\"\n                    + \"        RETURN;\"\n                    + \"    END IF;\"\n                    + \"    \"\n                    + \"    -- Password verification (simplified - use proper hashing in production)\"\n                    + \"    IF DBMS_CRYPTO.HASH(UTL_I18N.STRING_TO_RAW(p_password, 'AL32UTF8'), DBMS_CRYPTO.HASH_SH512) = v_password_hash THEN\"\n                    + \"        -- Successful authentication\"\n                    + \"        UPDATE users SET last_login = SYSTIMESTAMP, failed_attempts = 0 WHERE id = v_user_id;\"\n                    + \"        p_result := 1;\"\n                    + \"        p_user_id := v_user_id;\"\n                    + \"    ELSE\"\n                    + \"        -- Failed authentication\"\n                    + \"        UPDATE users SET failed_attempts = failed_attempts + 1 WHERE id = v_user_id;\"\n                    + \"        p_result := 0;\"\n                    + \"    END IF;\"\n                    + \"    \"\n                    + \"EXCEPTION \"\n                    + \"    WHEN NO_DATA_FOUND THEN\"\n                    + \"        p_result := -1;\"\n                    + \"    WHEN OTHERS THEN\"\n                    + \"        p_result := -3; -- Database error\"\n                    + \"END authenticate_user_proc;\"\n                );\n                \n                // Grant necessary privileges to application user\n                stmt.execute(\"GRANT EXECUTE ON authenticate_user_proc TO APP_USER\");\n                stmt.execute(\"GRANT SELECT, INSERT, UPDATE ON users TO APP_USER\");\n                stmt.execute(\"GRANT SELECT, INSERT ON audit_log TO APP_USER\");\n                stmt.execute(\"GRANT SELECT ON user_seq TO APP_USER\");\n                stmt.execute(\"GRANT SELECT ON audit_seq TO APP_USER\");\n                \n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to initialize Oracle database\", e);\n        }\n    }\n}\n\n// ============================================\n// SECURE ORACLE USER SERVICE\n// ============================================\n\n@Service\n@Transactional\npublic class SecureOracleUserService {\n    private final DataSource dataSource;\n    private final PasswordEncoder passwordEncoder;\n    private final AuditService auditService;\n    \n    public SecureOracleUserService(DataSource dataSource, AuditService auditService) {\n        this.dataSource = dataSource;\n        this.passwordEncoder = new BCryptPasswordEncoder(12);\n        this.auditService = auditService;\n    }\n    \n    // Secure Oracle authentication using PL/SQL procedure\n    public Optional<User> authenticateUser(String username, String password, String ipAddress, String userAgent) {\n        // Input validation\n        if (!isValidInput(username, 50) || !isValidInput(password, 255)) {\n            auditService.logAuthenticationFailure(null, \"Invalid input format\", ipAddress);\n            return Optional.empty();\n        }\n        \n        try (Connection conn = dataSource.getConnection()) {\n            // Call secure PL/SQL procedure for authentication\n            try (CallableStatement stmt = conn.prepareCall(\n                \"{CALL authenticate_user_proc(?, ?, ?, ?, ?, ?)}\")) {\n                \n                // Bind variables (prevents SQL injection)\n                stmt.setString(1, username);\n                stmt.setString(2, password);\n                stmt.setString(3, ipAddress);\n                stmt.setString(4, userAgent);\n                stmt.registerOutParameter(5, Types.INTEGER); // p_result\n                stmt.registerOutParameter(6, Types.BIGINT);   // p_user_id\n                \n                stmt.execute();\n                \n                int result = stmt.getInt(5);\n                Long userId = stmt.getObject(6) != null ? stmt.getLong(6) : null;\n                \n                // Handle authentication result\n                switch (result) {\n                    case 1: // Success\n                        auditService.logAuthenticationSuccess(userId, \"User authenticated successfully\", ipAddress);\n                        return getUserById(userId, conn);\n                    case 0: // Invalid password\n                        auditService.logAuthenticationFailure(userId, \"Invalid password\", ipAddress);\n                        return Optional.empty();\n                    case -1: // User not found\n                        auditService.logAuthenticationFailure(null, \"User not found\", ipAddress);\n                        return Optional.empty();\n                    case -2: // Account locked\n                        auditService.logAuthenticationFailure(userId, \"Account locked\", ipAddress);\n                        return Optional.empty();\n                    default: // Database error\n                        auditService.logAuthenticationFailure(userId, \"Database error: \" + result, ipAddress);\n                        return Optional.empty();\n                }\n            }\n            \n        } catch (SQLException e) {\n            auditService.logAuthenticationFailure(null, \"Database exception: \" + e.getMessage(), ipAddress);\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n    \n    // Secure user creation with bind variables\n    public User createUser(UserRegistrationDTO registration, String ipAddress) {\n        // Validate input\n        if (!isValidUsername(registration.getUsername()) ||\n            !isValidEmail(registration.getEmail()) ||\n            !isValidPassword(registration.getPassword())) {\n            throw new IllegalArgumentException(\"Invalid user registration data\");\n        }\n        \n        try (Connection conn = dataSource.getConnection()) {\n            // Check if user exists using bind variables\n            if (userExists(registration.getUsername(), registration.getEmail(), conn)) {\n                throw new IllegalArgumentException(\"User already exists\");\n            }\n            \n            // Hash password\n            String passwordHash = passwordEncoder.encode(registration.getPassword());\n            \n            // Insert user using prepared statement with bind variables\n            String sql = \"\"\n                + \"INSERT INTO users (username, email, password_hash, role) \"\n                + \"VALUES (?, ?, ?, ?)\";\n            \n            try (PreparedStatement pstmt = conn.prepareStatement(sql, new String[]{\"id\"})) {\n                pstmt.setString(1, registration.getUsername());\n                pstmt.setString(2, registration.getEmail());\n                pstmt.setString(3, passwordHash);\n                pstmt.setString(4, \"USER\");\n                \n                int affectedRows = pstmt.executeUpdate();\n                if (affectedRows == 0) {\n                    throw new SQLException(\"Creating user failed, no rows affected.\");\n                }\n                \n                // Get generated ID\n                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {\n                    if (generatedKeys.next()) {\n                        Long userId = generatedKeys.getLong(1);\n                        \n                        // Audit user creation\n                        auditService.logUserCreation(userId, \"User created successfully\", ipAddress);\n                        \n                        return getUserById(userId, conn)\n                            .orElseThrow(() -> new RuntimeException(\"Failed to retrieve created user\"));\n                    } else {\n                        throw new SQLException(\"Creating user failed, no ID obtained.\");\n                    }\n                }\n            }\n            \n        } catch (SQLException e) {\n            auditService.logUserCreation(null, \"User creation failed: \" + e.getMessage(), ipAddress);\n            throw new RuntimeException(\"Failed to create user\", e);\n        }\n    }\n    \n    // Secure user search with bind variables\n    public List<User> searchUsers(String searchTerm, int maxResults, Long requestingUserId) {\n        if (!hasAdminRole(requestingUserId)) {\n            throw new AccessDeniedException(\"Unauthorized access\");\n        }\n        \n        if (!isValidInput(searchTerm, 100) || maxResults < 1 || maxResults > 100) {\n            throw new IllegalArgumentException(\"Invalid search parameters\");\n        }\n        \n        String sql = \"\"\n            + \"SELECT id, username, email, role, is_active, created_at, last_login \"\n            + \"FROM users \"\n            + \"WHERE (username LIKE ? OR email LIKE ?) AND is_active = 'Y' \"\n            + \"ORDER BY username \"\n            + \"FETCH FIRST ? ROWS ONLY\";\n        \n        List<User> users = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            // Bind variables prevent SQL injection\n            String searchPattern = \"%\" + searchTerm.toLowerCase() + \"%\";\n            pstmt.setString(1, searchPattern);\n            pstmt.setString(2, searchPattern);\n            pstmt.setInt(3, maxResults);\n            \n            try (ResultSet rs = pstmt.executeQuery()) {\n                while (rs.next()) {\n                    users.add(mapUserFromResultSet(rs));\n                }\n            }\n            \n        } catch (SQLException e) {\n            throw new RuntimeException(\"User search failed\", e);\n        }\n        \n        return users;\n    }\n    \n    // Helper methods\n    private boolean userExists(String username, String email, Connection conn) throws SQLException {\n        String sql = \"SELECT COUNT(*) FROM users WHERE username = ? OR email = ?\";\n        \n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username);\n            pstmt.setString(2, email);\n            \n            try (ResultSet rs = pstmt.executeQuery()) {\n                return rs.next() && rs.getInt(1) > 0;\n            }\n        }\n    }\n    \n    private Optional<User> getUserById(Long userId, Connection conn) throws SQLException {\n        String sql = \"\"\n            + \"SELECT id, username, email, role, is_active, created_at, last_login, failed_attempts, locked_until \"\n            + \"FROM users \"\n            + \"WHERE id = ?\";\n        \n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setLong(1, userId);\n            \n            try (ResultSet rs = pstmt.executeQuery()) {\n                if (rs.next()) {\n                    return Optional.of(mapUserFromResultSet(rs));\n                }\n            }\n        }\n        \n        return Optional.empty();\n    }\n    \n    private User mapUserFromResultSet(ResultSet rs) throws SQLException {\n        User user = new User();\n        user.setId(rs.getLong(\"id\"));\n        user.setUsername(rs.getString(\"username\"));\n        user.setEmail(rs.getString(\"email\"));\n        user.setRole(rs.getString(\"role\"));\n        user.setActive(\"Y\".equals(rs.getString(\"is_active\")));\n        user.setCreatedAt(rs.getTimestamp(\"created_at\"));\n        user.setLastLogin(rs.getTimestamp(\"last_login\"));\n        user.setFailedAttempts(rs.getInt(\"failed_attempts\"));\n        user.setLockedUntil(rs.getTimestamp(\"locked_until\"));\n        return user;\n    }\n    \n    private boolean isValidInput(String input, int maxLength) {\n        return input != null && \n               input.length() <= maxLength &&\n               !input.contains(\"'\") && \n               !input.contains(\"\\\"\") &&\n               !input.contains(\";\") &&\n               !input.contains(\"--\") &&\n               !input.contains(\"/*\") &&\n               !input.contains(\"*/\");\n    }\n    \n    private boolean isValidUsername(String username) {\n        return username != null && \n               username.matches(\"^[a-zA-Z0-9_]{3,50}$\");\n    }\n    \n    private boolean isValidEmail(String email) {\n        return email != null && \n               email.matches(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n    }\n    \n    private boolean isValidPassword(String password) {\n        return password != null && \n               password.length() >= 8 &&\n               password.matches(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\");\n    }\n}\n\n<!-- ============================================ -->\n<!-- ORACLE DATABASE SECURITY CONFIGURATION -->\n<!-- ============================================ -->\n\n/*\n-- Oracle Database Security Setup Script\n\n-- Create secure tablespaces\nCREATE TABLESPACE users_ts\n    DATAFILE 'users_ts.dbf' SIZE 100M\n    AUTOEXTEND ON NEXT 10M MAXSIZE UNLIMITED\n    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 64K\n    SEGMENT SPACE MANAGEMENT AUTO;\n\nCREATE TABLESPACE audit_ts\n    DATAFILE 'audit_ts.dbf' SIZE 50M\n    AUTOEXTEND ON NEXT 5M MAXSIZE 1G\n    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 64K\n    SEGMENT SPACE MANAGEMENT AUTO;\n\nCREATE TABLESPACE index_ts\n    DATAFILE 'index_ts.dbf' SIZE 50M\n    AUTOEXTEND ON NEXT 5M MAXSIZE 500M\n    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 64K\n    SEGMENT SPACE MANAGEMENT AUTO;\n\n-- Create secure application user\nCREATE USER app_user IDENTIFIED BY \"secure_password\";\nGRANT CREATE SESSION TO app_user;\nGRANT CREATE PROCEDURE TO app_user;\nGRANT CREATE SEQUENCE TO app_user;\nGRANT UNLIMITED TABLESPACE TO app_user;\n\n-- Enable Oracle Database Vault (if licensed)\nBEGIN DBMS_MACADM.CREATE_COMMAND_RULE(\n    command => 'DROP USER',\n    rule_set_name => 'Can Maintain Own Account',\n    object_owner => 'APP_USER',\n    object_name => '%',\n    enabled => 'YES');\nEND;\n/\n\n-- Configure Oracle Label Security (optional)\nBEGIN SA_USER_ADMIN.CREATE_USER(\n    user_name => 'APP_USER',\n    default_levels => 'TOP_SECRET',\n    default_compartments => 'FINANCIAL',\n    default_groups => 'ALL_ACCESS');\nEND;\n/\n\n-- Enable Unified Auditing for security\nBEGIN DBMS_AUDIT_MGMT.SET_AUDIT_TRAIL_PROPERTY(\n    audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,\n    audit_trail_property => DBMS_AUDIT_MGMT.AUDIT_TRAIL_ENABLE,\n    audit_trail_property_value => TRUE);\nEND;\n/\n\n-- Audit critical operations\nAUDIT ALL BY app_user BY ACCESS;\nAUDIT SELECT, INSERT, UPDATE, DELETE ON app_user.users BY ACCESS;\nAUDIT EXECUTE PROCEDURE ON app_user.authenticate_user_proc BY ACCESS;\n\n-- Configure Oracle Advanced Security\n-- Enable network encryption and integrity\nALTER SYSTEM SET SQLNET.ENCRYPTION_TYPES_SERVER = '(AES256,AES192,AES128)' SCOPE=SPFILE;\nALTER SYSTEM SET SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER = '(SHA1,SHA256,SHA384,SHA512)' SCOPE=SPFILE;\nALTER SYSTEM SET SQLNET.ENCRYPTION_SERVER = REQUIRED SCOPE=SPFILE;\nALTER SYSTEM SET SQLNET.CRYPTO_CHECKSUM_SERVER = REQUIRED SCOPE=SPFILE;\n\n-- Enable Oracle Flashback for data recovery\nALTER DATABASE ADD SUPPLEMENTAL LOG DATA;\nALTER DATABASE FLASHBACK ON;\n\n-- Configure connection security\nCREATE PROFILE app_profile LIMIT\n    FAILED_LOGIN_ATTEMPTS 5\n    PASSWORD_LOCK_TIME 1/24 -- 1 hour\n    PASSWORD_GRACE_TIME 7\n    PASSWORD_LIFE_TIME 90\n    PASSWORD_REUSE_TIME 365\n    PASSWORD_REUSE_MAX 10\n    SESSIONS_PER_USER 10\n    LOGICAL_READS_PER_SESSION 1000000\n    IDLE_TIME 30\n    CONNECT_TIME 60;\n\nALTER USER app_user PROFILE app_profile;\n\n-- Oracle RAC security configuration (if using RAC)\nALTER SYSTEM SET REMOTE_LOGIN_PASSWORDFILE = EXCLUSIVE SCOPE=SPFILE;\nALTER SYSTEM SET ENCRYPTION_WALLET_LOCATION =\n  '(SOURCE = (METHOD = FILE)(METHOD_DATA = (DIRECTORY = /etc/oracle/wallet)))' SCOPE=BOTH;\n\n-- Enable Transparent Data Encryption (TDE)\nALTER SYSTEM SET ENCRYPTION KEY IDENTIFIED BY \"wallet_password\";\nALTER TABLE app_user.users ENCRYPT;\nALTER TABLE app_user.audit_log ENCRYPT;\n\n-- Set up Real Application Security\nBEGIN ORDS.create_schema(\n    p_enabled => TRUE,\n    p_schema_url_prefix => 'app_',\n    p_schema_user => 'APP_USER',\n    p_schema_pwd => 'secure_password');\nEND;\n/\n\n-- Enable Oracle Data Safe for advanced security monitoring\nBEGIN DSA.create_user(\n    user_name => 'APP_USER',\n    user_type => 'APP');\nEND;\n/\n*/\n\n<!-- ============================================ -->\n<!-- ORACLE DATABASE CONNECTION PROPERTIES -->\n<!-- ============================================ -->\n\n/*\n# oracle-datasource.properties\n\n# Oracle UCP Configuration\noracle.ucp.jdbc.PoolDataSource.connectionFactoryClassName=oracle.jdbc.pool.OracleDataSource\noracle.ucp.jdbc.PoolDataSource.url=jdbc:oracle:thin:@//oracle-host:1521/SERVICE_NAME\noracle.ucp.jdbc.PoolDataSource.user=APP_USER\noracle.ucp.jdbc.PoolDataSource.password=secure_password\n\n# Connection Pool Settings\noracle.ucp.jdbc.PoolDataSource.initialPoolSize=5\noracle.ucp.jdbc.PoolDataSource.minPoolSize=5\noracle.ucp.jdbc.PoolDataSource.maxPoolSize=20\noracle.ucp.jdbc.PoolDataSource.validateConnectionOnBorrow=true\noracle.ucp.jdbc.PoolDataSource.abandonedConnectionTimeout=300\noracle.ucp.jdbc.PoolDataSource.timeToLiveConnectionTimeout=1200\noracle.ucp.jdbc.PoolDataSource.connectionPoolName=SecureOraclePool\n\n# Oracle Security Properties\noracle.net.CONNECT_TIMEOUT=5000\noracle.jdbc.ReadTimeout=30000\noracle.net.encryptTypes=(AES256)\noracle.net.crypto_checksum_client=REQUIRED\noracle.net.crypto_checksum_server=REQUIRED\noracle.net.encryption_client=REQUIRED\noracle.net.encryption_server=REQUIRED\n\n# Performance Settings\noracle.jdbc.defaultRowPrefetch=50\noracle.jdbc.defaultBatchValue=25\noracle.jdbc.defaultNChar=true\noracle.jdbc.fanEnabled=true\n\n# SSL/TLS Configuration (if required)\njavax.net.ssl.trustStore=/path/to/truststore.jks\njavax.net.ssl.trustStorePassword=truststore_password\njavax.net.ssl.keyStore=/path/to/keystore.jks\njavax.net.ssl.keyStorePassword=keystore_password\n\n# Oracle Advanced Security\noracle.net.tns_admin=/path/to/tns_admin\noracle.net.wallet_location=/path/to/wallet\n*/"
      }
    ]
  },
  {
    "pluginId": 40022,
    "title": "SQL Injection - PostgreSQL",
    "defaultRisk": "Critical",
    "cweid": "89",
    "description": "PostgreSQL SQL Injection occurs when untrusted input is concatenated into PostgreSQL SQL queries without proper parameterization. PostgreSQL has specific injection vulnerabilities including function calls (pg_sleep(), copy_to(), version()), command execution through COPY commands, PostgreSQL-specific syntax like -- comments, $$ string delimiters, UNION queries, and access to pg_catalog system tables that can bypass authentication, access sensitive data, or execute system commands.",
    "simplified_description": "Your application has a critical PostgreSQL database security flaw that allows attackers to inject malicious PostgreSQL commands. PostgreSQL is like a sophisticated information vault with advanced scripting capabilities - attackers can exploit this to not only read your data but also execute PostgreSQL functions to access system files, make the database sleep (causing denial of service), or even copy your entire database to remote locations. This can lead to complete data theft, system compromise, or service disruption.",
    "solution": "Implement PostgreSQL parameterized queries using bind variables, use PostgreSQL's binary protocol, disable dangerous PostgreSQL functions, implement row-level security (RLS), validate all inputs, and employ PostgreSQL-specific security features like pgcrypto for encryption and pgaudit for comprehensive auditing.",
    "simplified_solution": "Replace all SQL string concatenation with PostgreSQL prepared statements using bind variables. Use the PostgreSQL JDBC/ODBC drivers with binary protocol enabled. Create database users with minimal required privileges using PostgreSQL's role-based access control. Implement Row Level Security (RLS) policies for fine-grained data access control. Use pgcrypto for data encryption and pgaudit for comprehensive security auditing. Disable dangerous PostgreSQL functions like COPY TO/FROM PROGRAM. Enable statement logging and monitoring. Regularly apply PostgreSQL security updates.",
    "references": [
      {
        "name": "PostgreSQL Security Documentation",
        "url": "https://www.postgresql.org/docs/current/security.html"
      },
      {
        "name": "OWASP PostgreSQL SQL Injection Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
      },
      {
        "name": "PostgreSQL Row Level Security",
        "url": "https://www.postgresql.org/docs/current/ddl-rowsecurity.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Java PostgreSQL Secure Implementation",
        "solution_description": "Secure PostgreSQL implementation using HikariCP connection pooling, prepared statements with bind variables, PostgreSQL's Row Level Security (RLS), pgcrypto encryption, pgaudit logging, and comprehensive input validation with PostgreSQL-specific security configurations.",
        "affected_files": "PostgreSQL connection configuration (application.properties, pg_hba.conf), data access objects (DAO classes), security policies (RLS policies), migration scripts (Flyway), audit configuration (postgresql.conf)",
        "code": "// ============================================\n// SECURE POSTGRESQL CONNECTION CONFIGURATION\n// ============================================\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.postgresql.ds.PGSimpleDataSource;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport javax.sql.DataSource;\nimport java.sql.*;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class SecurePostgreSQLConfig {\n    \n    // PostgreSQL HikariCP with security settings\n    public static DataSource createSecurePostgreSQLDataSource() {\n        HikariConfig config = new HikariConfig();\n        \n        // PostgreSQL connection details\n        config.setJdbcUrl(\"jdbc:postgresql://localhost:5432/secureapp?sslmode=require&binaryTransferEnable=true\");\n        config.setUsername(\"app_user\");\n        config.setPassword(\"secure_password\");\n        config.setDriverClassName(\"org.postgresql.Driver\");\n        \n        // PostgreSQL-specific SSL configuration\n        config.addDataSourceProperty(\"ssl\", \"true\");\n        config.addDataSourceProperty(\"sslmode\", \"verify-full\");\n        config.addDataSourceProperty(\"sslrootcert\", \"/path/to/root.crt\");\n        config.addDataSourceProperty(\"sslcert\", \"/path/to/client.crt\");\n        config.addDataSourceProperty(\"sslkey\", \"/path/to/client.key\");\n        config.addDataSourceProperty(\"sslpassword\", \"client_key_password\");\n        \n        // PostgreSQL performance and security\n        config.addDataSourceProperty(\"binaryTransferEnable\", \"true\");\n        config.addDataSourceProperty(\"binaryTransferDisable\", \"\");\n        config.addDataSourceProperty(\"prepareThreshold\", \"5\");\n        config.addDataSourceProperty(\"preparedStatementCacheQueries\", \"256\");\n        config.addDataSourceProperty(\"preparedStatementCacheSizeMiB\", \"5\");\n        config.addDataSourceProperty(\"defaultRowFetchSize\", \"50\");\n        config.addDataSourceProperty(\"reWriteBatchedInserts\", \"true\");\n        config.addDataSourceProperty(\"loginTimeout\", \"30\");\n        config.addDataSourceProperty(\"connectTimeout\", \"30\");\n        config.addDataSourceProperty(\"socketTimeout\", \"30\");\n        \n        // Connection pool security settings\n        config.setMaximumPoolSize(20);\n        config.setMinimumIdle(5);\n        config.setConnectionTimeout(30000);\n        config.setIdleTimeout(600000);\n        config.setMaxLifetime(1800000);\n        config.setLeakDetectionThreshold(60000);\n        config.setConnectionTestQuery(\"SELECT 1\");\n        config.setPoolName(\"SecurePgPool\");\n        \n        return new HikariDataSource(config);\n    }\n    \n    // Initialize PostgreSQL database with security constraints\n    public static void initializePostgreSQLDatabase(DataSource dataSource) {\n        try (Connection conn = dataSource.getConnection();\n             Statement stmt = conn.createStatement()) {\n            \n            // Set PostgreSQL security parameters\n            stmt.execute(\"SET SESSION AUTHORIZATION app_user\");\n            stmt.execute(\"SET search_path TO app_schema\");\n            stmt.execute(\"SET timezone TO 'UTC'\");\n            \n            // Enable row-level security\n            stmt.execute(\"SET row_security = on\");\n            \n            // Create secure schema\n            try {\n                stmt.execute(\"DROP SCHEMA IF EXISTS app_schema CASCADE\");\n            } catch (SQLException e) {\n                // Schema might not exist, continue\n            }\n            stmt.execute(\"CREATE SCHEMA app_schema AUTHORIZATION app_user\");\n            stmt.execute(\"SET search_path TO app_schema\");\n            \n            // Enable pgcrypto extension for security functions\n            stmt.execute(\"CREATE EXTENSION IF NOT EXISTS pgcrypto\");\n            \n            // Enable pgaudit for comprehensive auditing\n            stmt.execute(\"CREATE EXTENSION IF NOT EXISTS pgaudit\");\n            \n            // Create secure user table with PostgreSQL features\n            stmt.execute(\"\"\n                + \"CREATE TABLE users (\"\n                + \"    id BIGSERIAL PRIMARY KEY,\"\n                + \"    username VARCHAR(50) NOT NULL UNIQUE,\"\n                + \"    email VARCHAR(255) NOT NULL UNIQUE,\"\n                + \"    password_hash VARCHAR(255) NOT NULL,\"\n                + \"    role VARCHAR(20) DEFAULT 'USER' CHECK (role IN ('USER', 'ADMIN', 'MANAGER')),\"n                + \"    is_active BOOLEAN DEFAULT TRUE,\"\n                + \"    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\"\n                + \"    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\"\n                + \"    last_login TIMESTAMP WITH TIME ZONE,\"\n                + \"    failed_attempts INTEGER DEFAULT 0 CHECK (failed_attempts >= 0 AND failed_attempts <= 10),\"\n                + \"    locked_until TIMESTAMP WITH TIME ZONE,\"\n                + \"    created_by BIGINT REFERENCES users(id),\"\n                + \"    CONSTRAINT chk_failed_attempts CHECK (failed_attempts >= 0)\"\n                + \")\"\n            );\n            \n            // Create audit log table with PostgreSQL features\n            stmt.execute(\"\"\n                + \"CREATE TABLE audit_log (\"\n                + \"    audit_id BIGSERIAL PRIMARY KEY,\"\n                + \"    user_id BIGINT REFERENCES users(id),\"\n                + \"    action VARCHAR(100) NOT NULL,\"\n                + \"    table_name VARCHAR(100),\"\n                + \"    record_id BIGINT,\"\n                + \"    old_values JSONB,\"\n                + \"    new_values JSONB,\"\n                + \"    ip_address INET,\"\n                + \"    user_agent TEXT,\"\n                + \"    session_id VARCHAR(100),\"\n                + \"    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\"\n                + \")\"\n            );\n            \n            // Create function for secure password hashing\n            stmt.execute(\"\"\n                + \"CREATE OR REPLACE FUNCTION secure_hash_password(password TEXT) \"\n                + \"RETURNS TEXT AS $$ \"\n                + \"BEGIN \"\n                + \"    RETURN crypt(password, gen_salt('bf', 12)); \"\n                + \"END; \"\n                + \"$$ LANGUAGE plpgsql SECURITY DEFINER\"\n            );\n            \n            // Create function for secure password verification\n            stmt.execute(\"\"\n                + \"CREATE OR REPLACE FUNCTION verify_password(password TEXT, hash TEXT) \"\n                + \"RETURNS BOOLEAN AS $$ \"\n                + \"BEGIN \"\n                + \"    RETURN (hash = crypt(password, hash)); \"\n                + \"END; \"\n                + \"$$ LANGUAGE plpgsql SECURITY DEFINER\"\n            );\n            \n            // Create Row Level Security (RLS) policy for users table\n            stmt.execute(\"ALTER TABLE users ENABLE ROW LEVEL SECURITY\");\n            \n            // Policy: Users can only see their own record, admins can see all\n            stmt.execute(\"\"\n                + \"CREATE POLICY user_isolation_policy ON users \"\n                + \"USING (\"\n                + \"    id = current_setting('app.current_user_id', true)::BIGINT \"\n                + \"    OR \"\n                + \"    current_setting('app.user_role', true) = 'ADMIN'\"\n                + \")\"\n            );\n            \n            // Policy for updates\n            stmt.execute(\"\"\n                + \"CREATE POLICY user_update_policy ON users \"\n                + \"FOR UPDATE \"\n                + \"USING (\"\n                + \"    id = current_setting('app.current_user_id', true)::BIGINT \"\n                + \"    OR \"\n                + \"    current_setting('app.user_role', true) = 'ADMIN'\"\n                + \") WITH CHECK (\"\n                + \"    id = current_setting('app.current_user_id', true)::BIGINT \"\n                + \"    OR \"\n                + \"    current_setting('app.user_role', true) = 'ADMIN'\"\n                + \")\"\n            );\n            \n            // Create trigger for audit logging\n            stmt.execute(\"\"\n                + \"CREATE OR REPLACE FUNCTION audit_trigger_function() \"\n                + \"RETURNS TRIGGER AS $$ \"\n                + \"BEGIN \"\n                + \"    IF TG_OP = 'INSERT' THEN \"\n                + \"        INSERT INTO audit_log (user_id, action, table_name, record_id, new_values) \"\n                + \"        VALUES (NEW.id, 'INSERT', TG_TABLE_NAME, NEW.id, row_to_json(NEW)); \"\n                + \"        RETURN NEW; \"\n                + \"    ELSIF TG_OP = 'UPDATE' THEN \"\n                + \"        INSERT INTO audit_log (user_id, action, table_name, record_id, old_values, new_values) \"\n                + \"        VALUES (NEW.id, 'UPDATE', TG_TABLE_NAME, NEW.id, row_to_json(OLD), row_to_json(NEW)); \"\n                + \"        RETURN NEW; \"\n                + \"    ELSIF TG_OP = 'DELETE' THEN \"\n                + \"        INSERT INTO audit_log (user_id, action, table_name, record_id, old_values) \"\n                + \"        VALUES (OLD.id, 'DELETE', TG_TABLE_NAME, OLD.id, row_to_json(OLD)); \"\n                + \"        RETURN OLD; \"\n                + \"    END IF; \"\n                + \"    RETURN NULL; \"\n                + \"END; \"\n                + \"$$ LANGUAGE plpgsql SECURITY DEFINER\"\n            );\n            \n            // Apply trigger to users table\n            stmt.execute(\"\"\n                + \"CREATE TRIGGER users_audit_trigger \"\n                + \"AFTER INSERT OR UPDATE OR DELETE ON users \"\n                + \"FOR EACH ROW EXECUTE FUNCTION audit_trigger_function()\"\n            );\n            \n            // Create indexes for performance and security\n            stmt.execute(\"CREATE INDEX idx_users_username ON users(username)\");\n            stmt.execute(\"CREATE INDEX idx_users_email ON users(email)\");\n            stmt.execute(\"CREATE INDEX idx_users_active ON users(is_active)\");\n            stmt.execute(\"CREATE INDEX idx_users_role ON users(role)\");\n            stmt.execute(\"CREATE INDEX idx_users_created_at ON users(created_at)\");\n            stmt.execute(\"CREATE INDEX idx_audit_user ON audit_log(user_id)\");\n            stmt.execute(\"CREATE INDEX idx_audit_created ON audit_log(created_at)\");\n            stmt.execute(\"CREATE INDEX idx_audit_action ON audit_log(action)\");\n            stmt.execute(\"CREATE INDEX idx_audit_table ON audit_log(table_name)\");\n            \n            // Create encrypted password storage function\n            stmt.execute(\"\"\n                + \"CREATE OR REPLACE FUNCTION create_user_secure(\"\n                + \"    p_username VARCHAR(50),\"\n                + \"    p_email VARCHAR(255),\"\n                + \"    p_password TEXT,\"\n                + \"    p_role VARCHAR(20) DEFAULT 'USER'\"\n                + \") RETURNS BIGINT AS $$ \"\n                + \"DECLARE \"\n                + \"    v_user_id BIGINT;\"\n                + \"    v_password_hash TEXT;\"\n                + \"BEGIN \"\n                + \"    -- Hash password using pgcrypto\"\n                + \"    v_password_hash := secure_hash_password(p_password);\"\n                + \"    \"\n                + \"    -- Insert user with bind variables (in function call)\"\n                + \"    INSERT INTO users (username, email, password_hash, role) \"\n                + \"    VALUES (p_username, p_email, v_password_hash, p_role) \"\n                + \"    RETURNING id INTO v_user_id;\"\n                + \"    \"\n                + \"    RETURN v_user_id;\"\n                + \"END; \"\n                + \"$$ LANGUAGE plpgsql SECURITY DEFINER\"\n            );\n            \n            // Grant necessary privileges\n            stmt.execute(\"GRANT USAGE ON SCHEMA app_schema TO app_user\");\n            stmt.execute(\"GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA app_schema TO app_user\");\n            stmt.execute(\"GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app_schema TO app_user\");\n            stmt.execute(\"GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA app_schema TO app_user\");\n            \n            // Create indexes for JSONB audit data\n            stmt.execute(\"CREATE INDEX idx_audit_old_values ON audit_log USING GIN (old_values)\");\n            stmt.execute(\"CREATE INDEX idx_audit_new_values ON audit_log USING GIN (new_values)\");\n            \n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to initialize PostgreSQL database\", e);\n        }\n    }\n}\n\n// ============================================\n// SECURE POSTGRESQL USER SERVICE\n// ============================================\n\n@Service\n@Transactional\npublic class SecurePostgreSQLUserService {\n    private final JdbcTemplate jdbcTemplate;\n    private final BCryptPasswordEncoder passwordEncoder;\n    private final AuditService auditService;\n    \n    public SecurePostgreSQLUserService(DataSource dataSource, AuditService auditService) {\n        this.jdbcTemplate = new JdbcTemplate(dataSource);\n        this.passwordEncoder = new BCryptPasswordEncoder(12);\n        this.auditService = auditService;\n    }\n    \n    // Secure authentication using PostgreSQL functions and prepared statements\n    public Optional<User> authenticateUser(String username, String password, String ipAddress, String userAgent) {\n        // Input validation\n        if (!isValidUsername(username) || !isValidPassword(password)) {\n            auditService.logAuthenticationFailure(null, \"Invalid input format\", ipAddress);\n            return Optional.empty();\n        }\n        \n        try {\n            // Set PostgreSQL session context for RLS\n            jdbcTemplate.execute(\"SET app.current_user_id = NULL\");\n            jdbcTemplate.execute(\"SET app.user_role = NULL\");\n            \n            // Secure query with prepared statement\n            String sql = \"\"\n                + \"SELECT id, username, email, password_hash, role, is_active, \"\n                + \"       failed_attempts, locked_until, created_at, last_login \"\n                + \"FROM app_schema.users \"\n                + \"WHERE username = ? AND is_active = TRUE\";\n            \n            List<User> users = jdbcTemplate.query(sql, new Object[]{username}, this::mapUser);\n            \n            if (users.isEmpty()) {\n                auditService.logAuthenticationFailure(null, \"User not found\", ipAddress);\n                return Optional.empty();\n            }\n            \n            User user = users.get(0);\n            \n            // Check account lock\n            if (user.getLockedUntil() != null && user.getLockedUntil().after(new Date())) {\n                auditService.logAuthenticationFailure(user.getId(), \"Account locked\", ipAddress);\n                return Optional.empty();\n            }\n            \n            // Use PostgreSQL's verify_password function\n            Boolean passwordValid = jdbcTemplate.queryForObject(\n                \"SELECT app_schema.verify_password(?, ?)\",\n                new Object[]{password, user.getPasswordHash()},\n                Boolean.class\n            );\n            \n            if (!Boolean.TRUE.equals(passwordValid)) {\n                incrementFailedAttempts(user.getId());\n                auditService.logAuthenticationFailure(user.getId(), \"Invalid password\", ipAddress);\n                return Optional.empty();\n            }\n            \n            // Successful authentication\n            resetFailedAttempts(user.getId());\n            updateLastLogin(user.getId());\n            auditService.logAuthenticationSuccess(user.getId(), \"User authenticated successfully\", ipAddress);\n            \n            // Set session context for subsequent operations\n            jdbcTemplate.execute(\"SET app.current_user_id = \" + user.getId());\n            jdbcTemplate.execute(\"SET app.user_role = '\" + user.getRole() + \"'\");\n            \n            // Return user without sensitive data\n            user.setPasswordHash(null);\n            return Optional.of(user);\n            \n        } catch (Exception e) {\n            auditService.logAuthenticationFailure(null, \"Database error: \" + e.getMessage(), ipAddress);\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n    \n    // Secure user creation using PostgreSQL functions\n    @Transactional\n    public User createUser(UserRegistrationDTO registration, String ipAddress) {\n        // Validate input\n        if (!isValidUsername(registration.getUsername()) ||\n            !isValidEmail(registration.getEmail()) ||\n            !isValidPassword(registration.getPassword())) {\n            throw new IllegalArgumentException(\"Invalid user registration data\");\n        }\n        \n        try {\n            // Check if user exists using prepared statement\n            if (userExists(registration.getUsername(), registration.getEmail())) {\n                throw new IllegalArgumentException(\"User already exists\");\n            }\n            \n            // Use PostgreSQL secure function for user creation\n            Long userId = jdbcTemplate.queryForObject(\n                \"SELECT app_schema.create_user_secure(?, ?, ?, ?)\",\n                new Object[]{\n                    registration.getUsername(),\n                    registration.getEmail(),\n                    registration.getPassword(),\n                    \"USER\"\n                },\n                Long.class\n            );\n            \n            if (userId == null) {\n                throw new RuntimeException(\"Failed to create user\");\n            }\n            \n            // Audit user creation\n            auditService.logUserCreation(userId, \"User created successfully\", ipAddress);\n            \n            // Return created user\n            return getUserById(userId).orElseThrow(() -> new RuntimeException(\"Failed to retrieve created user\"));\n            \n        } catch (DataAccessException e) {\n            auditService.logUserCreation(null, \"User creation failed: \" + e.getMessage(), ipAddress);\n            throw new RuntimeException(\"Failed to create user\", e);\n        }\n    }\n    \n    // Secure user search with RLS and bind variables\n    public Page<User> searchUsers(String searchTerm, int page, int size, Long requestingUserId) {\n        // Set session context for RLS\n        jdbcTemplate.execute(\"SET app.current_user_id = \" + requestingUserId);\n        jdbcTemplate.execute(\"SET app.user_role = '\" + getUserRole(requestingUserId) + \"'\");\n        \n        // Validate input\n        if (!isValidSearchTerm(searchTerm) || size < 1 || size > 100) {\n            throw new IllegalArgumentException(\"Invalid search parameters\");\n        }\n        \n        // Count total users (RLS will automatically filter based on context)\n        String countSql = \"\"\n            + \"SELECT COUNT(*) FROM app_schema.users \"\n            + \"WHERE (username ILIKE ? OR email ILIKE ?) AND is_active = TRUE\";\n        \n        Long totalCount = jdbcTemplate.queryForObject(\n            countSql, \n            new Object[]{\"%\" + searchTerm.toLowerCase() + \"%\", \"%\" + searchTerm.toLowerCase() + \"%\"}, \n            Long.class\n        );\n        \n        // Get paginated users with bind variables\n        String sql = \"\"\n            + \"SELECT id, username, email, role, is_active, created_at, last_login \"\n            + \"FROM app_schema.users \"\n            + \"WHERE (username ILIKE ? OR email ILIKE ?) AND is_active = TRUE \"\n            + \"ORDER BY username \"\n            + \"LIMIT ? OFFSET ?\";\n        \n        int offset = page * size;\n        List<User> users = jdbcTemplate.query(\n            sql, \n            new Object[]{\"%\" + searchTerm.toLowerCase() + \"%\", \"%\" + searchTerm.toLowerCase() + \"%\", size, offset}, \n            this::mapUser\n        );\n        \n        return new Page<>(users, totalCount, page, size);\n    }\n    \n    // Helper methods\n    private boolean userExists(String username, String email) {\n        String sql = \"SELECT COUNT(*) FROM app_schema.users WHERE username = ? OR email = ?\";\n        Long count = jdbcTemplate.queryForObject(sql, new Object[]{username, email}, Long.class);\n        return count != null && count > 0;\n    }\n    \n    private Optional<User> getUserById(Long userId) {\n        String sql = \"\"\n            + \"SELECT id, username, email, role, is_active, created_at, last_login, failed_attempts, locked_until \"\n            + \"FROM app_schema.users \"\n            + \"WHERE id = ?\";\n        \n        try {\n            List<User> users = jdbcTemplate.query(sql, new Object[]{userId}, this::mapUser);\n            return users.isEmpty() ? Optional.empty() : Optional.of(users.get(0));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    }\n    \n    private void incrementFailedAttempts(Long userId) {\n        String sql = \"\"\n            + \"UPDATE app_schema.users SET \"\n            + \"failed_attempts = failed_attempts + 1, \"\n            + \"locked_until = CASE \"\n            + \"    WHEN failed_attempts >= 4 THEN CURRENT_TIMESTAMP + INTERVAL '1 hour' \"\n            + \"    ELSE locked_until \"\n            + \"END \"\n            + \"WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private void resetFailedAttempts(Long userId) {\n        String sql = \"\"\n            + \"UPDATE app_schema.users SET \"\n            + \"failed_attempts = 0, \"\n            + \"locked_until = NULL \"\n            + \"WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private void updateLastLogin(Long userId) {\n        String sql = \"UPDATE app_schema.users SET last_login = CURRENT_TIMESTAMP WHERE id = ?\";\n        jdbcTemplate.update(sql, userId);\n    }\n    \n    private String getUserRole(Long userId) {\n        String sql = \"SELECT role FROM app_schema.users WHERE id = ?\";\n        return jdbcTemplate.queryForObject(sql, new Object[]{userId}, String.class);\n    }\n    \n    private User mapUser(ResultSet rs) throws SQLException {\n        User user = new User();\n        user.setId(rs.getLong(\"id\"));\n        user.setUsername(rs.getString(\"username\"));\n        user.setEmail(rs.getString(\"email\"));\n        user.setPasswordHash(rs.getString(\"password_hash\"));\n        user.setRole(rs.getString(\"role\"));\n        user.setActive(rs.getBoolean(\"is_active\"));\n        user.setCreatedAt(rs.getTimestamp(\"created_at\"));\n        user.setLastLogin(rs.getTimestamp(\"last_login\"));\n        user.setFailedAttempts(rs.getInt(\"failed_attempts\"));\n        user.setLockedUntil(rs.getTimestamp(\"locked_until\"));\n        return user;\n    }\n    \n    // Input validation methods\n    private boolean isValidUsername(String username) {\n        return username != null && \n               username.matches(\"^[a-zA-Z0-9_]{3,50}$\");\n    }\n    \n    private boolean isValidEmail(String email) {\n        return email != null && \n               email.matches(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\");\n    }\n    \n    private boolean isValidPassword(String password) {\n        return password != null && \n               password.length() >= 8 &&\n               password.matches(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\");\n    }\n    \n    private boolean isValidSearchTerm(String searchTerm) {\n        return searchTerm != null && \n               searchTerm.length() <= 100 &&\n               !searchTerm.contains(\"'\") && \n               !searchTerm.contains(\"\\\"\") &&\n               !searchTerm.contains(\";\");\n    }\n}\n\n<!-- ============================================ -->\n<!-- POSTGRESQL DATABASE SECURITY CONFIGURATION -->\n<!-- ============================================ -->\n\n/*\n-- PostgreSQL Security Configuration (postgresql.conf)\n\n# Connection Security\nssl = on\nssl_cert_file = '/var/lib/postgresql/12/main/server.crt'\nssl_key_file = '/var/lib/postgresql/12/main/server.key'\nssl_ca_file = '/var/lib/postgresql/12/main/root.crt'\nssl_crl_file = '/var/lib/postgresql/12/main/root.crl'\n\n# Logging and Auditing\nlogging_collector = on\nlog_directory = 'pg_log'\nlog_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\nlog_rotation_age = 1d\nlog_rotation_size = 100MB\nlog_min_messages = warning\nlog_min_error_statement = error\nlog_connections = on\nlog_disconnections = on\nlog_duration = on\nlog_statement = 'all'\nlog_min_duration_statement = 1000\n\n# pgAudit Configuration\nshared_preload_libraries = 'pgaudit'\npgaudit.log = 'all, -misc'\npgaudit.log_catalog = off\npgaudit.log_relation = on\npgaudit.log_parameter = on\npgaudit.log_statement_once = off\n\n# Row Level Security\nrow_security = on\n\n# Security Settings\ncheck_function_bodies = on\ndefault_transaction_isolation = 'read committed'\ndefault_transaction_read_only = off\ndefault_transaction_deferrable = off\n\n# Memory and Performance\nshared_buffers = 256MB\neffective_cache_size = 1GB\nwork_mem = 4MB\nmaintenance_work_mem = 64MB\n\n# pg_hba.conf (Client Authentication)\n\n# TYPE  DATABASE        USER            ADDRESS                 METHOD\n\n# Local connections\nlocal   all             postgres                                peer\nlocal   all             app_user                                md5\n\n# IPv4 local connections:\nhost    all             all             127.0.0.1/32            md5\n\n# IPv6 local connections:\nhost    all             all             ::1/128                 md5\n\n# Require SSL for remote connections\nhostssl all             app_user        0.0.0.0/0               md5\nhostssl all             app_user        ::/0                    md5\n\n# Replication connections\nhost    replication     replicator      0.0.0.0/0               md5\n\n-- PostgreSQL User and Security Setup\n\n-- Create secure application user\nCREATE USER app_user WITH PASSWORD 'secure_password' NOSUPERUSER NOCREATEDB NOCREATEROLE;\n\n-- Create admin user for database management\nCREATE USER app_admin WITH PASSWORD 'admin_password' SUPERUSER CREATEDB CREATEROLE;\n\n-- Create schema for application\nCREATE SCHEMA app_schema AUTHORIZATION app_user;\n\n-- Set search path for application user\nALTER ROLE app_user SET search_path TO app_schema, public;\n\n-- Grant necessary privileges to application user\nGRANT CONNECT ON DATABASE secureapp TO app_user;\nGRANT USAGE ON SCHEMA app_schema TO app_user;\nGRANT CREATE ON SCHEMA app_schema TO app_user;\n\n-- Configure Row Level Security\nALTER ROLE app_user SET row_security = on;\n\n-- PostgreSQL Extensions Setup\n\n-- Enable pgcrypto for cryptographic functions\nCREATE EXTENSION IF NOT EXISTS pgcrypto SCHEMA app_schema;\n\n-- Enable pgaudit for comprehensive auditing\nCREATE EXTENSION IF NOT EXISTS pgaudit;\n\n-- Enable pg_stat_statements for query monitoring\nCREATE EXTENSION IF NOT EXISTS pg_stat_statements;\n\n-- PostgreSQL Security Functions\n\n-- Function to securely hash passwords\nCREATE OR REPLACE FUNCTION app_schema.secure_hash_password(password TEXT)\nRETURNS TEXT AS $$\nBEGIN\n    RETURN crypt(password, gen_salt('bf', 12));\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to verify passwords\nCREATE OR REPLACE FUNCTION app_schema.verify_password(password TEXT, hash TEXT)\nRETURNS BOOLEAN AS $$\nBEGIN\n    RETURN (hash = crypt(password, hash));\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Audit trigger function\nCREATE OR REPLACE FUNCTION app_schema.audit_trigger_function()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        INSERT INTO app_schema.audit_log (user_id, action, table_name, record_id, new_values)\n        VALUES (NEW.id, 'INSERT', TG_TABLE_NAME, NEW.id, row_to_json(NEW));\n        RETURN NEW;\n    ELSIF TG_OP = 'UPDATE' THEN\n        INSERT INTO app_schema.audit_log (user_id, action, table_name, record_id, old_values, new_values)\n        VALUES (NEW.id, 'UPDATE', TG_TABLE_NAME, NEW.id, row_to_json(OLD), row_to_json(NEW));\n        RETURN NEW;\n    ELSIF TG_OP = 'DELETE' THEN\n        INSERT INTO app_schema.audit_log (user_id, action, table_name, record_id, old_values)\n        VALUES (OLD.id, 'DELETE', TG_TABLE_NAME, OLD.id, row_to_json(OLD));\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- PostgreSQL Security Monitoring\n\n-- View to monitor failed login attempts\nCREATE OR REPLACE VIEW app_schema.failed_login_attempts AS\nSELECT \n    user_id,\n    COUNT(*) as attempt_count,\n    MAX(created_at) as last_attempt,\n    MIN(created_at) as first_attempt\nFROM app_schema.audit_log \nWHERE action LIKE '%FAILED%'\nGROUP BY user_id\nORDER BY attempt_count DESC;\n\n-- View to monitor privileged operations\nCREATE OR REPLACE VIEW app_schema.privileged_operations AS\nSELECT \n    user_id,\n    action,\n    table_name,\n    record_id,\n    created_at,\n    ip_address\nFROM app_schema.audit_log \nWHERE action IN ('DELETE', 'UPDATE', 'INSERT')\n  AND table_name IN ('users', 'audit_log')\nORDER BY created_at DESC;\n\n-- PostgreSQL Security Constraints\n\n-- Function to validate input parameters\nCREATE OR REPLACE FUNCTION app_schema.validate_input(input TEXT, max_length INTEGER DEFAULT 255)\nRETURNS BOOLEAN AS $$\nBEGIN\n    IF input IS NULL THEN\n        RETURN FALSE;\n    END IF;\n    \n    IF length(input) > max_length THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check for dangerous SQL injection patterns\n    IF input ~* '[\\'\\\";]|(--)|(\\\\/\\\\*)|(\\\\*\\\\/)' THEN\n        RETURN FALSE;\n    END IF;\n    \n    RETURN TRUE;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- PostgreSQL Backup and Recovery\n\n-- Function to create encrypted backup\nCREATE OR REPLACE FUNCTION app_schema.create_encrypted_backup()\nRETURNS TEXT AS $$\nDECLARE\n    backup_file TEXT;\nBEGIN\n    -- This would typically call pg_dump with encryption\n    backup_file := '/var/backups/postgresql/secureapp_' || to_char(now(), 'YYYY-MM-DD_HH24-MI-SS') || '.sql.gpg';\n    \n    -- In production, this would execute pg_dump with GPG encryption\n    -- EXECUTE 'pg_dump -U app_user -h localhost secureapp | gpg --symmetric --cipher-algo AES256 --compress-algo 1 --output ' || backup_file;\n    \n    RETURN backup_file;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n*/\n\n<!-- ============================================ -->\n<!-- SPRING BOOT POSTGRESQL CONFIGURATION -->\n<!-- ============================================ -->\n\n/*\n# application.properties - PostgreSQL Configuration\n\n# PostgreSQL Database Configuration\nspring.datasource.url=jdbc:postgresql://localhost:5432/secureapp?sslmode=require&binaryTransferEnable=true&prepareThreshold=5\nspring.datasource.username=app_user\nspring.datasource.password=secure_password\nspring.datasource.driver-class-name=org.postgresql.Driver\n\n# PostgreSQL SSL Configuration\nspring.datasource.properties.ssl=true\nspring.datasource.properties.sslmode=verify-full\nspring.datasource.properties.sslrootcert=/path/to/root.crt\nspring.datasource.properties.sslcert=/path/to/client.crt\nspring.datasource.properties.sslkey=/path/to/client.key\nspring.datasource.properties.sslpassword=client_key_password\n\n# PostgreSQL Performance Settings\nspring.datasource.properties.binaryTransferEnable=true\nspring.datasource.properties.binaryTransferDisable=\nspring.datasource.properties.prepareThreshold=5\nspring.datasource.properties.preparedStatementCacheQueries=256\nspring.datasource.properties.preparedStatementCacheSizeMiB=5\nspring.datasource.properties.defaultRowFetchSize=50\nspring.datasource.properties.reWriteBatchedInserts=true\nspring.datasource.properties.loginTimeout=30\nspring.datasource.properties.connectTimeout=30\nspring.datasource.properties.socketTimeout=30\n\n# HikariCP Connection Pool Settings\nspring.datasource.hikari.maximum-pool-size=20\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.connection-timeout=30000\nspring.datasource.hikari.idle-timeout=600000\nspring.datasource.hikari.max-lifetime=1800000\nspring.datasource.hikari.leak-detection-threshold=60000\nspring.datasource.hikari.pool-name=SecurePgPool\n\n# JPA/Hibernate Configuration with PostgreSQL\nspring.jpa.hibernate.ddl-auto=validate\nspring.jpa.show-sql=false\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\nspring.jpa.properties.hibernate.jdbc.batch_size=20\nspring.jpa.properties.hibernate.order_inserts=true\nspring.jpa.properties.hibernate.order_updates=true\nspring.jpa.properties.hibernate.jdbc.batch_versioned_data=true\nspring.jpa.properties.hibernate.connection.provider_disables_autocommit=true\nspring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true\n\n# PostgreSQL Schema Configuration\nspring.jpa.properties.hibernate.default_schema=app_schema\nspring.jpa.properties.hibernate.schema_update=true\n\n# Security Settings\nserver.servlet.session.cookie.http-only=true\nserver.servlet.session.cookie.secure=true\nserver.servlet.session.cookie.same-site=strict\nserver.servlet.session.timeout=30m\n\n# Logging\nlogging.level.org.springframework.security=DEBUG\nlogging.level.com.yourapp.audit=INFO\nlogging.level.org.postgresql=WARN\nlogging.level.org.postgresql.Driver=WARN\n\n# Health Checks\nmanagement.health.db.enabled=true\nmanagement.health.probes.enabled=true\n*/"
      }
    ]
  },
  {
    "pluginId": 40026,
    "title": "Cross Site Scripting (DOM Based)",
    "defaultRisk": "Medium",
    "cweid": "79",
    "description": "DOM-based Cross Site Scripting vulnerabilities occur when client-side scripts modify the DOM with unsafe user input, allowing malicious code execution entirely in the browser without server interaction.",
    "simplified_description": "Your website has a security vulnerability that allows attackers to execute malicious code directly in users' browsers by manipulating how the webpage is displayed. This is like having a blueprint that attackers can modify to change how your building looks - they can steal information or take control of what users see.",
    "solution": "Implement proper input validation, use safe DOM manipulation methods, avoid eval() and similar functions, use modern frameworks with built-in XSS protection, and implement Content Security Policy.",
    "simplified_solution": "Validate and sanitize all user input before using it to modify webpage content, use safe JavaScript methods like textContent instead of innerHTML, avoid dangerous functions like eval(), implement Content Security Policy headers, and use modern frameworks that automatically protect against DOM-based attacks.",
    "references": [
      {
        "name": "OWASP DOM-based XSS Prevention",
        "url": "https://owasp.org/www-community/attacks/DOM_Based_XSS"
      },
      {
        "name": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "url": "https://cwe.mitre.org/data/definitions/79.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "DOM-based XSS Prevention",
        "solution_description": "Comprehensive DOM-based XSS prevention including safe DOM manipulation, input validation, and secure JavaScript practices.",
        "affected_files": "JavaScript files, client-side scripts, single-page applications, dynamic content manipulation code",
        "code": "// ==========================\n// SECURE DOM MANIPULATION UTILITIES\n// ==========================\nclass SecureDOMUtils {\n    \n    // Safely set text content (prevents XSS)\n    static setSafeText(element, text) {\n        if (element && typeof text === 'string') {\n            element.textContent = text;\n        }\n    }\n    \n    // Safely set HTML content with sanitization\n    static setSafeHTML(element, html) {\n        if (!element || typeof html !== 'string') {\n            return;\n        }\n        \n        // Basic HTML sanitization - use DOMPurify in production\n        const sanitizedHTML = this.sanitizeHTML(html);\n        element.innerHTML = sanitizedHTML;\n    }\n    \n    // Basic HTML sanitization function\n    static sanitizeHTML(html) {\n        const tempDiv = document.createElement('div');\n        tempDiv.textContent = html;\n        return tempDiv.innerHTML;\n    }\n    \n    // Safely update URL without injection risk\n    static updateURLParameter(param, value) {\n        if (typeof param !== 'string' || typeof value !== 'string') {\n            return;\n        }\n        \n        const url = new URL(window.location);\n        url.searchParams.set(param, encodeURIComponent(value));\n        window.history.replaceState({}, '', url);\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 40032,
    "title": ".htaccess Information Leak",
    "defaultRisk": "Medium",
    "cweid": 538,
    "description": "The Apache .htaccess file is accessible from the web, revealing sensitive server configuration information including authentication settings, URL rewrite rules, directory permissions, and security configurations that can assist attackers in planning attacks against the application.",
    "simplified_description": "Your website's configuration file (.htaccess) is publicly accessible, like leaving your security system blueprint on public display. Attackers can read this file to understand your security settings, find hidden directories, discover authentication bypass methods, and plan targeted attacks against your website.",
    "solution": "Configure the web server to deny access to .htaccess files and other sensitive configuration files. Implement proper file permissions, use .htaccess to block access to configuration files, and ensure Apache is configured to protect sensitive files by default. Also consider moving sensitive configuration to server configuration files instead of .htaccess.",
    "simplified_solution": "Configure your web server to block access to .htaccess files and other sensitive configuration files. Update your Apache configuration to deny access to files starting with a dot (.ht*), set proper file permissions, and test that these files are no longer accessible from the web. Move sensitive information from .htaccess to secure server configuration files.",
    "references": [
      {
        "name": "Apache .htaccess Files Documentation",
        "url": "https://httpd.apache.org/docs/current/howto/htaccess.html"
      },
      {
        "name": "OWASP Information Exposure",
        "url": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"
      },
      {
        "name": "CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory",
        "url": "https://cwe.mitre.org/data/definitions/538.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Apache Server Security Configuration",
        "solution_description": "This comprehensive solution addresses .htaccess information disclosure by implementing multiple layers of protection. It includes Apache main server configuration, .htaccess protection mechanisms, file permission hardening, access controls for sensitive files, and automated monitoring. The solution covers both prevention and detection of configuration file exposure.",
        "affected_files": "/etc/apache2/apache2.conf, /etc/apache2/conf-available/security.conf, /etc/apache2/sites-available/*.conf, .htaccess files, Apache main configuration files",
        "code": "# Apache .htaccess Information Leak Protection\n# Comprehensive Security Configuration\n\n# ======================================\n# APACHE MAIN SERVER CONFIGURATION\n# ======================================\n\n# /etc/apache2/apache2.conf or /etc/httpd/conf/httpd.conf\n\n# Block access to configuration and sensitive files\n<FilesMatch \"^\\.ht\">\n    Require all denied\n</FilesMatch>\n\n# Extended protection for various configuration files\n<FilesMatch \"\\.(htaccess|htpasswd|ini|log|sh|sql|bak|backup|old|tmp|env|config|conf)$\">\n    Require all denied\n</FilesMatch>\n\n# Block access to version control files\n<FilesMatch \"\\.(svn|git|hg)\">\n    Require all denied\n</FilesMatch>\n\n# Block access to development files\n<FilesMatch \"\\.(dev|test|staging|local)\">\n    Require all denied\n</FilesMatch>\n\n# Prevent directory listing globally\n<Directory /var/www/>\n    Options -Indexes\n    AllowOverride None\n    Require all granted\n</Directory>\n\n# Specific web directory configuration\n<Directory /var/www/html>\n    Options FollowSymLinks\n    AllowOverride None  # Disable .htaccess in production\n    Require all granted\n    \n    # Security headers\n    Header always set X-Content-Type-Options nosniff\n    Header always set X-Frame-Options DENY\n    Header always set X-XSS-Protection \"1; mode=block\"\n    Header always set Referrer-Policy \"strict-origin-when-cross-origin\"\n</Directory>\n\n# ======================================\n# ENHANCED SECURITY CONFIGURATION\n# ======================================\n\n# /etc/apache2/conf-available/security.conf\n\n# Security: Block access to sensitive files\n<DirectoryMatch \"/\\.svn/\">\n    Require all denied\n</DirectoryMatch>\n\n<DirectoryMatch \"/\\.git/\">\n    Require all denied\n</DirectoryMatch>\n\n<DirectoryMatch \"/\\.hg/\">\n    Require all denied\n</DirectoryMatch>\n\n# Block access to backup and temporary files\n<LocationMatch \"\\.(bak|backup|old|tmp|log|sql|ini|conf|config)\">\n    Require all denied\n</LocationMatch>\n\n# Block access to common web application config files\n<LocationMatch \"(wp-config|config\\.php|database\\.yml|settings\\.php|\\.env)$\">\n    Require all denied\n</LocationMatch>\n\n# Prevent access to Apache configuration files\n<Files \"apache2.conf\">\n    Require all denied\n</Files>\n\n<Files \"httpd.conf\">\n    Require all denied\n</Files>\n\n# ======================================\n# VIRTUAL HOST SECURITY CONFIGURATION\n# ======================================\n\n# /etc/apache2/sites-available/000-default.conf\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # Enhanced security configuration\n    <Directory \"/var/www/html\">\n        Options FollowSymLinks\n        AllowOverride None  # Critical: Disable .htaccess\n        Require all granted\n        \n        # Prevent directory listing\n        Options -Indexes\n        \n        # Don't serve .htaccess and other hidden files\n        <FilesMatch \"^\\.\">\n            Require all denied\n        </FilesMatch>\n        \n        # Block specific sensitive file extensions\n        <FilesMatch \"\\.(htaccess|htpasswd|ini|log|sql|bak|backup|old|tmp|env|config|conf)$\">\n            Require all denied\n        </FilesMatch>\n    </Directory>\n    \n    # Global security rules\n    <Location \"/\">\n        # Block common sensitive files\n        RewriteEngine On\n        \n        # Block .htaccess files\n        RewriteRule \\.htaccess$ - [F,L]\n        \n        # Block configuration files\n        RewriteRule \\.(htpasswd|ini|log|sql|bak|backup|old|tmp|env|config|conf)$ - [F,L]\n        \n        # Block version control directories\n        RewriteRule (\\.svn|\\.git|\\.hg)/ - [F,L]\n    </Location>\n    \n    # Logging for security monitoring\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n    \n    # Additional security logging\n    CustomLog ${APACHE_LOG_DIR}/security.log \"%h %l %u %t \\\"%r\\\" %>s %b \\\"%{User-Agent}i\\\"\" env=blocked_request\n</VirtualHost>\n\n# ======================================\n# .HTACCESS PROTECTION MECHANISMS\n# ======================================\n\n# If you must use .htaccess, include these protection rules\n# .htaccess file in web root\n\n# Block access to .htaccess itself\n<Files .htaccess>\n    Require all denied\n</Files>\n\n# Block access to all hidden files\n<FilesMatch \"^\\.\">\n    Require all denied\n</FilesMatch>\n\n# Prevent directory listing\nOptions -Indexes\n\n# Server signature protection\nServerSignature Off\n\n# Remove server tokens\nServerTokens Prod\n\n# ======================================\n# FILE PERMISSION HARDENING\n# ======================================\n\n#!/bin/bash\n# File permission hardening script\n\n# Set proper ownership\nsudo chown -R root:www-data /etc/apache2\nsudo chown -R www-data:www-data /var/www\n\n# Secure configuration files\nsudo chmod 640 /etc/apache2/apache2.conf\nsudo chmod 640 /etc/apache2/conf-available/*.conf\nsudo chmod 640 /etc/apache2/sites-available/*.conf\n\n# Secure .htaccess files\nfind /var/www -name \".htaccess\" -exec chmod 640 {} \\;\nfind /var/www -name \".htaccess\" -exec chown www-data:www-data {} \\;\n\n# Secure other sensitive files\nfind /var/www -name \"*.conf\" -exec chmod 640 {} \\;\nfind /var/www -name \"*.ini\" -exec chmod 640 {} \\;\nfind /var/www -name \"*.log\" -exec chmod 640 {} \\;\n\n# Secure backup and temporary files\nfind /var/www -name \"*.bak\" -exec chmod 600 {} \\;\nfind /var/www -name \"*.old\" -exec chmod 600 {} \\;\nfind /var/www -name \"*.tmp\" -exec chmod 600 {} \\;\n\n# ======================================\n# MODSECURITY CONFIGURATION\n# ======================================\n\n# /etc/modsecurity/modsecurity.conf\n\n# Enable ModSecurity\nSecRuleEngine On\n\n# Block access to .htaccess files\nSecRule REQUEST_URI \"@streq .htaccess\" \"phase:1,log,deny,id:1001,status:403,msg:'Access to .htaccess file blocked'\"\n\n# Block access to sensitive configuration files\nSecRule REQUEST_URI \"@rx \\.(htpasswd|ini|log|sql|bak|backup|old|tmp|env|config|conf)$\" \"phase:1,log,deny,id:1002,status:403,msg:'Access to sensitive file blocked'\"\n\n# Block access to version control files\nSecRule REQUEST_URI \"@rx (\\.svn|\\.git|\\.hg)/\" \"phase:1,log,deny,id:1003,status:403,msg:'Access to version control directory blocked'\"\n\n# Monitor for attempts to access hidden files\nSecRule REQUEST_URI \"@rx ^/\\.\" \"phase:1,log,id:1004,msg:'Access to hidden file attempted'\"\n\n# ======================================\n# AUTOMATED MONITORING AND DETECTION\n# ======================================\n\n#!/bin/bash\n# Monitor for .htaccess access attempts\n\nLOG_FILE=\"/var/log/apache2/access.log\"\nALERT_EMAIL=\"admin@example.com\"\nALERT_THRESHOLD=5\nTIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')\n\necho \"[$TIMESTAMP] Starting .htaccess access monitoring\"\n\n# Check for recent .htaccess access attempts\nHTACCESS_COUNT=$(grep \"\\.htaccess\" \"$LOG_FILE\" | grep \"$(date '+%d/%b/%Y:%H' -d '1 hour ago')\" | wc -l)\n\nif [ $HTACCESS_COUNT -gt 0 ]; then\n    echo \"ALERT: $HTACCESS_COUNT .htaccess access attempts detected\"\n    \n    # Show recent attempts\n    echo \"Recent attempts:\"\n    grep \"\\.htaccess\" \"$LOG_FILE\" | grep \"$(date '+%d/%b/%Y:%H' -d '1 hour ago')\" | tail -10\n    \n    # Send alert if threshold exceeded\n    if [ $HTACCESS_COUNT -gt $ALERT_THRESHOLD ]; then\n        echo \"HIGH ALERT: Threshold exceeded. Sending notification.\"\n        \n        ALERT_MSG=\"High number of .htaccess access attempts detected on $(hostname).\\n\\nAttempts in last hour: $HTACCESS_COUNT\\n\\nRecent attempts:\\n$(grep \"\\.htaccess\" \"$LOG_FILE\" | grep \"$(date '+%d/%b/%Y:%H' -d '1 hour ago')\" | tail -5)\"\n        \n        echo \"$ALERT_MSG\" | mail -s \"Security Alert: .htaccess Access Attempts\" \"$ALERT_EMAIL\"\n    fi\nfi\n\n# Check for other sensitive file access\nSENSITIVE_PATTERNS=(\"htpasswd\" \"config\" \"backup\" \"sql\" \"ini\")\n\nfor pattern in \"${SENSITIVE_PATTERNS[@]}\"; do\n    COUNT=$(grep \"$pattern\" \"$LOG_FILE\" | grep \"$(date '+%d/%b/%Y:%H' -d '1 hour ago')\" | wc -l)\n    \n    if [ $COUNT -gt $ALERT_THRESHOLD ]; then\n        echo \"ALERT: $COUNT $pattern file access attempts detected\"\n    fi\ndone\n\n# ======================================\n# TESTING AND VALIDATION\n# ======================================\n\n#!/bin/bash\n# Test .htaccess protection configuration\n\necho \"=== .htaccess Protection Test ===\"\nDOMAIN=\"example.com\"\n\n# Test 1: Try to access .htaccess file directly\necho \"\\n1. Testing direct .htaccess access:\"\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" \"https://$DOMAIN/.htaccess\")\nif [ \"$HTTP_CODE\" = \"403\" ] || [ \"$HTTP_CODE\" = \"404\" ]; then\n    echo \"✓ .htaccess file properly protected (HTTP $HTTP_CODE)\"\nelse\n    echo \"✗ .htaccess file accessible (HTTP $HTTP_CODE) - VULNERABILITY DETECTED\"\nfi\n\n# Test 2: Try to access .htpasswd file\necho \"\\n2. Testing .htpasswd access:\"\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" \"https://$DOMAIN/.htpasswd\")\nif [ \"$HTTP_CODE\" = \"403\" ] || [ \"$HTTP_CODE\" = \"404\" ]; then\n    echo \"✓ .htpasswd file properly protected (HTTP $HTTP_CODE)\"\nelse\n    echo \"✗ .htpasswd file accessible (HTTP $HTTP_CODE) - VULNERABILITY DETECTED\"\nfi\n\n# Test 3: Try to access configuration files\necho \"\\n3. Testing configuration file access:\"\nCONFIG_FILES=(\"config.ini\" \"database.conf\" \"settings.php\" \".env\")\n\nfor file in \"${CONFIG_FILES[@]}\"; do\n    HTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" \"https://$DOMAIN/$file\")\n    if [ \"$HTTP_CODE\" = \"403\" ] || [ \"$HTTP_CODE\" = \"404\" ]; then\n        echo \"✓ $file properly protected (HTTP $HTTP_CODE)\"\n    else\n        echo \"✗ $file accessible (HTTP $HTTP_CODE) - VULNERABILITY DETECTED\"\n    fi\ndone\n\n# Test 4: Try directory listing\necho \"\\n4. Testing directory listing:\"\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" \"https://$DOMAIN/images/\")\nif curl -s \"https://$DOMAIN/images/\" | grep -q \"Index of\"; then\n    echo \"✗ Directory listing enabled - VULNERABILITY DETECTED\"\nelse\n    echo \"✓ Directory listing disabled\"\nfi\n\n# Test 5: Check for hidden files access\necho \"\\n5. Testing hidden files access:\"\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" \"https://$DOMAIN/.hidden\")\nif [ \"$HTTP_CODE\" = \"403\" ] || [ \"$HTTP_CODE\" = \"404\" ]; then\n    echo \"✓ Hidden files properly protected (HTTP $HTTP_CODE)\"\nelse\n    echo \"✗ Hidden files accessible (HTTP $HTTP_CODE) - VULNERABILITY DETECTED\"\nfi\n\n# Test 6: Check server signature\necho \"\\n6. Testing server signature:\"\nSIGNATURE=$(curl -s \"https://$DOMAIN/nonexistent\" | grep -i \"apache\\|server at\")\nif [ -n \"$SIGNATURE\" ]; then\n    echo \"⚠ Server signature exposed:\"\n    echo \"$SIGNATURE\"\nelse\n    echo \"✓ Server signature properly hidden\"\nfi\n\necho \"\\n=== Test Complete ===\"\n\n# ======================================\n# CONTINUOUS SECURITY MONITORING\n# ======================================\n\n# /etc/cron.d/apache_security_monitor\n# Monitor every 30 minutes\n*/30 * * * * root /usr/local/bin/apache_security_monitor.sh\n\n#!/bin/bash\n# /usr/local/bin/apache_security_monitor.sh\n\nLOG_FILE=\"/var/log/apache2/security_monitor.log\"\nACCESS_LOG=\"/var/log/apache2/access.log\"\nTIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')\n\nlog_message() {\n    echo \"[$TIMESTAMP] $1\" >> $LOG_FILE\n}\n\n# Check for .htaccess access attempts\nHTACCESS_ATTEMPTS=$(grep \"\\.htaccess\" \"$ACCESS_LOG\" | grep \"$(date '+%d/%b/%Y:%H' -d '30 minutes ago')\" | wc -l)\nif [ $HTACCESS_ATTEMPTS -gt 0 ]; then\n    log_message \"ALERT: $HTACCESS_ATTEMPTS .htaccess access attempts in last 30 minutes\"\nfi\n\n# Check for sensitive file access attempts\nSENSITIVE_ATTEMPTS=$(grep -E \"\\.(htpasswd|ini|log|sql|bak|backup|old|tmp|env|config|conf)$\" \"$ACCESS_LOG\" | grep \"$(date '+%d/%b/%Y:%H' -d '30 minutes ago')\" | wc -l)\nif [ $SENSITIVE_ATTEMPTS -gt 5 ]; then\n    log_message \"ALERT: $SENSITIVE_ATTEMPTS sensitive file access attempts in last 30 minutes\"\nfi\n\n# Check for version control access attempts\nVCS_ATTEMPTS=$(grep -E \"(\\.svn|\\.git|\\.hg)/\" \"$ACCESS_LOG\" | grep \"$(date '+%d/%b/%Y:%H' -d '30 minutes ago')\" | wc -l)\nif [ $VCS_ATTEMPTS -gt 0 ]; then\n    log_message \"ALERT: $VCS_ATTEMPTS version control access attempts in last 30 minutes\"\nfi\n\n# Check for hidden file access attempts\nHIDDEN_ATTEMPTS=$(grep \" /\\.\" \"$ACCESS_LOG\" | grep \"$(date '+%d/%b/%Y:%H' -d '30 minutes ago')\" | wc -l)\nif [ $HIDDEN_ATTEMPTS -gt 10 ]; then\n    log_message \"ALERT: $HIDDEN_ATTEMPTS hidden file access attempts in last 30 minutes\"\nfi\n\n# Daily comprehensive check\nif [ $(date +%H) = \"06\" ]; then\n    log_message \"Running daily security assessment\"\n    \n    # Check for world-writable .htaccess files\n    WORLD_WRITABLE=$(find /var/www -name \".htaccess\" -perm -o+w | wc -l)\n    if [ $WORLD_WRITABLE -gt 0 ]; then\n        log_message \"CRITICAL: $WORLD_WRITABLE world-writable .htaccess files found\"\n    fi\n    \n    # Check for .htaccess files in web root\n    HTACCESS_COUNT=$(find /var/www -name \".htaccess\" | wc -l)\n    log_message \"Found $HTACCESS_COUNT .htaccess files in web directories\"\n    \n    # Verify file permissions\n    find /var/www -name \".htaccess\" -not -perm 640 -exec ls -la {} \\; >> $LOG_FILE\nfi"
      }
    ]
  },
  {
    "pluginId": 40034,
    "title": ".env Information Leak",
    "defaultRisk": "High",
    "cweid": "200",
    "description": ".env information leak vulnerabilities occur when environment variable files containing sensitive configuration data such as database credentials, API keys, and security secrets are publicly accessible, allowing attackers to extract critical authentication and access information.",
    "simplified_description": "Your application has a critical security vulnerability that exposes your entire configuration file to the public. This is like leaving your master key, password book, and building alarm codes all available for anyone to read. Attackers can access your databases, external services, and completely compromise your system by simply reading your configuration file.",
    "solution": "Restrict access to .env files and move sensitive configuration to secure environment variables or encrypted storage.",
    "simplified_solution": "Immediately block public access to .env files using web server configuration. Move all sensitive data like database passwords and API keys to secure environment variables or encrypted secrets management systems. Ensure .env files are included in .gitignore, never committed to version control, and protected with proper file permissions. Use application-level access controls to prevent configuration disclosure.",
    "references": [
      {
        "name": "OWASP Environment Variable Security",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Environment_Variables_Cheat_Sheet.html"
      },
      {
        "name": "CWE-200: Information Exposure",
        "url": "https://cwe.mitre.org/data/definitions/200.html"
      },
      {
        "name": "12-Factor App Configuration",
        "url": "https://12factor.net/config"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Environment Variable Security Implementation",
        "solution_description": "This solution demonstrates comprehensive security for environment variables and configuration management, including secure .env file handling, encrypted storage, access controls, monitoring, and secrets management integration for production applications.",
        "affected_files": ".env files, web server configuration (httpd.conf, nginx.conf, .htaccess), application configuration loaders, secrets management scripts, CI/CD pipeline configuration, Docker files",
        "code": "# ============================================\n# SECURE .ENV FILE CONFIGURATION\n# ============================================\n\n# Example .env file with security considerations\n# NEVER commit this file to version control!\n# ALWAYS add to .gitignore\n\n# Database Configuration (use encrypted values in production)\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=app_user\nDB_PASSWORD=encrypted:base64:encrypted_password_here\nDB_SSL_MODE=require\n\n# API Keys (use secrets management in production)\nAPI_SECRET_KEY=encrypted:base64:encrypted_api_key_here\nEXTERNAL_SERVICE_API_KEY=encrypted:base64:encrypted_service_key\nJWT_SECRET=encrypted:base64:encrypted_jwt_secret\n\n# Application Configuration\nAPP_ENV=production\nAPP_DEBUG=false\nAPP_URL=https://example.com\nAPP_KEY=base64:encrypted_app_key_here\n\n# Security Settings\nCORS_ALLOWED_ORIGINS=https://example.com,https://app.example.com\nSESSION_ENCRYPTION_KEY=encrypted:base64:encrypted_session_key\nHASH_SALT=encrypted:base64:encrypted_hash_salt"
      }
    ]
  },
  {
    "pluginId": 40035,
    "title": "Hidden File Finder",
    "defaultRisk": "Medium",
    "cweid": "538",
    "description": "Hidden file finder vulnerabilities occur when web servers allow access to hidden files and directories that contain sensitive information such as configuration files, backup files, development artifacts, or administrative interfaces.",
    "simplified_description": "Your web server is exposing hidden files and directories that should be protected, like leaving your maintenance logs, backup files, and administrative tools accessible to the public. Attackers can discover sensitive configuration details, find vulnerabilities in your system, or gain access to administrative functions simply by exploring these hidden resources.",
    "solution": "Restrict access to hidden files and directories, remove sensitive files from production, and implement proper access controls for administrative interfaces.",
    "simplified_solution": "Configure your web server to block access to all hidden files (starting with '.'), backup files, and development artifacts. Remove any sensitive files from production directories. Move administrative interfaces to separate, authenticated areas. Implement proper access controls and regularly audit your web directories for exposed sensitive files.",
    "references": [
      {
        "name": "OWASP Information Disclosure Prevention",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Information_Leakage_Cheat_Sheet.html"
      },
      {
        "name": "CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory",
        "url": "https://cwe.mitre.org/data/definitions/538.html"
      },
      {
        "name": "OWASP Testing Guide: Information Leakage",
        "url": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Review_Webserver_Metafiles_for_Information_Leakage.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Web Server Security Configuration for Hidden Files",
        "solution_description": "This solution demonstrates comprehensive security configuration to prevent access to hidden files, backup files, and sensitive directories. Includes Apache, Nginx, and IIS configurations along with automated cleanup scripts and monitoring for production environments.",
        "affected_files": "Web server configuration files (.htaccess, httpd.conf, nginx.conf, web.config), deployment scripts, CI/CD pipelines, backup management systems",
        "code": "<!--\n# Apache httpd.conf or .htaccess\n\n# Block access to hidden files (files starting with .)\n<FilesMatch \"^\\.\">\n    Require all denied\n    Options None\n    AllowOverride None\n</FilesMatch>\n\n# Block access to backup files\n<FilesMatch \"\\.(bak|backup|old|orig|save|tmp|temp|swp|swo)$\">\n    Require all denied\n    Options None\n    AllowOverride None\n</FilesMatch>\n\n# Block access to development files\n<FilesMatch \"\\.(dev|test|debug|log|conf|config|ini|yml|yaml|json|xml)$\">\n    Require all denied\n    Options None\n    AllowOverride None\n</FilesMatch>\n\n# Block access to specific hidden directories\n<DirectoryMatch \"^\\.\">\n    Require all denied\n    Options None\n    AllowOverride None\n</DirectoryMatch>\n\n<DirectoryMatch \"\\.(git|svn|hg)\">\n    Require all denied\n    Options None\n    AllowOverride None\n</DirectoryMatch>\n\n# Block access to common sensitive directories\n<Directory \"(git|svn|hg|node_modules|vendor|backup|logs|temp|cache)\">\n    Require all denied\n    Options None\n    AllowOverride None\n</Directory>\n\n# Block specific files\n<FilesMatch \"(README|CHANGELOG|LICENSE|composer\\.json|package\\.json|\\.gitignore)\">\n    Require all denied\n    Options None\n    AllowOverride None\n</FilesMatch>\n\n# Prevent directory listing\n<Directory \"/var/www/html/\">\n    Options -Indexes\n    Options FollowSymLinks\n</Directory>"
      }
    ]
  },
  {
    "pluginId": 90001,
    "title": "Insecure JSF ViewState",
    "defaultRisk": "High",
    "cweid": "643",
    "description": "Insecure JavaServer Faces (JSF) ViewState implementations can expose sensitive application state information or be vulnerable to tampering attacks, potentially leading to unauthorized access or data manipulation.",
    "simplified_description": "Your web application has a security vulnerability in how it manages user session state. This is like leaving your personal documents in an unlocked filing cabinet - attackers can view, modify, or tamper with sensitive information about user interactions and application state, potentially gaining unauthorized access to protected functionality.",
    "solution": "Implement proper ViewState encryption, MAC signing, and secure configuration to protect JSF component state from tampering and information disclosure.",
    "simplified_solution": "Configure your JSF application to use strong encryption for ViewState data, enable MAC signing to prevent tampering, set appropriate client state saving methods, and implement proper timeout mechanisms. Ensure ViewState parameters are cryptographically protected and cannot be manipulated by attackers.",
    "references": [
      {
        "name": "OWASP ViewState Security",
        "url": "https://owasp.org/www-community/vulnerabilities/JavaServer_Faces_View_State_Tampering"
      },
      {
        "name": "CWE-643: Improper Neutralization of Data within XPath Expressions",
        "url": "https://cwe.mitre.org/data/definitions/643.html"
      },
      {
        "name": "Oracle JSF Security Guide",
        "url": "https://docs.oracle.com/javaee/7/tutorial/jsf-security.htm"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure JSF Configuration and ViewState Protection",
        "solution_description": "This solution demonstrates comprehensive JSF security configuration including ViewState encryption, MAC signing, secure client state management, and protection against ViewState tampering attacks using modern security practices.",
        "affected_files": "web.xml, faces-config.xml, security configuration files, JSF managed beans, web application filters",
        "code": "// ============================================\n// WEB.XML - SECURE JSF CONFIGURATION\n// ============================================\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee \n         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    \n    <!-- JSF Configuration -->\n    <context-param>\n        <param-name>javax.faces.PROJECT_STAGE</param-name>\n        <param-value>Production</param-value>\n    </context-param>\n    \n    <!-- Secure ViewState Configuration -->\n    <context-param>\n        <param-name>javax.faces.STATE_SAVING_METHOD</param-name>\n        <param-value>server</param-value>\n        <!-- Use server-side state saving for better security -->\n    </context-param>\n    \n    <context-param>\n        <param-name>javax.faces.SERIALIZE_SERVER_STATE</param-name>\n        <param-value>false</param-value>\n        <!-- Disable serialization for better performance and security -->\n    </context-param>\n    \n    <!-- ViewState Encryption and MAC Configuration -->\n    <context-param>\n        <param-name>com.sun.faces.ClientStateSavingPassword</param-name>\n        <param-value>#{secureConfig['jsf.clientStatePassword']}</param-value>\n        <!-- Use strong, randomly generated password from secure config -->\n    </context-param>\n    \n    <context-param>\n        <param-name>com.sun.faces.ClientStateTimeoutMinutes</param-name>\n        <param-value>30</param-value>\n        <!-- ViewState expires after 30 minutes -->\n    </context-param>\n    \n    <!-- Enable ViewState MAC signing -->\n    <context-param>\n        <param-name>com.sun.faces.enableMacSecret</param-name>\n        <param-value>#{secureConfig['jsf.macSecret']}</param-value>\n    </context-param>\n    \n    <!-- Disable auto-complete for sensitive forms -->\n    <context-param>\n        <param-name>javax.faces.DISABLE_FACELET_JSF_VIEWHANDLER</param-name>\n        <param-value>false</param-value>\n    </context-param>\n    \n    <!-- Security Configuration -->\n    <context-param>\n        <param-name>javax.faces.FACELETS_SKIP_COMMENTS</param-name>\n        <param-value>true</param-value>\n        <!-- Skip comments in facelets to prevent information disclosure -->\n    </context-param>\n    \n    <!-- Prevent XSS in JSF components -->\n    <context-param>\n        <param-name>javax.faces.FACELETS_LIBRARIES</param-name>\n        <param-value>/WEB-INF/security.taglib.xml</param-value>\n    </context-param>\n    \n    <!-- Session Configuration -->\n    <session-config>\n        <session-timeout>30</session-timeout>\n        <cookie-config>\n            <http-only>true</http-only>\n            <secure>true</secure>\n            <same-site>strict</same-site>\n        </cookie-config>\n        <tracking-mode>COOKIE</tracking-mode>\n    </session-config>\n    \n    <!-- Security Constraints -->\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>Secure Area</web-resource-name>\n            <url-pattern>/secure/*</url-pattern>\n        </web-resource-collection>\n        <auth-constraint>\n            <role-name>ADMIN</role-name>\n            <role-name>USER</role-name>\n        </auth-constraint>\n        <user-data-constraint>\n            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n        </user-data-constraint>\n    </security-constraint>\n    \n    <!-- Login Configuration -->\n    <login-config>\n        <auth-method>FORM</auth-method>\n        <form-login-config>\n            <form-login-page>/login.xhtml</form-login-page>\n            <form-error-page>/login-error.xhtml</form-error-page>\n        </form-login-config>\n    </login-config>\n    \n    <!-- Security Roles -->\n    <security-role>\n        <role-name>ADMIN</role-name>\n    </security-role>\n    <security-role>\n        <role-name>USER</role-name>\n    </security-role>\n    \n    <!-- Filters -->\n    <filter>\n        <filter-name>SecurityFilter</filter-name>\n        <filter-class>com.example.security.JsfSecurityFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>SecurityFilter</filter-name>\n        <url-pattern>*.xhtml</url-pattern>\n    </filter-mapping>\n    \n    <!-- JSF Servlet Mapping -->\n    <servlet>\n        <servlet-name>Faces Servlet</servlet-name>\n        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>Faces Servlet</servlet-name>\n        <url-pattern>*.xhtml</url-pattern>\n    </servlet-mapping>\n    \n    <!-- Welcome Files -->\n    <welcome-file-list>\n        <welcome-file>index.xhtml</welcome-file>\n    </welcome-file-list>\n    \n    <!-- Error Pages -->\n    <error-page>\n        <error-code>403</error-code>\n        <location>/error/403.xhtml</location>\n    </error-page>\n    <error-page>\n        <error-code>404</error-code>\n        <location>/error/404.xhtml</location>\n    </error-page>\n    <error-page>\n        <exception-type>javax.faces.application.ViewExpiredException</exception-type>\n        <location>/error/view-expired.xhtml</location>\n    </error-page>\n    \n</web-app>\n\n// ============================================\n// FACES-CONFIG.XML - SECURITY CONFIGURATION\n// ============================================\n\n<?xml version='1.0' encoding='UTF-8'?>\n<faces-config xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n              xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n              xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee \n              http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_3.xsd\"\n              version=\"2.3\">\n    \n    <!-- Application Configuration -->\n    <application>\n        <!-- Use secure view handler -->\n        <view-handler>com.example.security.SecureViewHandler</view-handler>\n        \n        <!-- Custom security phase listener -->\n        <phase-listener>com.example.security.JsfSecurityPhaseListener</phase-listener>\n        \n        <!-- Enable secure EL resolver -->\n        <el-resolver>com.example.security.SecureELResolver</el-resolver>\n    </application>\n    \n    <!-- Managed Beans -->\n    <managed-bean>\n        <managed-bean-name>securityConfig</managed-bean-name>\n        <managed-bean-class>com.example.security.SecurityConfigBean</managed-bean-class>\n        <managed-bean-scope>application</managed-bean-scope>\n    </managed-bean>\n    \n    <!-- Navigation Rules -->\n    <navigation-rule>\n        <from-view-id>/login.xhtml</from-view-id>\n        <navigation-case>\n            <from-outcome>success</from-outcome>\n            <to-view-id>/secure/dashboard.xhtml</to-view-id>\n            <redirect/>\n        </navigation-case>\n        <navigation-case>\n            <from-outcome>failure</from-outcome>\n            <to-view-id>/login.xhtml</to-view-id>\n            <redirect/>\n        </navigation-case>\n    </navigation-rule>\n    \n    <!-- Security Navigation Rules -->\n    <navigation-rule>\n        <from-view-id>/secure/*</from-view-id>\n        <navigation-case>\n            <if>#{!securityBean.isLoggedIn}</if>\n            <to-view-id>/login.xhtml</to-view-id>\n            <redirect/>\n        </navigation-case>\n    </navigation-rule>\n    \n</faces-config>\n\n// ============================================\n// SECURITY CONFIGURATION BEAN\n// ============================================\n\npackage com.example.security;\n\nimport javax.annotation.PostConstruct;\nimport javax.enterprise.context.ApplicationScoped;\nimport javax.faces.application.FacesMessage;\nimport javax.faces.context.FacesContext;\nimport javax.inject.Named;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.SecureRandom;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Named\n@ApplicationScoped\npublic class SecurityConfigBean {\n    \n    private Map<String, String> secureConfig;\n    private SecretKey viewStateEncryptionKey;\n    private String macSecret;\n    \n    @PostConstruct\n    public void init() {\n        secureConfig = new HashMap<>();\n        generateSecureKeys();\n        loadSecurityConfiguration();\n    }\n    \n    private void generateSecureKeys() {\n        try {\n            // Generate ViewState encryption key\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n            keyGen.init(256, new SecureRandom());\n            viewStateEncryptionKey = keyGen.generateKey();\n            \n            // Generate MAC secret\n            SecureRandom random = new SecureRandom();\n            byte[] macBytes = new byte[32];\n            random.nextBytes(macBytes);\n            macSecret = Base64.getEncoder().encodeToString(macBytes);\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to generate secure keys\", e);\n        }\n    }\n    \n    private void loadSecurityConfiguration() {\n        // Load sensitive configuration from secure sources\n        secureConfig.put(\"jsf.clientStatePassword\", \n                        Base64.getEncoder().encodeToString(viewStateEncryptionKey.getEncoded()));\n        secureConfig.put(\"jsf.macSecret\", macSecret);\n        secureConfig.put(\"viewStateTimeout\", \"1800\"); // 30 minutes\n        secureConfig.put(\"maxViewStates\", \"10\");\n        secureConfig.put(\"enableViewStateEncryption\", \"true\");\n    }\n    \n    public Map<String, String> getSecureConfig() {\n        return secureConfig;\n    }\n    \n    public String getMacSecret() {\n        return macSecret;\n    }\n    \n    public SecretKey getViewStateEncryptionKey() {\n        return viewStateEncryptionKey;\n    }\n    \n    public boolean isViewStateEncryptionEnabled() {\n        return Boolean.parseBoolean(secureConfig.get(\"enableViewStateEncryption\"));\n    }\n}\n\n// ============================================\n// SECURITY FILTER FOR JSF\n// ============================================\n\npackage com.example.security;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.util.regex.Pattern;\n\n@WebFilter(\"*.xhtml\")\npublic class JsfSecurityFilter implements Filter {\n    \n    private static final Pattern VIEWSTATE_PATTERN = \n        Pattern.compile(\"j_id[0-9]+:j_id[0-9]+:([a-zA-Z0-9+/]+={0,2})\");\n    \n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        // Initialize filter\n    }\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, \n                        FilterChain chain) throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Set security headers\n        setSecurityHeaders(httpResponse);\n        \n        // Validate ViewState parameters\n        if (httpRequest.getMethod().equalsIgnoreCase(\"POST\")) {\n            if (!validateViewState(httpRequest)) {\n                httpResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, \n                                       \"Invalid ViewState detected\");\n                return;\n            }\n        }\n        \n        // Check for ViewExpiredException\n        checkViewStateExpiration(httpRequest, httpResponse);\n        \n        chain.doFilter(request, response);\n    }\n    \n    private void setSecurityHeaders(HttpServletResponse response) {\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        response.setHeader(\"X-Frame-Options\", \"DENY\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"Content-Security-Policy\", \n                          \"default-src 'self'; script-src 'self' 'unsafe-inline'; \" +\n                          \"style-src 'self' 'unsafe-inline'; img-src 'self' data:; \" +\n                          \"font-src 'self'; connect-src 'self'; frame-ancestors 'none';\");\n        response.setHeader(\"Referrer-Policy\", \"strict-origin-when-cross-origin\");\n        response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setHeader(\"Expires\", \"0\");\n    }\n    \n    private boolean validateViewState(HttpServletRequest request) {\n        String viewState = request.getParameter(\"javax.faces.ViewState\");\n        \n        if (viewState == null || viewState.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for suspicious ViewState patterns\n        if (VIEWSTATE_PATTERN.matcher(viewState).matches()) {\n            return false; // Potential tampering attempt\n        }\n        \n        // Additional ViewState validation logic\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            // Verify ViewState exists in session and is valid\n            String sessionViewState = (String) session.getAttribute(\"viewState\");\n            if (sessionViewState != null && !sessionViewState.equals(viewState)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private void checkViewStateExpiration(HttpServletRequest request, \n                                         HttpServletResponse response) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Long viewStateTimestamp = (Long) session.getAttribute(\"viewStateTimestamp\");\n            if (viewStateTimestamp != null) {\n                long currentTime = System.currentTimeMillis();\n                long maxAge = 30 * 60 * 1000; // 30 minutes\n                \n                if (currentTime - viewStateTimestamp > maxAge) {\n                    session.removeAttribute(\"viewState\");\n                    session.removeAttribute(\"viewStateTimestamp\");\n                    // Note: JSF will automatically handle ViewExpiredException\n                }\n            }\n        }\n    }\n    \n    @Override\n    public void destroy() {\n        // Cleanup filter resources\n    }\n}\n\n// ============================================\n// SECURITY PHASE LISTENER\n// ============================================\n\npackage com.example.security;\n\nimport javax.faces.event.PhaseEvent;\nimport javax.faces.event.PhaseId;\nimport javax.faces.event.PhaseListener;\nimport javax.faces.context.FacesContext;\nimport javax.faces.application.FacesMessage;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JsfSecurityPhaseListener implements PhaseListener {\n    \n    @Override\n    public void beforePhase(PhaseEvent event) {\n        FacesContext context = event.getFacesContext();\n        HttpServletRequest request = (HttpServletRequest) context.getExternalContext().getRequest();\n        \n        // Log security-relevant information\n        logSecurityEvent(request, \"BEFORE_\" + event.getPhaseId().toString());\n        \n        // Validate request parameters for injection attempts\n        validateRequestParameters(request, context);\n    }\n    \n    @Override\n    public void afterPhase(PhaseEvent event) {\n        FacesContext context = event.getFacesContext();\n        HttpServletRequest request = (HttpServletRequest) context.getExternalContext().getRequest();\n        \n        // Log security-relevant information\n        logSecurityEvent(request, \"AFTER_\" + event.getPhaseId().toString());\n        \n        // Clear sensitive data from request scope\n        clearSensitiveData(context);\n    }\n    \n    @Override\n    public PhaseId getPhaseId() {\n        return PhaseId.ANY_PHASE;\n    }\n    \n    private void logSecurityEvent(HttpServletRequest request, String phase) {\n        String clientIP = getClientIP(request);\n        String userAgent = request.getHeader(\"User-Agent\");\n        String requestURI = request.getRequestURI();\n        \n        // Log to security audit log\n        System.out.println(String.format(\n            \"[SECURITY] %s - %s - %s - %s\", \n            clientIP, phase, requestURI, userAgent\n        ));\n        \n        // In production, use proper logging framework\n        // securityLogger.info(\"Security event: {} - {} - {}\", clientIP, phase, requestURI);\n    }\n    \n    private void validateRequestParameters(HttpServletRequest request, FacesContext context) {\n        Enumeration<String> parameterNames = request.getParameterNames();\n        \n        while (parameterNames.hasMoreElements()) {\n            String paramName = parameterNames.nextElement();\n            String[] paramValues = request.getParameterValues(paramName);\n            \n            for (String paramValue : paramValues) {\n                if (containsSuspiciousContent(paramValue)) {\n                    // Add warning message\n                    context.addMessage(null, new FacesMessage(\n                        FacesMessage.SEVERITY_WARN,\n                        \"Suspicious input detected\",\n                        \"Potential security issue in parameter: \" + paramName\n                    ));\n                    \n                    // Log security event\n                    System.out.println(String.format(\n                        \"[SECURITY WARNING] Suspicious content in parameter %s: %s\", \n                        paramName, paramValue\n                    ));\n                }\n            }\n        }\n    }\n    \n    private boolean containsSuspiciousContent(String value) {\n        String[] suspiciousPatterns = {\n            \"<script\", \"javascript:\", \"vbscript:\", \"onload=\", \"onerror=\",\n            \"../\", \"..\\\\\", \"SELECT.*FROM\", \"INSERT.*INTO\", \"DELETE.*FROM\",\n            \"UNION.*SELECT\", \"DROP.*TABLE\", \"exec\\s*\\(\", \"eval\\s*\\(\"\n        };\n        \n        String lowerValue = value.toLowerCase();\n        for (String pattern : suspiciousPatterns) {\n            if (lowerValue.matches(\"(?i).*\" + pattern + \".*\")) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void clearSensitiveData(FacesContext context) {\n        // Clear sensitive data from request map\n        Map<String, Object> requestMap = context.getExternalContext().getRequestMap();\n        requestMap.entrySet().removeIf(entry -> \n            entry.getKey().toLowerCase().contains(\"password\") ||\n            entry.getKey().toLowerCase().contains(\"secret\") ||\n            entry.getKey().toLowerCase().contains(\"token\")\n        );\n    }\n    \n    private String getClientIP(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        \n        String xRealIP = request.getHeader(\"X-Real-IP\");\n        if (xRealIP != null && !xRealIP.isEmpty()) {\n            return xRealIP;\n        }\n        \n        return request.getRemoteAddr();\n    }\n}\n\n// ============================================\n// SECURE JSF PAGE EXAMPLE\n// ============================================\n\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:h=\"http://xmlns.jcp.org/jsf/html\"\n      xmlns:f=\"http://xmlns.jcp.org/jsf/core\"\n      xmlns:ui=\"http://xmlns.jcp.org/jsf/facelets\"\n      xmlns:sec=\"http://xmlns.jcp.org/jsf/security\">\n    \n<h:head>\n    <title>Secure Dashboard</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    <!-- Security headers automatically added by filter -->\n</h:head>\n    \n<h:body>\n    <ui:include src=\"/WEB-INF/templates/header.xhtml\"/>\n    \n    <div class=\"container\">\n        <h2>Secure Dashboard</h2>\n        \n        <!-- User Information -->\n        <h:panelGroup rendered=\"#{securityBean.isLoggedIn}\">\n            <h3>Welcome, #{securityBean.currentUser.name}!</h3>\n            \n            <!-- Secure Form with ViewState Protection -->\n            <h:form id=\"profileForm\" prependId=\"false\">\n                <!-- ViewState automatically secured by configuration -->\n                \n                <h:panelGrid columns=\"2\" cellpadding=\"5\">\n                    <h:outputLabel for=\"email\" value=\"Email:\"/>\n                    <h:inputText id=\"email\" \n                                 value=\"#{userBean.email}\" \n                                 required=\"true\"\n                                 requiredMessage=\"Email is required\">\n                        <f:validator validatorId=\"emailValidator\"/>\n                        <f:ajax event=\"blur\" render=\"emailMessage\"/>\n                    </h:inputText>\n                    <h:message for=\"email\" id=\"emailMessage\" style=\"color: red;\"/>\n                    \n                    <h:outputLabel for=\"name\" value=\"Name:\"/>\n                    <h:inputText id=\"name\" \n                                 value=\"#{userBean.name}\" \n                                 required=\"true\"\n                                 requiredMessage=\"Name is required\">\n                        <f:validateLength minimum=\"2\" maximum=\"50\"/>\n                    </h:inputText>\n                    <h:message for=\"name\" style=\"color: red;\"/>\n                    \n                    <h:outputLabel for=\"role\" value=\"Role:\"/>\n                    <h:selectOneMenu id=\"role\" value=\"#{userBean.role}\">\n                        <f:selectItem itemValue=\"USER\" itemLabel=\"User\"/>\n                        <f:selectItem itemValue=\"ADMIN\" itemLabel=\"Admin\"/>\n                        <f:selectItem itemValue=\"MODERATOR\" itemLabel=\"Moderator\"/>\n                    </h:selectOneMenu>\n                </h:panelGrid>\n                \n                <!-- Action buttons with proper security checks -->\n                <h:panelGroup>\n                    <h:commandButton value=\"Update Profile\" \n                                     action=\"#{userBean.updateProfile}\"\n                                     styleClass=\"btn btn-primary\">\n                        <f:ajax execute=\"@form\" render=\"@form :messages\"/>\n                    </h:commandButton>\n                    \n                    <h:commandButton value=\"Reset\" \n                                     action=\"#{userBean.reset}\"\n                                     immediate=\"true\"\n                                     styleClass=\"btn btn-secondary\">\n                        <f:ajax render=\"@form\"/>\n                    </h:commandButton>\n                    \n                    <!-- Admin only action -->\n                    <h:commandButton value=\"Delete User\" \n                                     action=\"#{adminBean.deleteUser}\"\n                                     rendered=\"#{securityBean.hasRole('ADMIN')}\"\n                                     styleClass=\"btn btn-danger\"\n                                     onclick=\"return confirm('Are you sure?');\">\n                        <f:ajax execute=\"@form\" render=\":messages\"/>\n                    </h:commandButton>\n                </h:panelGroup>\n            </h:form>\n            \n            <!-- Messages -->\n            <h:messages id=\"messages\" \n                        globalOnly=\"true\" \n                        styleClass=\"alert alert-info\"\n                        infoClass=\"alert-success\"\n                        warnClass=\"alert-warning\"\n                        errorClass=\"alert-danger\"\n                        fatalClass=\"alert-danger\"/>\n        </h:panelGroup>\n        \n        <!-- Login form for unauthenticated users -->\n        <h:panelGroup rendered=\"#{!securityBean.isLoggedIn}\">\n            <h:form id=\"loginForm\" prependId=\"false\">\n                <h:panelGrid columns=\"2\" cellpadding=\"5\">\n                    <h:outputLabel for=\"username\" value=\"Username:\"/>\n                    <h:inputText id=\"username\" \n                                 value=\"#{loginBean.username}\" \n                                 required=\"true\"\n                                 autocomplete=\"username\"/>\n                    \n                    <h:outputLabel for=\"password\" value=\"Password:\"/>\n                    <h:inputSecret id=\"password\" \n                                   value=\"#{loginBean.password}\" \n                                   required=\"true\"\n                                   autocomplete=\"current-password\"/>\n                    \n                    <h:outputLabel for=\"remember\" value=\"Remember Me:\"/>\n                    <h:selectBooleanCheckbox id=\"remember\" value=\"#{loginBean.rememberMe}\"/>\n                </h:panelGrid>\n                \n                <h:commandButton value=\"Login\" \n                                 action=\"#{loginBean.login}\"\n                                 styleClass=\"btn btn-primary\">\n                    <f:ajax execute=\"@form\" render=\"@form :messages\"/>\n                </h:commandButton>\n                \n                <h:commandButton value=\"Forgot Password\" \n                                 action=\"forgot-password\" \n                                 immediate=\"true\"\n                                 styleClass=\"btn btn-link\"/>\n            </h:form>\n        </h:panelGroup>\n    </div>\n    \n    <ui:include src=\"/WEB-INF/templates/footer.xhtml\"/>\n    \n    <!-- Security JavaScript -->\n    <h:outputScript name=\"js/security.js\" target=\"head\"/>\n    \n</h:body>\n</html>\n\n// ============================================\n// SECURITY VALIDATION AND TESTING\n// ============================================\n\n/*\nJSF ViewState Security Testing:\n\n1. ViewState Tampering Tests:\n   - Modify ViewState parameters and verify rejection\n   - Test with expired ViewState values\n   - Attempt ViewState injection attacks\n   - Verify ViewState encryption is working\n\n2. Session Management Tests:\n   - Test session fixation prevention\n   - Verify session timeout enforcement\n   - Check session invalidation on logout\n   - Test concurrent session handling\n\n3. Security Headers Verification:\n   - X-Content-Type-Options: nosniff\n   - X-Frame-Options: DENY\n   - X-XSS-Protection: 1; mode=block\n   - Content-Security-Policy headers\n   - Cache-Control headers\n\n4. Authentication and Authorization:\n   - Test role-based access control\n   - Verify authentication bypass attempts fail\n   - Test privilege escalation prevention\n   - Check secure logout implementation\n\n5. Input Validation Tests:\n   - XSS payload injection attempts\n   - SQL injection parameter tests\n   - Path traversal attempts\n   - Command injection tests\n\n6. ViewState Encryption Verification:\n   - Verify ViewState is not readable in plaintext\n   - Test MAC signature validation\n   - Check encryption strength (AES-256)\n   - Verify key management security\n\nAutomated Testing Commands:\n# ZAP scan for JSF vulnerabilities\nzaproxy -cmd -quickurl http://localhost:8080/secure/dashboard.xhtml\n\n# Manual ViewState testing\ncurl -X POST http://localhost:8080/secure/dashboard.xhtml \\\n     -d \"javax.faces.ViewState=invalid_value\" \\\n     -d \"profileForm=email=test@example.com\"\n\n# Security headers test\nnpx lighthouse --chrome-flags=\"--headless\" \\\n  --output=html --output-path=./security-report.html \\\n  http://localhost:8080/secure/dashboard.xhtml\n\nExpected Results:\n- All ViewState tampering attempts should be rejected\n- Security headers should be present and correct\n- Authentication and authorization should be properly enforced\n- ViewState should be encrypted and MAC-signed\n- Input validation should prevent injection attacks\n*/"
      }
    ]
  },
  {
    "pluginId": 90019,
    "title": "Server Side Code Injection",
    "defaultRisk": "Critical",
    "cweid": "94",
    "description": "Server Side Code Injection vulnerabilities allow attackers to execute arbitrary server-side code by injecting malicious input into eval() functions or similar code execution constructs.",
    "simplified_description": "Your application has an extremely dangerous security flaw that allows attackers to run their own code on your server. This is like giving strangers the keys to your office computer - they can steal all your data, take over your systems, and cause catastrophic damage to your business.",
    "solution": "Eliminate all dynamic code execution, use static code analysis, implement strict input validation, avoid eval() and similar functions, use parameterized queries for database operations.",
    "simplified_solution": "Remove all instances of eval(), exec(), system(), and similar code execution functions, validate and sanitize all user input, use secure coding practices that avoid dynamic code generation, implement proper access controls and code review processes.",
    "references": [
      {
        "name": "OWASP Code Injection",
        "url": "https://owasp.org/www-community/attacks/Code_Injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Code Injection Prevention",
        "solution_description": "Comprehensive code injection prevention including eliminating dynamic code execution, implementing strict validation, and using secure coding practices.",
        "affected_files": "Code execution functions, template engines, dynamic language features, plugin systems, configuration files",
        "code": "// ==========================\n// SECURE CODE EXECUTION ALTERNATIVES\n// ==========================\npublic class SecureCodeExecution {\n    \n    // NEVER DO THIS - VULNERABLE CODE:\n    // public void executeUserCode(String userInput) {\n    //     ScriptEngineManager manager = new ScriptEngineManager();\n    //     ScriptEngine engine = manager.getEngineByName(\"javascript\");\n    //     engine.eval(userInput); // DANGEROUS!\n    // }\n    \n    // INSTEAD - Use safe alternatives:\n    \n    /**\n     * Safe mathematical expression evaluator\n     */\n    public static double evaluateMathExpression(String expression) throws SecurityException {\n        if (!isValidMathExpression(expression)) {\n            throw new SecurityException(\"Invalid mathematical expression\");\n        }\n        \n        try {\n            // Use a safe math expression parser\n            MathExpressionParser parser = new MathExpressionParser();\n            return parser.parse(expression);\n        } catch (Exception e) {\n            throw new SecurityException(\"Failed to evaluate expression\", e);\n        }\n    }\n    \n    private static boolean isValidMathExpression(String expression) {\n        if (expression == null || expression.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Only allow mathematical characters\n        if (!expression.matches(\"^[0-9+\\\\-*/().\\\\s]+$\")) {\n            return false;\n        }\n        \n        // Check for dangerous patterns\n        String[] dangerousPatterns = {\n            \"eval\", \"function\", \"var\", \"let\", \"const\", \"new\", \"this\",\n            \"window\", \"document\", \"process\", \"require\", \"import\"\n        };\n        \n        String lowerExpression = expression.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerExpression.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 90020,
    "title": "Remote OS Command Injection",
    "defaultRisk": "Critical",
    "cweid": "78",
    "description": "Remote OS Command Injection vulnerabilities allow attackers to execute arbitrary operating system commands on the server, potentially leading to complete system compromise.",
    "simplified_description": "Your application has an extremely dangerous vulnerability that allows attackers to run their own commands on your server's operating system. This is like giving someone the administrator password to your computer - they can access all your files, steal data, install malware, and take complete control of your systems.",
    "solution": "Eliminate all system command execution, use language-specific functions instead of OS commands, implement strict input validation, use parameterized commands when absolutely necessary, and apply principle of least privilege.",
    "simplified_solution": "Remove all calls to system(), exec(), shell_exec(), and similar functions, use secure language-specific alternatives for file operations, validate and sanitize all user input, implement proper access controls, and run applications with minimal permissions.",
    "references": [
      {
        "name": "OWASP Command Injection",
        "url": "https://owasp.org/www-community/attacks/Command_Injection"
      },
      {
        "name": "CWE-78: Improper Neutralization of Special Elements used in an OS Command",
        "url": "https://cwe.mitre.org/data/definitions/78.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Command Injection Prevention",
        "solution_description": "Comprehensive command injection prevention including eliminating system calls, implementing secure alternatives, and strict input validation.",
        "affected_files": "System command execution code, file processing utilities, image processing, network utilities, administration interfaces",
        "code": "// ==========================\n// SECURE FILE OPERATIONS (NO COMMAND INJECTION)\n// ==========================\npublic class SecureFileOperations {\n    private static final Logger logger = LoggerFactory.getLogger(SecureFileOperations.class);\n    \n    // VULNERABLE CODE (DO NOT USE):\n    // public void compressFile(String filename) {\n    //     String command = \"zip \" + filename + \".zip \" + filename;\n    //     Runtime.getRuntime().exec(command); // DANGEROUS!\n    // }\n    \n    // SECURE IMPLEMENTATION - Use Java libraries instead\n    public boolean compressFile(String filename) {\n        if (!isValidFilename(filename)) {\n            throw new SecurityException(\"Invalid filename\");\n        }\n        \n        try {\n            Path filePath = Paths.get(\"/secure/uploads\", filename).normalize();\n            if (!filePath.startsWith(\"/secure/uploads/\")) {\n                throw new SecurityException(\"Path traversal attempt\");\n            }\n            \n            // Use Java's built-in zip functionality\n            Path zipPath = Paths.get(filePath.toString() + \".zip\");\n            try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zipPath))) {\n                ZipEntry entry = new ZipEntry(filename);\n                zos.putNextEntry(entry);\n                Files.copy(filePath, zos);\n                zos.closeEntry();\n            }\n            \n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to compress file: {}\", filename, e);\n            return false;\n        }\n    }\n    \n    // SECURE IMAGE PROCESSING\n    public BufferedImage processImage(String filename, int width, int height) {\n        if (!isValidFilename(filename)) {\n            throw new SecurityException(\"Invalid filename\");\n        }\n        \n        if (width <= 0 || height <= 0 || width > 2000 || height > 2000) {\n            throw new SecurityException(\"Invalid image dimensions\");\n        }\n        \n        try {\n            Path filePath = Paths.get(\"/secure/images\", filename).normalize();\n            if (!filePath.startsWith(\"/secure/images/\")) {\n                throw new SecurityException(\"Path traversal attempt\");\n            }\n            \n            // Use Java's ImageIO instead of external tools\n            BufferedImage originalImage = ImageIO.read(filePath.toFile());\n            \n            // Resize image using Java's built-in functionality\n            BufferedImage resizedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n            Graphics2D g = resizedImage.createGraphics();\n            g.drawImage(originalImage, 0, 0, width, height, null);\n            g.dispose();\n            \n            return resizedImage;\n        } catch (Exception e) {\n            logger.error(\"Failed to process image: {}\", filename, e);\n            throw new RuntimeException(\"Image processing failed\", e);\n        }\n    }\n    \n    private boolean isValidFilename(String filename) {\n        if (filename == null || filename.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for path traversal\n        if (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n            return false;\n        }\n        \n        // Check for dangerous characters\n        Pattern dangerousPattern = Pattern.compile(\"[<>:\\\"|?*\\\\\\\\;()&$`]\");\n        if (dangerousPattern.matcher(filename).find()) {\n            return false;\n        }\n        \n        // Check length\n        if (filename.length() > 255) {\n            return false;\n        }\n        \n        // Only allow specific file extensions\n        String[] allowedExtensions = {\".jpg\", \".jpeg\", \".png\", \".gif\", \".pdf\", \".txt\", \".doc\", \".docx\"};\n        String lowerFilename = filename.toLowerCase();\n        \n        return Arrays.stream(allowedExtensions)\n            .anyMatch(lowerFilename::endsWith);\n    }\n}\n\n// ==========================\n// SECURE NETWORK OPERATIONS\n// ==========================\npublic class SecureNetworkOperations {\n    private static final Logger logger = LoggerFactory.getLogger(SecureNetworkOperations.class);\n    \n    // VULNERABLE CODE (DO NOT USE):\n    // public String pingHost(String hostname) {\n    //     String command = \"ping -c 4 \" + hostname;\n    //     Process process = Runtime.getRuntime().exec(command);\n    //     // Read output... DANGEROUS!\n    // }\n    \n    // SECURE IMPLEMENTATION - Use Java networking libraries\n    public boolean checkHostConnectivity(String hostname, int port) {\n        if (!isValidHostname(hostname)) {\n            throw new SecurityException(\"Invalid hostname\");\n        }\n        \n        if (port < 1 || port > 65535) {\n            throw new SecurityException(\"Invalid port\");\n        }\n        \n        try {\n            // Use Java's socket functionality instead of ping command\n            try (Socket socket = new Socket()) {\n                socket.connect(new InetSocketAddress(hostname, port), 5000); // 5 second timeout\n                return true;\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    \n    public boolean isValidHostname(String hostname) {\n        if (hostname == null || hostname.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous characters\n        Pattern dangerousPattern = Pattern.compile(\"[<>:\\\"|?*\\\\\\\\;()&$`!]\");\n        if (dangerousPattern.matcher(hostname).find()) {\n            return false;\n        }\n        \n        // Check length\n        if (hostname.length() > 253) {\n            return false;\n        }\n        \n        // Basic hostname validation\n        return hostname.matches(\"^[a-zA-Z0-9.-]+$\") && \n               !hostname.startsWith(\"-\") && \n               !hostname.endsWith(\"-\") &&\n               !hostname.startsWith(\".\") && \n               !hostname.endsWith(\".\");\n    }\n}\n\n// ==========================\n// SECURE PROCESS BUILDER ALTERNATIVE\n// ==========================\npublic class SecureProcessExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(SecureProcessExecutor.class);\n    \n    // Only execute pre-approved commands with strict validation\n    private static final Map<String, List<String>> ALLOWED_COMMANDS = Map.of(\n        \"pdf-converter\", List.of(\"/usr/bin/libreoffice\", \"--headless\", \"--convert-to\", \"pdf\"),\n        \"image-optimizer\", List.of(\"/usr/bin/optipng\", \"-o7\")\n    );\n    \n    public ProcessResult executeCommand(String commandType, String filename) {\n        // Validate command type\n        if (!ALLOWED_COMMANDS.containsKey(commandType)) {\n            throw new SecurityException(\"Command type not allowed: \" + commandType);\n        }\n        \n        // Validate filename\n        if (!isValidFilename(filename)) {\n            throw new SecurityException(\"Invalid filename: \" + filename);\n        }\n        \n        List<String> command = new ArrayList<>(ALLOWED_COMMANDS.get(commandType));\n        command.add(filename);\n        \n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(command);\n            \n            // Set up secure environment\n            processBuilder.directory(new File(\"/secure/workspace\"));\n            \n            // Clear dangerous environment variables\n            Map<String, String> env = processBuilder.environment();\n            env.remove(\"PATH\");\n            env.remove(\"LD_LIBRARY_PATH\");\n            env.put(\"PATH\", \"/usr/bin:/bin\");\n            \n            Process process = processBuilder.start();\n            \n            // Read output safely\n            String output = new BufferedReader(new InputStreamReader(process.getInputStream()))\n                .lines().collect(Collectors.joining(\"\\\\n\"));\n            \n            String error = new BufferedReader(new InputStreamReader(process.getErrorStream()))\n                .lines().collect(Collectors.joining(\"\\\\n\"));\n            \n            int exitCode = process.waitFor();\n            \n            return new ProcessResult(exitCode, output, error);\n            \n        } catch (Exception e) {\n            logger.error(\"Command execution failed\", e);\n            throw new RuntimeException(\"Command execution failed\", e);\n        }\n    }\n    \n    private boolean isValidFilename(String filename) {\n        if (filename == null || filename.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous characters and patterns\n        Pattern dangerousPattern = Pattern.compile(\"[<>:\\\"|?*\\\\\\\\;()&$`!{}[]`\\\\n\\\\r\\\\t]\");\n        if (dangerousPattern.matcher(filename).find()) {\n            return false;\n        }\n        \n        // Check for command injection patterns\n        String[] injectionPatterns = {\n            \"&&\", \"||\", \";\", \"|\", \"&\", \">\", \"<\", \"`\", \"$\", \"$(\", \"${\",\n            \"..\", \"/\", \"\\\\\", \"exec\", \"eval\", \"system\", \"sh\", \"bash\"\n        };\n        \n        String lowerFilename = filename.toLowerCase();\n        for (String pattern : injectionPatterns) {\n            if (lowerFilename.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        return filename.length() <= 255;\n    }\n}\n\n// ==========================\n// INPUT VALIDATION FOR COMMAND INJECTION\n// ==========================\n@Component\npublic class CommandInjectionFilter implements Filter {\n    \n    private static final String[] DANGEROUS_COMMANDS = {\n        \"&&\", \"||\", \";\", \"|\", \"&\", \">\", \"<\", \"`\", \"$\", \"$(\", \"${\",\n        \"exec\", \"eval\", \"system\", \"sh\", \"bash\", \"cmd\", \"powershell\",\n        \"nc\", \"netcat\", \"wget\", \"curl\", \"ping\", \"traceroute\", \"nslookup\",\n        \"..\", \"/\", \"\\\\\", \"~\", \"etc/passwd\", \"etc/shadow\"\n    };\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Check all parameters for command injection attempts\n        if (containsCommandInjection(httpRequest)) {\n            logger.warn(\"Command injection attempt detected from IP: {}\", getClientIpAddress(httpRequest));\n            httpResponse.setStatus(HttpStatus.FORBIDDEN.value());\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private boolean containsCommandInjection(HttpServletRequest request) {\n        // Check parameters\n        Enumeration<String> parameterNames = request.getParameterNames();\n        while (parameterNames.hasMoreElements()) {\n            String paramName = parameterNames.nextElement();\n            String[] paramValues = request.getParameterValues(paramName);\n            \n            for (String value : paramValues) {\n                if (containsDangerousCommands(value)) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check headers\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String headerName = headerNames.nextElement();\n            String headerValue = request.getHeader(headerName);\n            \n            if (containsDangerousCommands(headerValue)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean containsDangerousCommands(String input) {\n        if (input == null) {\n            return false;\n        }\n        \n        String lowerInput = input.toLowerCase();\n        return Arrays.stream(DANGEROUS_COMMANDS)\n            .anyMatch(lowerInput::contains);\n    }\n    \n    private String getClientIpAddress(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        return request.getRemoteAddr();\n    }\n}\n\n// ==========================\n// SECURE ALTERNATIVE EXAMPLES\n// ==========================\n/*\nInstead of: Runtime.getRuntime().exec(\"ls -la \" + userInput);\nUse:     Files.list(Paths.get(userInput));\n\nInstead of: Runtime.getRuntime().exec(\"ping \" + hostname);\nUse:     InetAddress.getByName(hostname).isReachable(timeout);\n\nInstead of: Runtime.getRuntime().exec(\"convert image.jpg -resize 800x600 output.jpg\");\nUse:     ImageIO and Java2D for image processing\n\nInstead of: Runtime.getRuntime().exec(\"zip archive.zip file.txt\");\nUse:     ZipOutputStream and Java IO\n\nInstead of: Runtime.getRuntime().exec(\"curl \" + url);\nUse:     HttpClient or HttpURLConnection\n\nInstead of: Runtime.getRuntime().exec(\"mysql -u user -p password database -e \\\"SELECT * FROM users WHERE name='\" + input + \"'\\\"\");\nUse:     JDBC with PreparedStatement\n*/"
      }
    ]
  },
  {
    "pluginId": 90021,
    "title": "XPath Injection",
    "defaultRisk": "High",
    "cweid": "91",
    "description": "XPath Injection vulnerabilities allow attackers to inject malicious XPath queries into XML document processing, potentially leading to unauthorized data access, information disclosure, or bypassing authentication mechanisms.",
    "simplified_description": "Your application has a security flaw that allows attackers to manipulate XML database queries to access sensitive information they shouldn't see. This is like giving someone a special key that can unlock any filing cabinet - they can read private user data, bypass security controls, and extract confidential information.",
    "solution": "Use parameterized XPath queries, implement proper input validation and sanitization, use secure XML parsing libraries, and apply least privilege access to XML data.",
    "simplified_solution": "Replace dynamic XPath queries with parameterized or compiled queries, validate all user input before using it in XPath expressions, use modern XML libraries with built-in protection, implement proper error handling that doesn't reveal sensitive information.",
    "references": [
      {
        "name": "OWASP XPath Injection",
        "url": "https://owasp.org/www-community/attacks/XPath_Injection"
      },
      {
        "name": "CWE-91: XML Injection (aka Blind XPath Injection)",
        "url": "https://cwe.mitre.org/data/definitions/91.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "XPath Injection Prevention",
        "solution_description": "Comprehensive XPath injection prevention including parameterized queries, input validation, and secure XML processing.",
        "affected_files": "XML processing code, XPath query builders, authentication systems, configuration file parsers, data extraction utilities",
        "code": "// ==========================\n// SECURE XQUERY PROCESSING\n// ==========================\npublic class SecureXPathProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(SecureXPathProcessor.class);\n    \n    // VULNERABLE CODE (DO NOT USE):\n    // public NodeList findUsers(String username) {\n    //     String xpath = \"//users/user[username='\" + username + \"']\";\n    //     return (NodeList) xpath.evaluate(xpath, document, XPathConstants.NODESET);\n    // }\n    \n    // SECURE IMPLEMENTATION - Use parameterized XPath\n    public NodeList findUsersByUsername(String username) throws XPathExpressionException {\n        if (!isValidUsername(username)) {\n            throw new SecurityException(\"Invalid username\");\n        }\n        \n        try {\n            // Use XPath variables for safe parameterization\n            XPathFactory xpathFactory = XPathFactory.newInstance();\n            XPath xpath = xpathFactory.newXPath();\n            \n            // Compile the XPath expression\n            XPathExpression expr = xpath.compile(\"//users/user[username=$username]\");\n            \n            // Set the variable safely\n            XPathVariableResolver variableResolver = new SimpleVariableResolver(Map.of(\"username\", username));\n            xpath.setXPathVariableResolver(variableResolver);\n            \n            return (NodeList) expr.evaluate(document, XPathConstants.NODESET);\n            \n        } catch (Exception e) {\n            logger.error(\"XPath query failed for username: {}\", username, e);\n            throw new XPathExpressionException(\"Query execution failed\");\n        }\n    }\n    \n    // Alternative secure implementation using built-in XML processing\n    public List<User> findUsersSecurely(String username) {\n        if (!isValidUsername(username)) {\n            return Collections.emptyList();\n        }\n        \n        List<User> users = new ArrayList<>();\n        \n        try {\n            // Use DOM traversal instead of dynamic XPath\n            NodeList userNodes = document.getElementsByTagName(\"user\");\n            \n            for (int i = 0; i < userNodes.getLength(); i++) {\n                Element userElement = (Element) userNodes.item(i);\n                \n                // Safely extract username\n                NodeList usernameNodes = userElement.getElementsByTagName(\"username\");\n                if (usernameNodes.getLength() > 0) {\n                    String usernameText = usernameNodes.item(0).getTextContent();\n                    \n                    // Compare safely\n                    if (username.equals(usernameText)) {\n                        User user = parseUserElement(userElement);\n                        users.add(user);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Error finding users\", e);\n        }\n        \n        return users;\n    }\n    \n    // Secure authentication check\n    public boolean authenticateUser(String username, String password) {\n        if (!isValidUsername(username) || !isValidPassword(password)) {\n            return false;\n        }\n        \n        try {\n            // Use safe DOM traversal instead of dynamic XPath\n            NodeList userNodes = document.getElementsByTagName(\"user\");\n            \n            for (int i = 0; i < userNodes.getLength(); i++) {\n                Element userElement = (Element) userNodes.item(i);\n                \n                String storedUsername = getElementText(userElement, \"username\");\n                String storedPassword = getElementText(userElement, \"password\");\n                String storedSalt = getElementText(userElement, \"salt\");\n                \n                // Compare securely\n                if (username.equals(storedUsername)) {\n                    String hashedPassword = hashPassword(password, storedSalt);\n                    return hashedPassword.equals(storedPassword);\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Authentication error for user: {}\", username, e);\n        }\n        \n        return false;\n    }\n    \n    // Input validation methods\n    private boolean isValidUsername(String username) {\n        if (username == null || username.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check length\n        if (username.length() < 3 || username.length() > 50) {\n            return false;\n        }\n        \n        // Check for XPath injection patterns\n        String[] dangerousPatterns = {\n            \"'\", \"\\\"\", \"//\", \"/*\", \"|\", \"&\", \"and\", \"or\", \"not\",\n            \"=\", \"!=\", \"<\", \">\", \"<=\", \">=\", \"(\", \")\", \"[\", \"]\",\n            \"..\", \"/\", \"@\", \"::\", \"node()\", \"text()\", \"comment()\"\n        };\n        \n        String lowerUsername = username.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerUsername.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        // Only allow alphanumeric characters and basic symbols\n        return username.matches(\"^[a-zA-Z0-9._-]+$\");\n    }\n    \n    private boolean isValidPassword(String password) {\n        return password != null && \n               password.length() >= 8 && \n               password.length() <= 128;\n    }\n    \n    // Helper methods\n    private String getElementText(Element parent, String tagName) {\n        NodeList nodes = parent.getElementsByTagName(tagName);\n        return nodes.getLength() > 0 ? nodes.item(0).getTextContent() : \"\";\n    }\n    \n    private User parseUserElement(Element userElement) {\n        User user = new User();\n        user.setUsername(getElementText(userElement, \"username\"));\n        user.setEmail(getElementText(userElement, \"email\"));\n        user.setRole(getElementText(userElement, \"role\"));\n        return user;\n    }\n    \n    private String hashPassword(String password, String salt) {\n        // Implement secure password hashing\n        return BCrypt.hashpw(password + salt, BCrypt.gensalt());\n    }\n}\n\n// ==========================\n// SIMPLE VARIABLE RESOLVER FOR XPATH\n// ==========================\npublic class SimpleVariableResolver implements XPathVariableResolver {\n    private final Map<String, String> variables;\n    \n    public SimpleVariableResolver(Map<String, String> variables) {\n        this.variables = new HashMap<>(variables);\n    }\n    \n    @Override\n    public Object resolveVariable(QName variableName) {\n        String name = variableName.getLocalPart();\n        return variables.get(name);\n    }\n}\n\n// ==========================\n// SECURE XML DOCUMENT LOADER\n// ==========================\n@Component\npublic class SecureXmlDocumentLoader {\n    private static final Logger logger = LoggerFactory.getLogger(SecureXmlDocumentLoader.class);\n    \n    public Document loadSecureDocument(String filePath) throws Exception {\n        // Validate file path\n        if (!isValidFilePath(filePath)) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        \n        Path path = Paths.get(filePath).normalize();\n        if (!path.startsWith(\"/secure/xml/\") {\n            throw new SecurityException(\"Access denied\");\n        }\n        \n        // Configure secure XML parsing\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        \n        // Security features\n        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n        \n        DocumentBuilder builder = factory.newDocumentBuilder();\n        \n        // Set secure entity resolver\n        builder.setEntityResolver((publicId, systemId) -> {\n            logger.warn(\"External entity resolution blocked: {}\", systemId);\n            return new InputSource(new StringReader(\"\"));\n        });\n        \n        // Set error handler\n        builder.setErrorHandler(new ErrorHandler() {\n            @Override\n            public void warning(SAXParseException exception) throws SAXException {\n                logger.warn(\"XML parsing warning\", exception);\n            }\n            \n            @Override\n            public void error(SAXParseException exception) throws SAXException {\n                logger.error(\"XML parsing error\", exception);\n                throw exception;\n            }\n            \n            @Override\n            public void fatalError(SAXParseException exception) throws SAXException {\n                logger.error(\"XML parsing fatal error\", exception);\n                throw exception;\n            }\n        });\n        \n        Document document = builder.parse(path.toFile());\n        \n        // Additional security validation\n        validateDocumentStructure(document);\n        \n        return document;\n    }\n    \n    private boolean isValidFilePath(String filePath) {\n        if (filePath == null || filePath.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for path traversal\n        if (filePath.contains(\"..\") || filePath.contains(\"~\")) {\n            return false;\n        }\n        \n        // Check file extension\n        return filePath.toLowerCase().endsWith(\".xml\");\n    }\n    \n    private void validateDocumentStructure(Document document) throws SecurityException {\n        // Check for suspicious content\n        NodeList scriptNodes = document.getElementsByTagName(\"script\");\n        if (scriptNodes.getLength() > 0) {\n            throw new SecurityException(\"Script elements detected in XML\");\n        }\n        \n        // Check for external entity references\n        String xmlContent = documentToString(document);\n        if (xmlContent.contains(\"&\") && xmlContent.contains(\";\")) {\n            // Additional entity validation needed\n            validateEntities(xmlContent);\n        }\n    }\n    \n    private void validateEntities(String xmlContent) throws SecurityException {\n        // Check for dangerous entity references\n        String[] dangerousEntities = {\"&lt;\", \"&gt;\", \"&amp;\", \"&quot;\", \"&apos;\"};\n        for (String entity : dangerousEntities) {\n            if (xmlContent.contains(entity)) {\n                // These are typically safe, but monitor usage\n                logger.debug(\"Entity reference found: {}\", entity);\n            }\n        }\n    }\n    \n    private String documentToString(Document document) {\n        try {\n            TransformerFactory tf = TransformerFactory.newInstance();\n            Transformer transformer = tf.newTransformer();\n            StringWriter writer = new StringWriter();\n            transformer.transform(new DOMSource(document), new StreamResult(writer));\n            return writer.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}\n\n// ==========================\n// XPATH INJECTION PREVENTION FILTER\n// ==========================\n@Component\npublic class XPathInjectionFilter implements Filter {\n    \n    private static final String[] XPATH_INJECTION_PATTERNS = {\n        \"'\", \"\\\"\", \"//\", \"/*\", \"|\", \"&\", \"and\", \"or\", \"not\",\n        \"=\", \"!=\", \"<\", \">\", \"<=\", \">=\", \"(\", \")\", \"[\", \"]\",\n        \"..\", \"/\", \"@\", \"::\", \"node()\", \"text()\", \"comment()\",\n        \"position()\", \"last()\", \"count()\", \"name()\", \"local-name()\",\n        \"namespace-uri()\", \"string()\", \"number()\", \"boolean()\"\n    };\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Check all parameters for XPath injection attempts\n        if (containsXPathInjection(httpRequest)) {\n            logger.warn(\"XPath injection attempt detected from IP: {}\", getClientIpAddress(httpRequest));\n            httpResponse.setStatus(HttpStatus.FORBIDDEN.value());\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private boolean containsXPathInjection(HttpServletRequest request) {\n        // Check parameters\n        Enumeration<String> parameterNames = request.getParameterNames();\n        while (parameterNames.hasMoreElements()) {\n            String paramName = parameterNames.nextElement();\n            String[] paramValues = request.getParameterValues(paramName);\n            \n            for (String value : paramValues) {\n                if (containsXPathPatterns(value)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean containsXPathPatterns(String input) {\n        if (input == null) {\n            return false;\n        }\n        \n        String lowerInput = input.toLowerCase();\n        return Arrays.stream(XPATH_INJECTION_PATTERNS)\n            .anyMatch(lowerInput::contains);\n    }\n    \n    private String getClientIpAddress(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        return request.getRemoteAddr();\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 90023,
    "title": "XML External Entity Attack",
    "defaultRisk": "High",
    "cweid": "611",
    "description": "XML External Entity (XXE) attacks occur when XML input containing a reference to an external entity is processed by a misconfigured XML parser, potentially leading to information disclosure, server-side request forgery, or denial of service.",
    "simplified_description": "Your application has a dangerous XML processing vulnerability that allows attackers to access files on your server or make requests to internal systems. This is like giving someone a special remote control that can access your file cabinets and make phone calls on your behalf - they can read sensitive files, scan your internal network, and potentially take over systems.",
    "solution": "Disable XML external entity processing, use secure XML parser configurations, validate XML input, implement input sanitization, and use JSON as a safer alternative when possible.",
    "simplified_solution": "Turn off all external entity processing in your XML parsers, disable DTD processing completely, use modern XML libraries with secure defaults, validate all XML input structure and content, consider using JSON instead of XML for data exchange, and implement proper input validation.",
    "references": [
      {
        "name": "OWASP XXE Prevention",
        "url": "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
      },
      {
        "name": "CWE-611: Improper Restriction of XML External Entity Reference",
        "url": "https://cwe.mitre.org/data/definitions/611.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "XXE Attack Prevention",
        "solution_description": "Comprehensive XXE prevention including secure XML parser configuration, input validation, and alternative data formats.",
        "affected_files": "XML processing code, configuration parsers, SOAP web services, file upload handlers, data import utilities",
        "code": "// ==========================\n// SECURE XML PROCESSING CONFIGURATION\n// ==========================\npublic class SecureXmlProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(SecureXmlProcessor.class);\n    \n    /**\n     * Creates a secure DocumentBuilderFactory with XXE protection\n     */\n    public static DocumentBuilderFactory createSecureDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        \n        try {\n            // Core security features\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            \n            // Disable DTDs entirely (most secure)\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            \n            // Disable external entities\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            \n            // Disable XInclude\n            factory.setXIncludeAware(false);\n            \n            // Don't expand entity references\n            factory.setExpandEntityReferences(false);\n            \n            // Disable standalone document declaration\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            \n            return factory;\n        } catch (ParserConfigurationException e) {\n            logger.error(\"Failed to configure secure XML parser\", e);\n            throw new RuntimeException(\"XML parser configuration failed\", e);\n        }\n    }\n    \n    /**\n     * Creates a secure SAXParserFactory with XXE protection\n     */\n    public static SAXParserFactory createSecureSAXParserFactory() {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        \n        try {\n            // Security features\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setXIncludeAware(false);\n            \n            return factory;\n        } catch (ParserConfigurationException | SAXNotRecognizedException | SAXNotSupportedException e) {\n            logger.error(\"Failed to configure secure SAX parser\", e);\n            throw new RuntimeException(\"SAX parser configuration failed\", e);\n        }\n    }\n    \n    /**\n     * Creates a secure XMLInputFactory for StAX parsing\n     */\n    public static XMLInputFactory createSecureXMLInputFactory() {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        \n        // Disable DTDs\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        // Disable external entities\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);\n        factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        \n        // Disable XInclude\n        factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        \n        return factory;\n    }\n}\n\n// ==========================\n// SECURE XML DOCUMENT PROCESSOR\n// ==========================\n@Component\npublic class SecureXmlDocumentProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(SecureXmlDocumentProcessor.class);\n    \n    public Document processXmlDocument(String xmlContent) throws SecurityException {\n        if (!isValidXmlContent(xmlContent)) {\n            throw new SecurityException(\"Invalid XML content detected\");\n        }\n        \n        try {\n            DocumentBuilderFactory factory = SecureXmlProcessor.createSecureDocumentBuilderFactory();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Set custom entity resolver that blocks all external entities\n            builder.setEntityResolver(new SecureEntityResolver());\n            \n            // Set error handler for security validation\n            builder.setErrorHandler(new SecureErrorHandler());\n            \n            // Parse the XML\n            Document document = builder.parse(new InputSource(new StringReader(xmlContent)));\n            \n            // Additional validation\n            validateDocumentSecurity(document);\n            \n            return document;\n            \n        } catch (Exception e) {\n            logger.error(\"XML processing failed\", e);\n            throw new SecurityException(\"XML processing failed\", e);\n        }\n    }\n    \n    public String processXmlToJson(String xmlContent) {\n        try {\n            Document document = processXmlDocument(xmlContent);\n            \n            // Convert to JSON safely\n            ObjectMapper mapper = new ObjectMapper();\n            return convertDocumentToJson(document, mapper);\n            \n        } catch (Exception e) {\n            logger.error(\"XML to JSON conversion failed\", e);\n            throw new RuntimeException(\"Conversion failed\", e);\n        }\n    }\n    \n    private boolean isValidXmlContent(String xmlContent) {\n        if (xmlContent == null || xmlContent.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous patterns\n        String[] dangerousPatterns = {\n            \"<!DOCTYPE\", \"<!ENTITY\", \"SYSTEM\", \"PUBLIC\",\n            \"&\", \"<!\", \"<![CDATA[\", \"<?xml\", \"xmlns\"\n        };\n        \n        String lowerContent = xmlContent.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerContent.contains(pattern)) {\n                logger.warn(\"Potentially dangerous XML pattern detected: {}\", pattern);\n                // Allow some patterns but be more restrictive\n                if (pattern.equals(\"<!DOCTYPE\") || pattern.equals(\"<!ENTITY\") || pattern.equals(\"SYSTEM\")) {\n                    return false; // Block these immediately\n                }\n            }\n        }\n        \n        // Check for extremely large content (DoS protection)\n        if (xmlContent.length() > 10_000_000) { // 10MB limit\n            return false;\n        }\n        \n        return true;\n    }\n    \n    private void validateDocumentSecurity(Document document) throws SecurityException {\n        // Check for unexpected elements\n        NodeList suspiciousNodes = document.getElementsByTagName(\"!\");\n        if (suspiciousNodes.getLength() > 0) {\n            throw new SecurityException(\"Suspicious XML elements detected\");\n        }\n        \n        // Check for processing instructions\n        NodeList processingInstructions = document.getChildNodes();\n        for (int i = 0; i < processingInstructions.getLength(); i++) {\n            Node node = processingInstructions.item(i);\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                throw new SecurityException(\"Processing instructions not allowed\");\n            }\n        }\n    }\n    \n    private String convertDocumentToJson(Document document, ObjectMapper mapper) throws JsonProcessingException {\n        // Implement safe XML to JSON conversion\n        Map<String, Object> result = new HashMap<>();\n        Element root = document.getDocumentElement();\n        \n        result.put(\"rootTag\", root.getTagName());\n        result.put(\"attributes\", getAttributes(root));\n        result.put(\"children\", getChildElements(root));\n        \n        return mapper.writeValueAsString(result);\n    }\n    \n    private Map<String, String> getAttributes(Element element) {\n        Map<String, String> attributes = new HashMap<>();\n        NamedNodeMap attributeNodes = element.getAttributes();\n        \n        for (int i = 0; i < attributeNodes.getLength(); i++) {\n            Node attr = attributeNodes.item(i);\n            attributes.put(attr.getNodeName(), attr.getNodeValue());\n        }\n        \n        return attributes;\n    }\n    \n    private List<Map<String, Object>> getChildElements(Element parent) {\n        List<Map<String, Object>> children = new ArrayList<>();\n        NodeList childNodes = parent.getChildNodes();\n        \n        for (int i = 0; i < childNodes.getLength(); i++) {\n            Node child = childNodes.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                Element childElement = (Element) child;\n                Map<String, Object> childMap = new HashMap<>();\n                \n                childMap.put(\"tag\", childElement.getTagName());\n                childMap.put(\"attributes\", getAttributes(childElement));\n                childMap.put(\"text\", childElement.getTextContent());\n                childMap.put(\"children\", getChildElements(childElement));\n                \n                children.add(childMap);\n            }\n        }\n        \n        return children;\n    }\n}\n\n// ==========================\n// SECURE ENTITY RESOLVER\n// ==========================\npublic class SecureEntityResolver implements EntityResolver {\n    private static final Logger logger = LoggerFactory.getLogger(SecureEntityResolver.class);\n    \n    @Override\n    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n        // Block all external entity resolution\n        logger.warn(\"External entity resolution blocked - PublicId: {}, SystemId: {}\", publicId, systemId);\n        \n        // Return empty input source to prevent resolution\n        return new InputSource(new StringReader(\"\"));\n    }\n}\n\n// ==========================\n// SECURE ERROR HANDLER\n// ==========================\npublic class SecureErrorHandler implements ErrorHandler {\n    private static final Logger logger = LoggerFactory.getLogger(SecureErrorHandler.class);\n    \n    @Override\n    public void warning(SAXParseException exception) throws SAXException {\n        logger.warn(\"XML parsing warning\", exception);\n        // Don't expose detailed error information\n    }\n    \n    @Override\n    public void error(SAXParseException exception) throws SAXException {\n        logger.error(\"XML parsing error\", exception);\n        // Throw generic error to prevent information disclosure\n        throw new SAXException(\"XML parsing failed\");\n    }\n    \n    @Override\n    public void fatalError(SAXParseException exception) throws SAXException {\n        logger.error(\"XML parsing fatal error\", exception);\n        // Throw generic error to prevent information disclosure\n        throw new SAXException(\"XML parsing failed\");\n    }\n}\n\n// ==========================\n// JSON AS SECURE ALTERNATIVE\n// ==========================\n@Component\npublic class JsonDataProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(JsonDataProcessor.class);\n    \n    public Map<String, Object> processJsonData(String jsonContent) throws SecurityException {\n        if (!isValidJsonContent(jsonContent)) {\n            throw new SecurityException(\"Invalid JSON content detected\");\n        }\n        \n        try {\n            ObjectMapper mapper = createSecureObjectMapper();\n            return mapper.readValue(jsonContent, new TypeReference<Map<String, Object>>() {});\n        } catch (Exception e) {\n            logger.error(\"JSON processing failed\", e);\n            throw new SecurityException(\"JSON processing failed\", e);\n        }\n    }\n    \n    private ObjectMapper createSecureObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        \n        // Security features\n        mapper.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);\n        mapper.disable(JsonParser.Feature.ALLOW_COMMENTS);\n        mapper.disable(JsonParser.Feature.ALLOW_YAML_COMMENTS);\n        mapper.disable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);\n        mapper.disable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);\n        mapper.disable(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER);\n        mapper.disable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);\n        mapper.disable(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS);\n        \n        return mapper;\n    }\n    \n    private boolean isValidJsonContent(String jsonContent) {\n        if (jsonContent == null || jsonContent.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous patterns\n        String[] dangerousPatterns = {\n            \"<script\", \"javascript:\", \"eval(\", \"exec(\",\n            \"<?php\", \"<%\", \"__proto__\", \"constructor\", \"prototype\"\n        };\n        \n        String lowerContent = jsonContent.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerContent.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        // Check size\n        if (jsonContent.length() > 10_000_000) { // 10MB limit\n            return false;\n        }\n        \n        return true;\n    }\n}\n\n// ==========================\n// XXE PREVENTION FILTER\n// ==========================\n@Component\npublic class XxePreventionFilter implements Filter {\n    \n    private static final String[] XXE_PATTERNS = {\n        \"<!DOCTYPE\", \"<!ENTITY\", \"SYSTEM\", \"PUBLIC\", \"&\", \"<![CDATA[\"\n    };\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Check for XML content\n        if (isXmlContent(httpRequest)) {\n            String xmlContent = getRequestBody(httpRequest);\n            \n            if (containsXxePatterns(xmlContent)) {\n                logger.warn(\"XXE attack attempt detected from IP: {}\", getClientIpAddress(httpRequest));\n                httpResponse.setStatus(HttpStatus.FORBIDDEN.value());\n                return;\n            }\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private boolean isXmlContent(HttpServletRequest request) {\n        String contentType = request.getContentType();\n        return contentType != null && contentType.contains(\"application/xml\");\n    }\n    \n    private String getRequestBody(HttpServletRequest request) {\n        try {\n            BufferedReader reader = request.getReader();\n            return reader.lines().collect(Collectors.joining(\"\\\\n\"));\n        } catch (IOException e) {\n            return \"\";\n        }\n    }\n    \n    private boolean containsXxePatterns(String input) {\n        if (input == null) {\n            return false;\n        }\n        \n        String lowerInput = input.toLowerCase();\n        return Arrays.stream(XXE_PATTERNS)\n            .anyMatch(lowerInput::contains);\n    }\n    \n    private String getClientIpAddress(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        return request.getRemoteAddr();\n    }\n}\n\n// ==========================\n// CONFIGURATION EXAMPLES\n// ==========================\n/*\n1. Spring Boot application.properties:\n   spring.xml.parser.feature-secure-processing=true\n   spring.xml.parser.disallow-doctype-decl=true\n   spring.xml.parser.external-general-entities=false\n   spring.xml.parser.external-parameter-entities=false\n   spring.xml.parser.xinclude-aware=false\n   spring.xml.parser.expand-entity-references=false\n\n2. Java System Properties:\n   -Djavax.xml.parsers.DocumentBuilderFactory=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl\n   -Djavax.xml.stream.XMLInputFactory=com.ctc.wstx.stax.WstxInputFactory\n\n3. Library-specific configurations:\n\n   JAXB:\n   System.setProperty(\"javax.xml.accessExternalDTD\", \"\");\n   System.setProperty(\"javax.xml.accessExternalSchema\", \"\");\n\n   StAX:\n   XMLInputFactory factory = XMLInputFactory.newFactory();\n   factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n   factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\n   Jackson with XML:\n   XmlMapper mapper = new XmlMapper();\n   mapper.disable(JsonXml.Feature.AUTO_DETECT_FIELDS);\n   mapper.disable(JsonXml.Feature.AUTO_DETECT_GETTERS);\n   mapper.disable(JsonXml.Feature.AUTO_DETECT_IS_GETTERS);\n   mapper.enable(JsonXml.Feature.FAIL_ON_UNKNOWN_PROPERTIES);\n*/"
      }
    ]
  },
  {
    "pluginId": 90024,
    "title": "Generic Padding Oracle",
    "defaultRisk": "High",
    "cweid": "203",
    "description": "Padding Oracle vulnerabilities occur when an application reveals different error messages or timing behavior for valid vs. invalid padding in cryptographic operations. This allows attackers to decrypt ciphertexts without knowing the encryption key through adaptive chosen ciphertext attacks.",
    "simplified_description": "Your application has a cryptographic weakness that leaks information about whether encrypted data is correctly formatted. Attackers can exploit this to gradually decrypt sensitive information by watching how your application responds to specially crafted encrypted messages. This is like playing a game of 'hot or cold' where the application tells attackers when they're getting closer to the correct decryption.",
    "solution": "Implement constant-time error handling, use authenticated encryption (AEAD) modes, and ensure consistent response times regardless of padding validation results.",
    "simplified_solution": "Use modern authenticated encryption methods like AES-GCM that include built-in integrity protection, implement consistent error handling that doesn't reveal whether padding is valid, add random delays to prevent timing attacks, and avoid implementing custom cryptography.",
    "references": [
      {
        "name": "OWASP Padding Oracle Attack",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Padding_Oracle_Cheat_Sheet.html"
      },
      {
        "name": "CWE-203: Observable Discrepancy",
        "url": "https://cwe.mitre.org/data/definitions/203.html"
      },
      {
        "name": "Vaudenay, 2002 - Security Flaws in the Implementation of a Cryptographic Protocol",
        "url": "https://link.springer.com/chapter/10.1007/3-540-46035-7_23"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Authenticated Encryption Implementation",
        "solution_description": "This comprehensive solution demonstrates how to prevent padding oracle attacks by implementing authenticated encryption (AEAD) modes, constant-time operations, and proper error handling. It provides secure alternatives to vulnerable CBC mode encryption, includes proper key management, and implements timing-attack resistant validation.",
        "affected_files": "Encryption/decryption services, authentication controllers, API endpoints handling encrypted data, cryptographic utilities, session management systems, data protection modules, configuration files with encryption settings",
        "code": "// =========================================================\n// SECURE ENCRYPTION - PREVENT PADDING ORACLE ATTACKS\n// =========================================================\n\n// BEFORE (VULNERABLE): CBC mode with padding oracle\n/*\npublic class VulnerableEncryption {\n    \n    public String decrypt(String encryptedData) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\n        \n        try {\n            byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedData));\n            return new String(decrypted);\n        } catch (BadPaddingException e) {\n            throw new SecurityException(\"Invalid padding detected\"); // Leaks padding info\n        } catch (IllegalBlockSizeException e) {\n            throw new SecurityException(\"Invalid block size\"); // Different error\n        }\n    }\n}\n*/\n\n// AFTER (SECURE): Authenticated Encryption with constant-time operations\n@Service\npublic class SecureEncryptionService {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/GCM/NoPadding\";\n    private static final int GCM_IV_LENGTH = 12;\n    private static final int GCM_TAG_LENGTH = 16;\n    private static final int KEY_SIZE = 256;\n    \n    private final SecretKey secretKey;\n    private final SecureRandom secureRandom;\n    private final Logger logger = LoggerFactory.getLogger(SecureEncryptionService.class);\n    \n    public SecureEncryptionService() {\n        this.secureRandom = new SecureRandom();\n        this.secretKey = generateSecureKey();\n    }\n    \n    // Generate secure encryption key\n    private SecretKey generateSecureKey() {\n        try {\n            KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);\n            keyGenerator.init(KEY_SIZE);\n            return keyGenerator.generateKey();\n        } catch (NoSuchAlgorithmException e) {\n            throw new SecurityException(\"Failed to generate encryption key\", e);\n        }\n    }\n    \n    /**\n     * Encrypt data using AES-GCM (Authenticated Encryption)\n     */\n    public EncryptedData encrypt(String plaintext) {\n        if (plaintext == null) {\n            throw new IllegalArgumentException(\"Plaintext cannot be null\");\n        }\n        \n        try {\n            // Generate random IV\n            byte[] iv = new byte[GCM_IV_LENGTH];\n            secureRandom.nextBytes(iv);\n            \n            // Initialize cipher\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);\n            \n            // Add additional authenticated data (AAD) for extra security\n            String aad = \"MyApp-v1.0\";\n            cipher.updateAAD(aad.getBytes(StandardCharsets.UTF_8));\n            \n            // Encrypt\n            byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));\n            \n            // Combine IV and ciphertext\n            byte[] encryptedData = new byte[iv.length + ciphertext.length];\n            System.arraycopy(iv, 0, encryptedData, 0, iv.length);\n            System.arraycopy(ciphertext, 0, encryptedData, iv.length, ciphertext.length);\n            \n            return new EncryptedData(\n                Base64.getEncoder().encodeToString(encryptedData),\n                aad,\n                System.currentTimeMillis()\n            );\n            \n        } catch (GeneralSecurityException e) {\n            logger.error(\"Encryption failed\", e);\n            throw new SecurityException(\"Encryption operation failed\");\n        }\n    }\n    \n    /**\n     * Decrypt data with constant-time operations and proper error handling\n     */\n    public String decrypt(EncryptedData encryptedData) {\n        if (encryptedData == null || encryptedData.getData() == null) {\n            throw new IllegalArgumentException(\"Encrypted data cannot be null\");\n        }\n        \n        try {\n            byte[] encryptedBytes = Base64.getDecoder().decode(encryptedData.getData());\n            \n            if (encryptedBytes.length < GCM_IV_LENGTH + GCM_TAG_LENGTH) {\n                throw new SecurityException(\"Invalid encrypted data format\");\n            }\n            \n            // Extract IV and ciphertext\n            byte[] iv = Arrays.copyOfRange(encryptedBytes, 0, GCM_IV_LENGTH);\n            byte[] ciphertext = Arrays.copyOfRange(encryptedBytes, GCM_IV_LENGTH, encryptedBytes.length);\n            \n            // Initialize cipher\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);\n            cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec);\n            \n            // Add same AAD as encryption\n            String expectedAad = \"MyApp-v1.0\";\n            if (!expectedAad.equals(encryptedData.getAdditionalAuthenticatedData())) {\n                throw new SecurityException(\"Invalid additional authenticated data\");\n            }\n            cipher.updateAAD(expectedAad.getBytes(StandardCharsets.UTF_8));\n            \n            // Decrypt with constant-time operation\n            byte[] decrypted = cipher.doFinal(ciphertext);\n            \n            return new String(decrypted, StandardCharsets.UTF_8);\n            \n        } catch (GeneralSecurityException | IllegalArgumentException e) {\n            // Log generic error without revealing specific failure\n            logger.warn(\"Decryption operation failed: encryptedDataId={}\", \n                       encryptedData.getTimestamp());\n            \n            // Constant-time delay to prevent timing attacks\n            performConstantTimeOperation();\n            \n            throw new SecurityException(\"Decryption operation failed\");\n        }\n    }\n    \n    /**\n     * Perform constant-time operation to prevent timing attacks\n     */\n    private void performConstantTimeOperation() {\n        // Always perform some work regardless of success/failure\n        byte[] dummy = new byte[64];\n        secureRandom.nextBytes(dummy);\n        \n        // Constant-time hash calculation\n        int result = 0;\n        for (byte b : dummy) {\n            result ^= b;\n        }\n        \n        // Use the result to prevent compiler optimization\n        assert result != Integer.MAX_VALUE;\n    }\n    \n    /**\n     * Constant-time string comparison to prevent timing attacks\n     */\n    public static boolean constantTimeEquals(String a, String b) {\n        if (a == null || b == null) {\n            return false;\n        }\n        \n        byte[] aBytes = a.getBytes(StandardCharsets.UTF_8);\n        byte[] bBytes = b.getBytes(StandardCharsets.UTF_8);\n        \n        return MessageDigest.isEqual(aBytes, bBytes);\n    }\n}\n\n// =========================================================\n// SECURE DATA STRUCTURES\n// =========================================================\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class EncryptedData {\n    private String data;  // Base64 encoded IV + ciphertext\n    private String additionalAuthenticatedData;\n    private long timestamp;\n    \n    public boolean isValid(int maxAgeMinutes) {\n        long ageInMillis = System.currentTimeMillis() - timestamp;\n        return ageInMillis <= (maxAgeMinutes * 60 * 1000L);\n    }\n}\n\n// =========================================================\n// SECURE AUTHENTICATION CONTROLLER\n// =========================================================\n\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class SecureAuthenticationController {\n    \n    private final SecureEncryptionService encryptionService;\n    private final AuthenticationService authService;\n    private final SecureRandom secureRandom;\n    private final Logger logger = LoggerFactory.getLogger(SecureAuthenticationController.class);\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestBody LoginRequest request) {\n        try {\n            // Add random delay to prevent timing attacks\n            addRandomDelay(50, 150);\n            \n            // Perform authentication\n            AuthenticationResult result = authService.authenticate(request);\n            \n            if (result.isSuccess()) {\n                // Encrypt user session data\n                String sessionData = String.format(\"%s:%s:%d\", \n                    result.getUserId(), \n                    result.getUsername(),\n                    System.currentTimeMillis());\n                \n                EncryptedData encryptedSession = encryptionService.encrypt(sessionData);\n                \n                return ResponseEntity.ok(AuthenticationResponse.builder()\n                    .token(generateJWT(result.getUser()))\n                    .sessionToken(encryptedSession.getData())\n                    .expiresIn(3600)\n                    .build());\n                    \n            } else {\n                // Always perform some work regardless of result\n                encryptionService.encrypt(\"dummy data\");\n                \n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                    .body(ErrorResponse.builder()\n                        .message(\"Invalid credentials\")\n                        .timestamp(System.currentTimeMillis())\n                        .build());\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Authentication error\", e);\n            \n            // Always perform dummy encryption to maintain consistent timing\n            try {\n                encryptionService.encrypt(\"dummy data\");\n            } catch (Exception ignored) {}\n            \n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(ErrorResponse.builder()\n                    .message(\"Authentication failed\")\n                    .timestamp(System.currentTimeMillis())\n                    .build());\n        }\n    }\n    \n    @PostMapping(\"/validate\")\n    public ResponseEntity<?> validateToken(@RequestBody TokenValidationRequest request) {\n        try {\n            // Add consistent delay\n            Thread.sleep(100);\n            \n            // Decrypt and validate session token\n            if (request.getSessionToken() != null) {\n                EncryptedData encryptedData = EncryptedData.builder()\n                    .data(request.getSessionToken())\n                    .additionalAuthenticatedData(\"MyApp-v1.0\")\n                    .timestamp(System.currentTimeMillis() - 60000) // Assume 1 minute old\n                    .build();\n                \n                String sessionData = encryptionService.decrypt(encryptedData);\n                \n                // Validate session format and age\n                if (validateSessionData(sessionData)) {\n                    return ResponseEntity.ok(ValidationResponse.builder()\n                        .valid(true)\n                        .message(\"Session valid\")\n                        .build());\n                }\n            }\n            \n            return ResponseEntity.ok(ValidationResponse.builder()\n                .valid(false)\n                .message(\"Invalid session\")\n                .build());\n                \n        } catch (Exception e) {\n            // Always return generic error, don't reveal specific failure\n            return ResponseEntity.ok(ValidationResponse.builder()\n                .valid(false)\n                .message(\"Invalid session\")\n                .build());\n        }\n    }\n    \n    private void addRandomDelay(int minMs, int maxMs) {\n        try {\n            int delay = minMs + secureRandom.nextInt(maxMs - minMs);\n            Thread.sleep(delay);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    private boolean validateSessionData(String sessionData) {\n        try {\n            String[] parts = sessionData.split(\":\");\n            if (parts.length != 3) {\n                return false;\n            }\n            \n            long userId = Long.parseLong(parts[0]);\n            String username = parts[1];\n            long timestamp = Long.parseLong(parts[2]);\n            \n            // Check session age (24 hours max)\n            long age = System.currentTimeMillis() - timestamp;\n            return age <= (24 * 60 * 60 * 1000L) && userId > 0 && !username.isEmpty();\n            \n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n\n// =========================================================\n// MIGRATION HELPER - FROM VULNERABLE CBC TO SECURE GCM\n// =========================================================\n\n@Component\npublic class EncryptionMigrationService {\n    \n    private final SecureEncryptionService secureEncryptionService;\n    private final VulnerableEncryptionService vulnerableEncryptionService;\n    private final Logger logger = LoggerFactory.getLogger(EncryptionMigrationService.class);\n    \n    /**\n     * Migrate data from vulnerable CBC encryption to secure GCM encryption\n     */\n    @Scheduled(fixedDelay = 86400000) // Run daily\n    public void migrateEncryptedData() {\n        logger.info(\"Starting encryption data migration...\");\n        \n        List<EncryptedDataRecord> records = getVulnerableEncryptedRecords();\n        int migrated = 0;\n        int failed = 0;\n        \n        for (EncryptedDataRecord record : records) {\n            try {\n                // Decrypt using old vulnerable method\n                String plaintext = vulnerableEncryptionService.decrypt(record.getEncryptedData());\n                \n                // Re-encrypt using secure method\n                EncryptedData secureEncrypted = secureEncryptionService.encrypt(plaintext);\n                \n                // Update record\n                record.setEncryptedData(secureEncrypted.getData());\n                record.setEncryptionMethod(\"AES-GCM\");\n                record.setMigratedAt(System.currentTimeMillis());\n                \n                saveRecord(record);\n                migrated++;\n                \n            } catch (Exception e) {\n                logger.error(\"Failed to migrate record: {}\", record.getId(), e);\n                failed++;\n            }\n        }\n        \n        logger.info(\"Migration completed: {} successful, {} failed\", migrated, failed);\n    }\n    \n    private List<EncryptedDataRecord> getVulnerableEncryptedRecords() {\n        // Implement database query for records using old encryption\n        return List.of(); // Placeholder\n    }\n    \n    private void saveRecord(EncryptedDataRecord record) {\n        // Implement database save\n    }\n}\n\n// =========================================================\n// CONFIGURATION FOR SECURE ENCRYPTION\n// =========================================================\n\n@Configuration\n@EnableConfigurationProperties(EncryptionProperties.class)\npublic class EncryptionConfiguration {\n    \n    @Bean\n    @Primary\n    public SecureEncryptionService secureEncryptionService(EncryptionProperties properties) {\n        return new SecureEncryptionService();\n    }\n    \n    @Bean\n    public SecretKey encryptionKey(EncryptionProperties properties) {\n        try {\n            // Load key from secure key management system\n            String base64Key = properties.getKey();\n            if (base64Key == null || base64Key.isEmpty()) {\n                throw new IllegalStateException(\"Encryption key not configured\");\n            }\n            \n            byte[] keyBytes = Base64.getDecoder().decode(base64Key);\n            return new SecretKeySpec(keyBytes, \"AES\");\n            \n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to initialize encryption key\", e);\n        }\n    }\n}\n\n@Data\n@ConfigurationProperties(prefix = \"security.encryption\")\npublic class EncryptionProperties {\n    private String key;\n    private String algorithm = \"AES/GCM/NoPadding\";\n    private int keySize = 256;\n    private int ivLength = 12;\n    private int tagLength = 16;\n}\n\n// application.yml\n/*\nsecurity:\n  encryption:\n    key: ${ENCRYPTION_KEY:your-base64-encoded-256-bit-key-here}\n    algorithm: AES/GCM/NoPadding\n    keySize: 256\n    ivLength: 12\n    tagLength: 16\n*/\n\n// =========================================================\n// TESTING FRAMEWORK FOR PADDING ORACLE\n// =========================================================\n\n@SpringBootTest\npublic class PaddingOracleSecurityTest {\n    \n    @Autowired\n    private SecureEncryptionService encryptionService;\n    \n    @Test\n    public void testEncryptionDecryptionConsistency() {\n        String plaintext = \"This is a test message for padding oracle prevention\";\n        \n        // Encrypt\n        EncryptedData encrypted = encryptionService.encrypt(plaintext);\n        \n        // Decrypt\n        String decrypted = encryptionService.decrypt(encrypted);\n        \n        // Should be equal\n        assertEquals(plaintext, decrypted);\n    }\n    \n    @Test\n    public void testModifiedDataDetection() {\n        String plaintext = \"Test message\";\n        EncryptedData encrypted = encryptionService.encrypt(plaintext);\n        \n        // Modify encrypted data\n        String modifiedData = modifyEncryptedData(encrypted.getData());\n        \n        // Create new encrypted data with modified content\n        EncryptedData modifiedEncrypted = EncryptedData.builder()\n            .data(modifiedData)\n            .additionalAuthenticatedData(encrypted.getAdditionalAuthenticatedData())\n            .timestamp(encrypted.getTimestamp())\n            .build();\n        \n        // Should throw exception\n        assertThrows(SecurityException.class, () -> {\n            encryptionService.decrypt(modifiedEncrypted);\n        });\n    }\n    \n    @Test\n    public void testConstantTimeOperations() {\n        // Test that decryption takes similar time for valid and invalid data\n        String plaintext = \"Test message\";\n        EncryptedData validEncrypted = encryptionService.encrypt(plaintext);\n        EncryptedData invalidEncrypted = createInvalidEncryptedData();\n        \n        long validTime = measureDecryptionTime(validEncrypted);\n        long invalidTime = measureDecryptionTime(invalidEncrypted);\n        \n        // Time difference should be small (within 50ms)\n        assertTrue(Math.abs(validTime - invalidTime) < 50);\n    }\n    \n    private String modifyEncryptedData(String base64Data) {\n        byte[] data = Base64.getDecoder().decode(base64Data);\n        // Flip a bit in the middle\n        data[data.length / 2] ^= 0x01;\n        return Base64.getEncoder().encodeToString(data);\n    }\n    \n    private EncryptedData createInvalidEncryptedData() {\n        return EncryptedData.builder()\n            .data(\"invalid-base64-data\")\n            .additionalAuthenticatedData(\"MyApp-v1.0\")\n            .timestamp(System.currentTimeMillis())\n            .build();\n    }\n    \n    private long measureDecryptionTime(EncryptedData encryptedData) {\n        long start = System.nanoTime();\n        try {\n            encryptionService.decrypt(encryptedData);\n        } catch (Exception ignored) {\n            // Ignore exceptions for timing measurement\n        }\n        long end = System.nanoTime();\n        return (end - start) / 1_000_000; // Convert to milliseconds\n    }\n}\n\n// =========================================================\n// SECURITY MONITORING AND ALERTS\n// =========================================================\n\n@Component\npublic class PaddingOracleMonitor {\n    \n    private final MeterRegistry meterRegistry;\n    private final Logger logger = LoggerFactory.getLogger(PaddingOracleMonitor.class);\n    \n    private final Counter decryptionAttempts;\n    private final Counter decryptionFailures;\n    private final Timer decryptionTimer;\n    \n    public PaddingOracleMonitor(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        this.decryptionAttempts = Counter.builder(\"encryption.decryption.attempts\")\n            .description(\"Total decryption attempts\")\n            .register(meterRegistry);\n        this.decryptionFailures = Counter.builder(\"encryption.decryption.failures\")\n            .description(\"Decryption failures\")\n            .register(meterRegistry);\n        this.decryptionTimer = Timer.builder(\"encryption.decryption.duration\")\n            .description(\"Decryption operation duration\")\n            .register(meterRegistry);\n    }\n    \n    @EventListener\n    public void handleDecryptionAttempt(DecryptionAttemptEvent event) {\n        decryptionAttempts.increment();\n        \n        Timer.Sample sample = Timer.start(meterRegistry);\n        \n        try {\n            // Decrypt operation happens here\n            event.getResult();\n            \n        } catch (Exception e) {\n            decryptionFailures.increment();\n            \n            // Alert on unusual failure patterns\n            if (decryptionFailures.count() % 10 == 0) {\n                logger.warn(\"Unusual number of decryption failures detected: {}\", \n                           decryptionFailures.count());\n                \n                // Send alert to security team\n                sendSecurityAlert(\"High number of decryption failures detected\");\n            }\n        } finally {\n            sample.stop(decryptionTimer);\n        }\n    }\n    \n    private void sendSecurityAlert(String message) {\n        // Implement alert notification system\n        logger.error(\"SECURITY ALERT: {}\", message);\n    }\n}\n\n// =========================================================\n// AUTOMATED SECURITY TESTING\n// =========================================================\n\n/*\nPADDING ORACLE TESTING PROCEDURES:\n\n1. Automated Vulnerability Scanning:\n   - Integrate OWASP ZAP padding oracle scan\n   - Use custom scripts to test endpoints\n   - Run in CI/CD pipeline\n   - Schedule periodic scans\n\n2. Manual Testing:\n   - Test API endpoints with malformed encrypted data\n   - Monitor error response patterns\n   - Measure response times for different inputs\n   - Check for information leakage\n\n3. Tools and Commands:\n   - padbuster.py: Automated padding oracle testing\n   - Burp Suite: Custom encrypted payload testing\n   - OWASP ZAP: Passive scanning\n   - Custom timing analysis tools\n\n4. Monitoring:\n   - Track decryption failure rates\n   - Monitor response time patterns\n   - Alert on unusual behavior\n   - Log security events\n\n5. Testing Script Example:\n\n#!/bin/bash\n# Test for padding oracle vulnerability\n\necho \"Testing for padding oracle vulnerability...\"\n\n# Test with invalid padding\nINVALID_BASE64=\"INVALID+BASE64/DATA=\"\nRESPONSE1=$(curl -s -X POST \"http://localhost:8080/api/auth/validate\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"sessionToken\":\"'$INVALID_BASE64'\"}')\n\necho \"Response to invalid data: $RESPONSE1\"\n\n# Test with valid format but modified content\nMODIFIED_BASE64=$(echo \"dGVzdC1kYXRhLXdpdGgtbW9kaWZpZWQtcGFkZGluZw==\" | base64)\nRESPONSE2=$(curl -s -X POST \"http://localhost:8080/api/auth/validate\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"sessionToken\":\"'$MODIFIED_BASE64'\"}')\n\necho \"Response to modified data: $RESPONSE2\"\n\n# Compare responses\nif [[ \"$RESPONSE1\" != \"$RESPONSE2\" ]]; then\n    echo \"WARNING: Different responses detected - possible padding oracle\"\nelse\n    echo \"OK: Consistent responses\"\nfi\n\n6. Security Validation Checklist:\n   - ✅ Use authenticated encryption (AES-GCM)\n   - ✅ Constant-time error handling\n   - ✅ Random delays to prevent timing attacks\n   - ✅ Generic error messages\n   - ✅ Input validation\n   - ✅ Proper key management\n   - ✅ Regular security audits\n   - ✅ Automated testing\n*/"
      }
    ]
  },
  {
    "pluginId": 90024,
    "title": "Generic Padding Oracle",
    "defaultRisk": "High",
    "cweid": 203,
    "description": "Padding Oracle vulnerabilities occur when an application reveals different error messages or timing behavior for valid vs. invalid padding in cryptographic operations. This allows attackers to decrypt ciphertexts without knowing the encryption key through adaptive chosen ciphertext attacks. The vulnerability arises when an application processes encrypted data (typically using CBC mode with PKCS#7 padding) and provides distinguishable responses based on padding validation results.",
    "simplified_description": "Your application has a cryptographic weakness that leaks information about whether encrypted data is correctly formatted. Attackers can exploit this to gradually decrypt sensitive information by watching how your application responds to specially crafted encrypted messages. This is like playing a game of 'hot or cold' where the application tells attackers when they're getting closer to the correct decryption - through different error messages, response times, or HTTP status codes that reveal whether padding was valid or not.",
    "solution": "Implement constant-time error handling, use authenticated encryption (AEAD) modes, and ensure consistent response times regardless of padding validation results.",
    "simplified_solution": "Use modern authenticated encryption methods like AES-GCM that include built-in integrity protection, implement consistent error handling that doesn't reveal whether padding is valid, add random delays to prevent timing attacks, and avoid implementing custom cryptography. Replace vulnerable CBC mode encryption with authenticated encryption modes that provide both confidentiality and integrity protection.",
    "references": [
      {
        "name": "OWASP Padding Oracle Attack",
        "url": "https://owasp.org/www-project-cheat-sheets/cheatsheets/Padding_Oracle_Cheat_Sheet.html"
      },
      {
        "name": "CWE-203: Observable Discrepancy",
        "url": "https://cwe.mitre.org/data/definitions/203.html"
      },
      {
        "name": "NIST SP 800-38D - Recommendation for Block Cipher Modes of Operation",
        "url": "https://csrc.nist.gov/publications/detail/sp/800-38d/final"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Authenticated Encryption Implementation",
        "solution_description": "Replace vulnerable CBC mode encryption with authenticated encryption (AEAD) modes like AES-GCM. Implement constant-time error handling, add random delays to prevent timing attacks, and use proper key derivation functions.",
        "affected_files": "Encryption/decryption services, authentication controllers, API endpoints handling encrypted data, cryptographic utilities, session management systems, data protection modules, configuration files with encryption settings",
        "code": "import javax.crypto.Cipher;\nimport javax.crypto.spec.GCMParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class SecureEncryption {\n    private static final String AEAD_ALGORITHM = \"AES/GCM/NoPadding\";\n    private static final int GCM_IV_LENGTH = 12;\n    private static final int GCM_TAG_LENGTH = 16;\n    \n    private final SecretKeySpec encryptionKey;\n    private final SecureRandom secureRandom;\n    \n    // Secure encryption with authentication\n    public String encrypt(String plaintext) {\n        try {\n            byte[] iv = new byte[GCM_IV_LENGTH];\n            secureRandom.nextBytes(iv);\n            \n            Cipher cipher = Cipher.getInstance(AEAD_ALGORITHM);\n            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);\n            cipher.init(Cipher.ENCRYPT_MODE, encryptionKey, gcmSpec);\n            \n            // Add AAD for context binding\n            cipher.updateAAD(\"application:v1\".getBytes());\n            \n            byte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n            return Base64.getEncoder().encodeToString(iv) + \":\" + \n                   Base64.getEncoder().encodeToString(ciphertext);\n        } catch (Exception e) {\n            throw new SecurityException(\"Encryption failed\");\n        }\n    }\n    \n    // Constant-time decryption with unified error handling\n    public String decrypt(String encryptedData) {\n        addRandomDelay(10, 50); // Prevent timing attacks\n        \n        try {\n            String[] parts = encryptedData.split(\":\");\n            byte[] iv = Base64.getDecoder().decode(parts[0]);\n            byte[] ciphertext = Base64.getDecoder().decode(parts[1]);\n            \n            Cipher cipher = Cipher.getInstance(AEAD_ALGORITHM);\n            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);\n            cipher.init(Cipher.DECRYPT_MODE, encryptionKey, gcmSpec);\n            cipher.updateAAD(\"application:v1\".getBytes());\n            \n            return new String(cipher.doFinal(ciphertext));\n        } catch (Exception e) {\n            return handleDecryptionFailure(); // Always same response\n        }\n    }\n    \n    private String handleDecryptionFailure() {\n        // Perform dummy operations to normalize timing\n        try {\n            Cipher dummyCipher = Cipher.getInstance(AEAD_ALGORITHM);\n            byte[] dummyIv = new byte[GCM_IV_LENGTH];\n            GCMParameterSpec dummySpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, dummyIv);\n            dummyCipher.init(Cipher.ENCRYPT_MODE, encryptionKey, dummySpec);\n            dummyCipher.doFinal(\"dummy\".getBytes());\n        } catch (Exception ignored) {}\n        \n        addRandomDelay(10, 50);\n        throw new SecurityException(\"Data processing failed\");\n    }\n    \n    private void addRandomDelay(int minMs, int maxMs) {\n        try {\n            Thread.sleep(minMs + (int)(Math.random() * (maxMs - minMs)));\n        } catch (InterruptedException ignored) {}\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 90033,
    "title": "Loosely Scoped Cookie",
    "defaultRisk": "Medium",
    "cweid": "565",
    "description": "Loosely scoped cookie vulnerabilities occur when cookies are configured with overly broad scope settings such as wide domain paths, insecure protocols, or missing SameSite restrictions, allowing attackers to steal cookies through cross-site attacks, network interception, or malicious subdomain exploitation.",
    "simplified_description": "Your application is using cookies that are accessible to too many websites or situations, like giving out master keys that work on multiple buildings. Attackers can steal these overly permissive cookies from subdomains, insecure connections, or cross-site requests and use them to impersonate users, access sensitive data, and perform unauthorized actions.",
    "solution": "Implement strict cookie scope settings including specific domain restrictions, Secure flag for HTTPS only, HttpOnly flag, and proper SameSite attributes.",
    "simplified_solution": "Configure all cookies with the most restrictive settings possible. Set the Domain attribute to your exact domain, use the Path attribute to limit cookie scope, enable the Secure flag for HTTPS-only transmission, set HttpOnly to prevent JavaScript access, and use SameSite=Strict or SameSite=Lax to prevent cross-site attacks. Never use overly broad cookie scopes.",
    "references": [
      {
        "name": "OWASP Session Management Cheat Sheet",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
      },
      {
        "name": "CWE-565: Reliance on Cookies without Validation and Integrity Checking",
        "url": "https://cwe.mitre.org/data/definitions/565.html"
      },
      {
        "name": "MDN Web Docs - HTTP cookies",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Secure Cookie Configuration Implementation",
        "solution_description": "This solution demonstrates comprehensive secure cookie configuration including strict domain scoping, path restrictions, security flags, SameSite attributes, and proper validation for web applications across multiple programming languages and frameworks.",
        "affected_files": "Authentication middleware, session management systems, API controllers, configuration files, web server settings, frontend JavaScript",
        "code": "<?php\n// ============================================\n// SECURE COOKIE MANAGER\n// ============================================\n\nclass SecureCookieManager {\n    private $defaultOptions;\n    private $secureDomains;\n    \n    public function __construct(array $config = []) {\n        $this->secureDomains = $config['secure_domains'] ?? [];\n        $this->defaultOptions = [\n            'expires' => 0,\n            'path' => '/',\n            'domain' => $this->getSecureDomain(),\n            'secure' => true,\n            'httponly' => true,\n            'samesite' => 'Strict'\n        ];\n    }\n    \n    /**\n     * Set secure cookie with strict scoping\n     */\n    public function setSecureCookie(\n        string $name,\n        string $value,\n        array $options = []\n    ): bool {\n        $mergedOptions = array_merge($this->defaultOptions, $options);\n        \n        // Validate and sanitize cookie options\n        $this->validateCookieOptions($name, $mergedOptions);\n        \n        // Set cookie with secure options\n        return setcookie(\n            $name,\n            $value,\n            [\n                'expires' => $mergedOptions['expires'],\n                'path' => $mergedOptions['path'],\n                'domain' => $mergedOptions['domain'],\n                'secure' => $mergedOptions['secure'],\n                'httponly' => $mergedOptions['httponly'],\n                'samesite' => $mergedOptions['samesite']\n            ]\n        );\n    }\n    \n    /**\n     * Set session cookie with maximum security\n     */\n    public function setSessionCookie(string $sessionId): bool {\n        $options = [\n            'expires' => 0, // Session cookie\n            'path' => $this->getSessionPath(),\n            'domain' => $this->getSecureDomain(),\n            'secure' => true,\n            'httponly' => true,\n            'samesite' => 'Strict'\n        ];\n        \n        return $this->setSecureCookie('SESSION_ID', $sessionId, $options);\n    }\n    \n    /**\n     * Set authentication token cookie\n     */\n    public function setAuthTokenCookie(string $token, int $expiry = 3600): bool {\n        $options = [\n            'expires' => time() + $expiry,\n            'path' => '/api/',\n            'domain' => $this->getSecureDomain(),\n            'secure' => true,\n            'httponly' => true,\n            'samesite' => 'Strict'\n        ];\n        \n        return $this->setSecureCookie('AUTH_TOKEN', $token, $options);\n    }\n    \n    /**\n     * Set preferences cookie with relaxed security (accessible to JS)\n     */\n    public function setPreferencesCookie(array $preferences): bool {\n        $options = [\n            'expires' => time() + (86400 * 30), // 30 days\n            'path' => '/',\n            'domain' => $this->getSecureDomain(),\n            'secure' => true,\n            'httponly' => false, // Allow JavaScript access\n            'samesite' => 'Lax'\n        ];\n        \n        return $this->setSecureCookie(\n            'USER_PREFS',\n            json_encode($preferences),\n            $options\n        );\n    }\n    \n    /**\n     * Get secure domain for cookies\n     */\n    private function getSecureDomain(): string {\n        $host = $_SERVER['HTTP_HOST'] ?? '';\n        \n        // Remove port if present\n        $host = parse_url('http://' . $host, PHP_URL_HOST) ?: $host;\n        \n        // For localhost in development\n        if (in_array($host, ['localhost', '127.0.0.1'])) {\n            return '';\n        }\n        \n        // For production, ensure we don't set overly broad domain\n        if (!empty($this->secureDomains)) {\n            foreach ($this->secureDomains as $domain) {\n                if ($this->matchesDomain($host, $domain)) {\n                    return $domain;\n                }\n            }\n        }\n        \n        // Default to current host without subdomain wildcards\n        return $host;\n    }\n    \n    /**\n     * Get appropriate session path\n     */\n    private function getSessionPath(): string {\n        $basePath = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH) ?: '/';\n        \n        // For session cookies, use the root path to ensure availability\n        return '/';\n    }\n    \n    /**\n     * Check if host matches allowed domain pattern\n     */\n    private function matchesDomain(string $host, string $pattern): bool {\n        if ($pattern === $host) {\n            return true;\n        }\n        \n        // Check subdomain match (only allow exact domain or immediate subdomains)\n        if (strpos($pattern, '.') !== false) {\n            $baseDomain = $pattern;\n            if (substr($host, -strlen($baseDomain)) === $baseDomain) {\n                $subdomain = substr($host, 0, -strlen($baseDomain));\n                return $subdomain === '' || $subdomain === '.';\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Validate cookie options for security\n     */\n    private function validateCookieOptions(string $name, array &$options): void {\n        // Ensure secure flag is set for HTTPS\n        if ($this->isHttpsConnection() && !$options['secure']) {\n            $options['secure'] = true;\n        }\n        \n        // Validate domain doesn't have leading dot\n        if (isset($options['domain']) && $options['domain']) {\n            $options['domain'] = ltrim($options['domain'], '.');\n        }\n        \n        // Ensure SameSite attribute is valid\n        if (isset($options['samesite'])) {\n            $validSameSite = ['Strict', 'Lax', 'None'];\n            if (!in_array($options['samesite'], $validSameSite)) {\n                $options['samesite'] = 'Strict';\n            }\n        }\n        \n        // For None SameSite, Secure must be true\n        if (isset($options['samesite']) && $options['samesite'] === 'None') {\n            $options['secure'] = true;\n            $options['httponly'] = true;\n        }\n    }\n    \n    /**\n     * Check if connection is HTTPS\n     */\n    private function isHttpsConnection(): bool {\n        return (\n            (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ||\n            $_SERVER['SERVER_PORT'] == 443 ||\n            (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && \n             $_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https')\n        );\n    }\n    \n    /**\n     * Delete cookie securely\n     */\n    public function deleteCookie(string $name): bool {\n        return setcookie(\n            $name,\n            '',\n            [\n                'expires' => time() - 3600,\n                'path' => '/',\n                'domain' => $this->getSecureDomain(),\n                'secure' => true,\n                'httponly' => true,\n                'samesite' => 'Strict'\n            ]\n        );\n    }\n    \n    /**\n     * Get cookie value with validation\n     */\n    public function getCookie(string $name): ?string {\n        if (isset($_COOKIE[$name])) {\n            // Validate cookie value format\n            $value = $_COOKIE[$name];\n            \n            // Basic validation - reject suspicious values\n            if ($this->isValidCookieValue($value)) {\n                return $value;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Validate cookie value for security\n     */\n    private function isValidCookieValue(string $value): bool {\n        // Check length\n        if (strlen($value) > 4096) {\n            return false;\n        }\n        \n        // Check for suspicious characters\n        $suspiciousChars = [\"\\n\", \"\\r\", \"\\0\", \"\\t\", \"\\f\", \"\\v\"];\n        foreach ($suspiciousChars as $char) {\n            if (strpos($value, $char) !== false) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 90034,
    "title": "Cloud Metadata Potentially Exposed",
    "defaultRisk": "High",
    "cweid": 200,
    "description": "The application may be exposing cloud service provider metadata endpoints, allowing attackers to access sensitive cloud instance information including credentials, network configurations, and instance metadata. This can lead to privilege escalation and lateral movement within cloud environments.",
    "simplified_description": "Your application might be exposing your cloud server's internal information to attackers, like leaving your server's configuration files and passwords publicly accessible. Attackers can exploit this to steal cloud credentials, access other servers in your network, and potentially take over your entire cloud infrastructure.",
    "solution": "Restrict access to cloud metadata endpoints through proper network security groups, firewall rules, and application-level controls. Implement metadata filtering, use IAM roles instead of instance credentials, and monitor for unauthorized access attempts. Configure reverse proxies to block metadata endpoint access.",
    "simplified_solution": "Update your cloud security settings to block access to internal metadata endpoints. Configure firewalls and security groups to prevent external access to metadata URLs like 169.254.169.254. Use proper IAM roles for authentication instead of storing credentials in metadata. Monitor for any attempts to access these internal services.",
    "references": [
      {
        "name": "OWASP Serverless Top 10",
        "url": "https://owasp.org/www-project-serverless-top-10/"
      },
      {
        "name": "AWS Instance Metadata Service",
        "url": "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html"
      },
      {
        "name": "Google Cloud Metadata Server",
        "url": "https://cloud.google.com/compute/docs/metadata/overview"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Cloud Security Configuration",
        "solution_description": "This comprehensive solution addresses cloud metadata exposure across major cloud providers (AWS, GCP, Azure). It includes network security configurations, application-level filtering, reverse proxy configurations, IAM best practices, and continuous monitoring. The solution provides both immediate mitigation and long-term security improvements.",
        "affected_files": "Cloud security group configurations, firewall rules, reverse proxy configurations (Nginx/Apache), application security middleware, IAM policies, monitoring configurations",
        "code": "# Cloud Metadata Exposure Protection\n# Comprehensive Security Configuration for AWS, GCP, Azure\n\n# ======================================\n# AWS METADATA PROTECTION\n# ======================================\n\n# AWS Security Group Configuration\n# Block outbound access to metadata service from public-facing instances\n{\n  \"Description\": \"Security group for web servers with metadata protection\",\n  \"GroupName\": \"WebServerSecurityGroup\",\n  \"IpPermissions\": [\n    {\n      \"IpProtocol\": \"tcp\",\n      \"FromPort\": 80,\n      \"ToPort\": 80,\n      \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]\n    },\n    {\n      \"IpProtocol\": \"tcp\",\n      \"FromPort\": 443,\n      \"ToPort\": 443,\n      \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]\n    }\n  ],\n  \"IpPermissionsEgress\": [\n    {\n      \"IpProtocol\": \"tcp\",\n      \"FromPort\": 80,\n      \"ToPort\": 80,\n      \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]\n    },\n    {\n      \"IpProtocol\": \"tcp\",\n      \"FromPort\": 443,\n      \"ToPort\": 443,\n      \"IpRanges\": [{\"CidrIp\": \"0.0.0.0/0\"}]\n    },\n    {\n      \"IpProtocol\": \"-1\",\n      \"IpRanges\": [{\"CidrIp\": \"169.254.0.0/16\", \"Description\": \"Block metadata access\"}]\n    }\n  ]\n}\n\n# AWS NACL Configuration (Network ACL)\naws ec2 create-network-acl-entry \\\n  --network-acl-id acl-12345678 \\\n  --rule-number 100 \\\n  --protocol -1 \\\n  --rule-action deny \\\n  --egress \\\n  --cidr-block 169.254.0.0/16 \\\n  --port-range From=0,To=65535\n\n# ======================================\n# REVERSE PROXY CONFIGURATION\n# ======================================\n\n# Nginx configuration to block metadata access\n# /etc/nginx/sites-available/default\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n    \n    # Block metadata access\n    location ~* ^/169\\.254\\.169\\.254 {\n        deny all;\n        return 404;\n    }\n    \n    # Block common metadata patterns\n    location ~* (metadata|latest|iam/security-credentials) {\n        deny all;\n        return 404;\n    }\n    \n    # Block internal IP ranges\n    location ~* ^/(169\\.254|10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.) {\n        deny all;\n        return 404;\n    }\n    \n    # Your regular configuration\n    location / {\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        \n        # Filter out metadata headers\n        proxy_set_header X-Forwarded-Proto \"\";\n        proxy_hide_header X-Forwarded-Proto;\n        proxy_hide_header X-Real-IP;\n    }\n    \n    # Security headers\n    add_header X-Frame-Options DENY always;\n    add_header X-Content-Type-Options nosniff always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n}\n\n# Apache configuration to block metadata access\n# /etc/apache2/sites-available/000-default.conf\n\n<VirtualHost *:443>\n    ServerName example.com\n    DocumentRoot /var/www/html\n    \n    # Block metadata access\n    <Location \"/169.254.169.254\">\n        Require all denied\n    </Location>\n    \n    <LocationMatch \"^/(metadata|latest|iam/security-credentials)\">\n        Require all denied\n    </LocationMatch>\n    \n    # Block internal IP ranges\n    <LocationMatch \"^/(169\\.254|10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.)\">\n        Require all denied\n    </LocationMatch>\n    \n    # ModSecurity rules for enhanced protection\n    SecRuleEngine On\n    SecRule REQUEST_URI \"@rx (169\\.254\\.169\\.254|metadata|latest|iam/security-credentials)\" \\\n        \"phase:1,log,deny,id:1001,status:403,msg:'Cloud metadata access blocked'\"\n</VirtualHost>\n\n# ======================================\n# GOOGLE CLOUD PLATFORM PROTECTION\n# ======================================\n\n# GCP Firewall Rules\ngcloud compute firewall-rules create block-metadata-access \\\n    --description \"Block access to metadata server\" \\\n    --direction EGRESS \\\n    --priority 1000 \\\n    --destination-ranges 169.254.169.254 \\\n    --rules DENY \\\n    --target-tags web-server\n\n# GCP IAM Best Practices\n# Use service accounts instead of default credentials\ngcloud iam service-accounts create web-app-sa \\\n    --description \"Web application service account\" \\\n    --display-name \"Web App SA\"\n\n# Grant minimum required permissions\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n    --member=\"serviceAccount:web-app-sa@PROJECT_ID.iam.gserviceaccount.com\" \\\n    --role=\"roles/logging.logWriter\"\n\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n    --member=\"serviceAccount:web-app-sa@PROJECT_ID.iam.gserviceaccount.com\" \\\n    --role=\"roles/monitoring.metricWriter\"\n\n# ======================================\n# AZURE METADATA PROTECTION\n# ======================================\n\n# Azure Network Security Group Rules\naz network nsg rule create \\\n    --resource-group MyResourceGroup \\\n    --nsg-name MyNetworkSecurityGroup \\\n    --name BlockMetadataAccess \\\n    --protocol * \\\n    --direction Outbound \\\n    --priority 1000 \\\n    --destination-address-prefixes 169.254.169.254 \\\n    --access Deny\n\n# Azure Managed Identity\n# Enable managed identity for VMs\naz vm identity assign \\\n    --resource-group MyResourceGroup \\\n    --name MyVM\n\n# ======================================\n# APPLICATION-LEVEL PROTECTION\n# ======================================\n\n# Node.js Express middleware for metadata protection\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Metadata protection middleware\nconst blockMetadataAccess = (req, res, next) => {\n    const blockedPatterns = [\n        /169\\.254\\.169\\.254/,\n        /metadata/i,\n        /latest/i,\n        /iam\\/security-credentials/,\n        /instance\\.metadata/i\n    ];\n    \n    const userAgent = req.get('User-Agent') || '';\n    const requestUri = req.url;\n    const headers = JSON.stringify(req.headers);\n    \n    // Check if request targets metadata\n    for (const pattern of blockedPatterns) {\n        if (pattern.test(requestUri) || pattern.test(userAgent) || pattern.test(headers)) {\n            console.warn(`Metadata access attempt blocked: ${req.ip} - ${requestUri}`);\n            return res.status(404).send('Not Found');\n        }\n    }\n    \n    next();\n};\n\n// Apply middleware\napp.use(helmet());\napp.use(blockMetadataAccess);\n\n# Python Flask middleware for metadata protection\nfrom flask import Flask, request, abort\nimport re\nfrom functools import wraps\n\napp = Flask(__name__)\n\n# Metadata protection decorator\ndef block_metadata(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        blocked_patterns = [\n            r'169\\.254\\.169\\.254',\n            r'metadata',\n            r'latest',\n            r'iam/security-credentials',\n            r'instance\\.metadata'\n        ]\n        \n        request_uri = request.path\n        user_agent = request.headers.get('User-Agent', '')\n        \n        # Check if request targets metadata\n        for pattern in blocked_patterns:\n            if (re.search(pattern, request_uri, re.IGNORECASE) or \n                re.search(pattern, user_agent, re.IGNORECASE)):\n                app.logger.warning(f'Metadata access attempt blocked: {request.remote_addr} - {request_uri}')\n                abort(404)\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n# Apply to all routes\n@app.before_request\ndef check_metadata_access():\n    blocked_patterns = [\n        r'169\\.254\\.169\\.254',\n        r'metadata',\n        r'latest',\n        r'iam/security-credentials'\n    ]\n    \n    request_uri = request.path\n    \n    for pattern in blocked_patterns:\n        if re.search(pattern, request_uri, re.IGNORECASE):\n            app.logger.warning(f'Metadata access attempt: {request.remote_addr} - {request_uri}')\n            abort(404)\n\n# ======================================\n# PHP APPLICATION PROTECTION\n# ======================================\n\n<?php\n// Metadata protection middleware\nclass MetadataProtection {\n    private $blockedPatterns = [\n        '/169\\.254\\.169\\.254/',\n        '/metadata/i',\n        '/latest/i',\n        '/iam\\/security-credentials/i',\n        '/instance\\.metadata/i'\n    ];\n    \n    public function __construct() {\n        $this->checkRequest();\n    }\n    \n    private function checkRequest() {\n        $requestUri = $_SERVER['REQUEST_URI'] ?? '';\n        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';\n        $headers = $this->getAllHeaders();\n        \n        foreach ($this->blockedPatterns as $pattern) {\n            if (preg_match($pattern, $requestUri) || \n                preg_match($pattern, $userAgent) ||\n                $this->headersContainPattern($headers, $pattern)) {\n                \n                $this->logAttempt($requestUri, $_SERVER['REMOTE_ADDR']);\n                http_response_code(404);\n                exit('Not Found');\n            }\n        }\n    }\n    \n    private function getAllHeaders() {\n        $headers = [];\n        foreach ($_SERVER as $name => $value) {\n            if (strpos($name, 'HTTP_') === 0) {\n                $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;\n            }\n        }\n        return $headers;\n    }\n    \n    private function headersContainPattern($headers, $pattern) {\n        foreach ($headers as $name => $value) {\n            if (preg_match($pattern, $value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private function logAttempt($uri, $ip) {\n        $logMessage = sprintf(\n            '[%s] Metadata access attempt blocked: %s - %s',\n            date('Y-m-d H:i:s'),\n            $ip,\n            $uri\n        );\n        error_log($logMessage);\n    }\n}\n\n// Initialize at the beginning of your application\nnew MetadataProtection();\n\n# ======================================\n# CONTAINER SECURITY (KUBERNETES)\n# ======================================\n\n# Kubernetes NetworkPolicy to block metadata access\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: block-metadata-access\n  namespace: production\nspec:\n  podSelector:\n    matchLabels:\n      app: webapp\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 0.0.0.0/0\n        except:\n        - 169.254.0.0/16  # Block metadata service\n    ports:\n    - protocol: TCP\n      port: 443\n    - protocol: TCP\n      port: 80\n\n# Docker security configuration\nFROM node:16-alpine\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs && \\\n    adduser -S nodejs -u 1001\n\n# Set security context\nUSER nodejs\n\n# Health check without metadata access\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1\n\n# ======================================\n# MONITORING AND DETECTION\n# ======================================\n\n# AWS CloudWatch metric filter for metadata access attempts\naws logs put-metric-filter \\\n    --log-group-name /aws/ec2/webapp \\\n    --filter-name MetadataAccessAttempts \\\n    --filter-pattern '{ $.requestUri = \"*169.254.169.254*\" }' \\\n    --metric-transformations metricName=MetadataAccessAttempts,metricNamespace=WebAppMetrics,metricValue=1\n\n# CloudWatch alarm for metadata access\naws cloudwatch put-metric-alarm \\\n    --alarm-name MetadataAccessAlarm \\\n    --alarm-description \"Alarm for metadata access attempts\" \\\n    --metric-name MetadataAccessAttempts \\\n    --namespace WebAppMetrics \\\n    --statistic Sum \\\n    --period 300 \\\n    --threshold 1 \\\n    --comparison-operator GreaterThanOrEqualToThreshold \\\n    --evaluation-periods 1\n\n# Python script for continuous monitoring\nimport requests\nimport re\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('/var/log/metadata_monitor.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass MetadataMonitor:\n    def __init__(self):\n        self.metadata_patterns = [\n            r'169\\.254\\.169\\.254',\n            r'metadata',\n            r'latest',\n            r'iam/security-credentials',\n            r'instance\\.metadata'\n        ]\n        self.alert_threshold = 5\n        self.monitoring_window = 300  # 5 minutes\n    \n    def check_access_logs(self, log_file):\n        \"\"\"Check access logs for metadata access attempts\"\"\"\n        try:\n            with open(log_file, 'r') as f:\n                recent_attempts = []\n                current_time = datetime.now()\n                \n                for line in f:\n                    # Parse log entry (adjust based on your log format)\n                    if self.contains_metadata_pattern(line):\n                        timestamp = self.extract_timestamp(line)\n                        if timestamp and (current_time - timestamp).seconds < self.monitoring_window:\n                            recent_attempts.append(line)\n                \n                if len(recent_attempts) >= self.alert_threshold:\n                    self.send_alert(recent_attempts)\n                    \n                return len(recent_attempts)\n        except FileNotFoundError:\n            logging.error(f\"Log file not found: {log_file}\")\n            return 0\n    \n    def contains_metadata_pattern(self, log_entry):\n        \"\"\"Check if log entry contains metadata access pattern\"\"\"\n        for pattern in self.metadata_patterns:\n            if re.search(pattern, log_entry, re.IGNORECASE):\n                return True\n        return False\n    \n    def extract_timestamp(self, log_entry):\n        \"\"\"Extract timestamp from log entry\"\"\"\n        # Implement based on your log format\n        try:\n            # Example for Apache/Nginx logs\n            timestamp_str = log_entry.split('[')[1].split(']')[0]\n            return datetime.strptime(timestamp_str, '%d/%b/%Y:%H:%M:%S')\n        except:\n            return None\n    \n    def send_alert(self, attempts):\n        \"\"\"Send alert for metadata access attempts\"\"\"\n        alert_message = f\"ALERT: {len(attempts)} metadata access attempts detected\\n\\nRecent attempts:\\n\"\n        for attempt in attempts[-5:]:  # Last 5 attempts\n            alert_message += f\"{attempt.strip()}\\n\"\n        \n        # Send to monitoring system or email\n        logging.warning(alert_message)\n        \n        # Example: Send to Slack webhook\n        # requests.post('https://hooks.slack.com/...', json={'text': alert_message})\n    \n    def test_metadata_endpoint(self, endpoint='http://169.254.169.254/latest/meta-data/'):\n        \"\"\"Test if metadata endpoint is accessible\"\"\"\n        try:\n            response = requests.get(endpoint, timeout=5)\n            if response.status_code == 200:\n                logging.warning(f\"Metadata endpoint accessible: {endpoint}\")\n                return True\n            else:\n                logging.info(f\"Metadata endpoint blocked: {endpoint} (HTTP {response.status_code})\")\n                return False\n        except requests.exceptions.RequestException:\n            logging.info(f\"Metadata endpoint not accessible: {endpoint}\")\n            return False\n\n# Usage\nif __name__ == '__main__':\n    monitor = MetadataMonitor()\n    \n    # Test metadata endpoint access\n    monitor.test_metadata_endpoint()\n    \n    # Monitor access logs\n    log_files = ['/var/log/nginx/access.log', '/var/log/apache2/access.log']\n    \n    for log_file in log_files:\n        if os.path.exists(log_file):\n            attempts = monitor.check_access_logs(log_file)\n            logging.info(f\"Checked {log_file}: {attempts} recent attempts\")"
      }
    ]
  },
  {
    "pluginId": 90035,
    "title": "Server Side Template Injection",
    "defaultRisk": "High",
    "cweid": "94",
    "description": "Server Side Template Injection vulnerabilities occur when user input is unsafely incorporated into server-side templates, allowing attackers to inject template code that can lead to remote code execution, information disclosure, or system compromise.",
    "simplified_description": "Your application has a dangerous vulnerability that allows attackers to inject malicious template code that runs on your server. This is like letting someone write their own instructions into your official documents - they can execute commands, access files, and potentially take complete control of your server.",
    "solution": "Use secure template engines with sandboxing, implement strict input validation and sanitization, avoid concatenating user input into templates, use template parameters instead of direct injection, and keep template engines updated.",
    "simplified_solution": "Never put user input directly into template code, use template engines with built-in security features and sandboxing, validate all input before using it in templates, keep template libraries updated, and use safe template practices like parameter passing instead of string concatenation.",
    "references": [
      {
        "name": "OWASP Template Injection",
        "url": "https://owasp.org/www-community/attacks/Server_Side_Template_Injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Server-Side Template Injection Prevention",
        "solution_description": "Comprehensive SSTI prevention including secure template engine configuration, input validation, and safe template practices.",
        "affected_files": "Template files, view controllers, email templates, report generators, dynamic content systems",
        "code": "// ==========================\n// SECURE TEMPLATE ENGINE CONFIGURATION\n// ==========================\n@Configuration\npublic class SecureTemplateConfig {\n    \n    @Bean\n    public SpringTemplateEngine templateEngine() {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        \n        // Use secure template resolver\n        SecureTemplateResolver templateResolver = new SecureTemplateResolver();\n        templateResolver.setPrefix(\"/templates/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        templateResolver.setCharacterEncoding(\"UTF-8\");\n        \n        // Security settings\n        templateResolver.setCacheable(true);\n        templateResolver.setCheckExistence(true);\n        \n        templateEngine.setTemplateResolver(templateResolver);\n        \n        // Add secure message source\n        templateEngine.setTemplateEngineMessageSource(messageSource());\n        \n        return templateEngine;\n    }\n    \n    @Bean\n    public MessageSource messageSource() {\n        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n        messageSource.setBasename(\"messages\");\n        messageSource.setDefaultEncoding(\"UTF-8\");\n        return messageSource;\n    }\n}\n\n// ==========================\n// SECURE TEMPLATE RESOLVER\n// ==========================\npublic class SecureTemplateResolver extends ClassLoaderTemplateResolver {\n    \n    @Override\n    protected TemplateResource getTemplateResource(String templateLocation, String characterEncoding) {\n        // Validate template path to prevent path traversal\n        if (!isValidTemplatePath(templateLocation)) {\n            throw new SecurityException(\"Invalid template path: \" + templateLocation);\n        }\n        \n        TemplateResource resource = super.getTemplateResource(templateLocation, characterEncoding);\n        \n        // Validate template content\n        if (resource != null && resource.exists()) {\n            validateTemplateContent(resource);\n        }\n        \n        return resource;\n    }\n    \n    private boolean isValidTemplatePath(String templateLocation) {\n        if (templateLocation == null || templateLocation.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for path traversal\n        if (templateLocation.contains(\"..\") || templateLocation.contains(\"/\") || templateLocation.contains(\"\\\\\")) {\n            return false;\n        }\n        \n        // Check for dangerous characters\n        Pattern dangerousPattern = Pattern.compile(\"[<>:\\\"|?*\\\\\\\\;()&$`]\");\n        if (dangerousPattern.matcher(templateLocation).find()) {\n            return false;\n        }\n        \n        // Only allow alphanumeric, hyphens, and underscores\n        return templateLocation.matches(\"^[a-zA-Z0-9_-]+$\");\n    }\n    \n    private void validateTemplateContent(TemplateResource resource) {\n        try {\n            String content = IOUtils.toString(resource.getReader(), StandardCharsets.UTF_8);\n            \n            // Check for dangerous template expressions\n            String[] dangerousExpressions = {\n                \"${\", \"#{\", \"[[\", \"%{\", \"*{\",\n                \"T(\", \"#context\", \"#request\", \"#session\",\n                \"#exec\", \"#runtime\", \"#process\", \"#system\"\n            };\n            \n            for (String expr : dangerousExpressions) {\n                if (content.contains(expr)) {\n                    throw new SecurityException(\"Dangerous template expression detected: \" + expr);\n                }\n            }\n            \n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read template content\", e);\n        }\n    }\n}\n\n// ==========================\n// SECURE TEMPLATE SERVICE\n// ==========================\n@Service\npublic class SecureTemplateService {\n    private static final Logger logger = LoggerFactory.getLogger(SecureTemplateService.class);\n    \n    private final SpringTemplateEngine templateEngine;\n    private final InputValidator inputValidator;\n    \n    public SecureTemplateService(SpringTemplateEngine templateEngine, InputValidator inputValidator) {\n        this.templateEngine = templateEngine;\n        this.inputValidator = inputValidator;\n    }\n    \n    public String processTemplate(String templateName, Map<String, Object> variables) {\n        // Validate template name\n        if (!isValidTemplateName(templateName)) {\n            throw new SecurityException(\"Invalid template name: \" + templateName);\n        }\n        \n        // Validate and sanitize variables\n        Map<String, Object> sanitizedVariables = sanitizeTemplateVariables(variables);\n        \n        try {\n            // Create context with sanitized variables\n            Context context = new Context();\n            context.setVariables(sanitizedVariables);\n            \n            // Process the template\n            return templateEngine.process(templateName, context);\n            \n        } catch (Exception e) {\n            logger.error(\"Template processing failed for: {}\", templateName, e);\n            throw new RuntimeException(\"Template processing failed\", e);\n        }\n    }\n    \n    private boolean isValidTemplateName(String templateName) {\n        if (templateName == null || templateName.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous patterns\n        String[] dangerousPatterns = {\n            \"..\", \"/\", \"\\\\\", \"<\", \">\", \"\\\"\", \"'\", \"&\", \"|\",\n            \"${\", \"#{\", \"[[\", \"%{\", \"*{\"\n        };\n        \n        String lowerTemplateName = templateName.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerTemplateName.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        // Only allow alphanumeric characters, hyphens, and underscores\n        return templateName.matches(\"^[a-zA-Z0-9_-]+$\");\n    }\n    \n    private Map<String, Object> sanitizeTemplateVariables(Map<String, Object> variables) {\n        Map<String, Object> sanitized = new HashMap<>();\n        \n        for (Map.Entry<String, Object> entry : variables.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            \n            // Validate key\n            if (isValidVariableKey(key)) {\n                // Sanitize value\n                Object sanitizedValue = sanitizeValue(value);\n                sanitized.put(key, sanitizedValue);\n            } else {\n                logger.warn(\"Invalid template variable key blocked: {}\", key);\n            }\n        }\n        \n        return sanitized;\n    }\n    \n    private boolean isValidVariableKey(String key) {\n        if (key == null || key.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Only allow alphanumeric characters and underscores\n        return key.matches(\"^[a-zA-Z_][a-zA-Z0-9_]*$\");\n    }\n    \n    private Object sanitizeValue(Object value) {\n        if (value == null) {\n            return null;\n        }\n        \n        if (value instanceof String) {\n            return inputValidator.sanitize((String) value);\n        } else if (value instanceof Map) {\n            return sanitizeTemplateVariables((Map<String, Object>) value);\n        } else if (value instanceof Collection) {\n            Collection<?> collection = (Collection<?>) value;\n            return collection.stream()\n                .map(this::sanitizeValue)\n                .collect(Collectors.toList());\n        } else {\n            // For other types, ensure they are safe\n            return isSafeObjectType(value) ? value : null;\n        }\n    }\n    \n    private boolean isSafeObjectType(Object value) {\n        // Only allow primitive types, strings, and safe POJOs\n        return value instanceof Number ||\n               value instanceof Boolean ||\n               value instanceof Character ||\n               value instanceof String ||\n               value.getClass().isAnnotationPresent(Component.class) ||\n               value.getClass().getName().startsWith(\"com.example.domain.\");\n    }\n}\n\n// ==========================\n// SECURE EMAIL TEMPLATE SERVICE\n// ==========================\n@Service\npublic class SecureEmailTemplateService {\n    private static final Logger logger = LoggerFactory.getLogger(SecureEmailTemplateService.class);\n    \n    private final JavaMailSender mailSender;\n    private final SecureTemplateService templateService;\n    \n    public void sendTemplatedEmail(String to, String subject, String templateName, Map<String, Object> variables) {\n        // Validate email address\n        if (!isValidEmailAddress(to)) {\n            throw new SecurityException(\"Invalid email address: \" + to);\n        }\n        \n        // Validate template name\n        if (!isValidTemplateName(templateName)) {\n            throw new SecurityException(\"Invalid template name: \" + templateName);\n        }\n        \n        try {\n            // Process the template\n            String emailBody = templateService.processTemplate(templateName, variables);\n            \n            // Create and send email\n            SimpleMailMessage message = new SimpleMailMessage();\n            message.setTo(to);\n            message.setSubject(subject);\n            message.setText(emailBody);\n            \n            mailSender.send(message);\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to send templated email to: {}\", to, e);\n            throw new RuntimeException(\"Email sending failed\", e);\n        }\n    }\n    \n    private boolean isValidEmailAddress(String email) {\n        if (email == null || email.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Basic email validation\n        return email.matches(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$\");\n    }\n    \n    private boolean isValidTemplateName(String templateName) {\n        // Only allow specific email templates\n        Set<String> allowedTemplates = Set.of(\n            \"welcome-email\", \"password-reset\", \"order-confirmation\", \"newsletter\"\n        );\n        \n        return allowedTemplates.contains(templateName);\n    }\n}\n\n// ==========================\n// TEMPLATE INJECTION PREVENTION FILTER\n// ==========================\n@Component\npublic class TemplateInjectionFilter implements Filter {\n    \n    private static final String[] TEMPLATE_INJECTION_PATTERNS = {\n        \"${\", \"#{\", \"[[\", \"%{\", \"*{\",\n        \"T(\", \"#context\", \"#request\", \"#session\",\n        \"#exec\", \"#runtime\", \"#process\", \"#system\",\n        \"__\", \"getClass\", \"getClassLoader\", \"forName\"\n    };\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // Check all parameters for template injection attempts\n        if (containsTemplateInjection(httpRequest)) {\n            logger.warn(\"Template injection attempt detected from IP: {}\", getClientIpAddress(httpRequest));\n            httpResponse.setStatus(HttpStatus.FORBIDDEN.value());\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private boolean containsTemplateInjection(HttpServletRequest request) {\n        // Check parameters\n        Enumeration<String> parameterNames = request.getParameterNames();\n        while (parameterNames.hasMoreElements()) {\n            String paramName = parameterNames.nextElement();\n            String[] paramValues = request.getParameterValues(paramName);\n            \n            for (String value : paramValues) {\n                if (containsTemplatePatterns(value)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean containsTemplatePatterns(String input) {\n        if (input == null) {\n            return false;\n        }\n        \n        String lowerInput = input.toLowerCase();\n        return Arrays.stream(TEMPLATE_INJECTION_PATTERNS)\n            .anyMatch(lowerInput::contains);\n    }\n    \n    private String getClientIpAddress(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        return request.getRemoteAddr();\n    }\n}\n\n// ==========================\n// SECURE FREEMARKER CONFIGURATION\n// ==========================\n@Configuration\npublic class FreemarkerConfig {\n    \n    @Bean\n    public FreeMarkerConfigurer freemarkerConfigurer() {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPath(\"classpath:/templates/\");\n        \n        // Security settings\n        Properties properties = new Properties();\n        properties.setProperty(\"template_exception_handler\", \"rethrow\");\n        properties.setProperty(\"template_update_delay\", \"3600\");\n        properties.setProperty(\"default_encoding\", \"UTF-8\");\n        properties.setProperty(\"locale\", \"en_US\");\n        properties.setProperty(\"boolean_format\", \"true,false\");\n        properties.setProperty(\"datetime_format\", \"yyyy-MM-dd HH:mm:ss\");\n        properties.setProperty(\"date_format\", \"yyyy-MM-dd\");\n        properties.setProperty(\"time_format\", \"HH:mm:ss\");\n        properties.setProperty(\"number_format\", \"0.##########\");\n        properties.setProperty(\"whitespace_stripping\", \"true\");\n        \n        // Security - disable dangerous features\n        properties.setProperty(\"new_builtin_class_resolver\", \"unsafe\");\n        properties.setProperty(\"auto_import\", \"\");\n        properties.setProperty(\"auto_include\", \"\");\n        \n        configurer.setFreemarkerSettings(properties);\n        return configurer;\n    }\n}\n\n// ==========================\n// SECURE THYMELEAF CONFIGURATION\n// ==========================\n@Configuration\npublic class ThymeleafConfig {\n    \n    @Bean\n    public SpringTemplateEngine thymeleafTemplateEngine() {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(thymeleafTemplateResolver());\n        return templateEngine;\n    }\n    \n    @Bean\n    public SpringResourceTemplateResolver thymeleafTemplateResolver() {\n        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();\n        templateResolver.setPrefix(\"classpath:/templates/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        templateResolver.setCharacterEncoding(\"UTF-8\");\n        templateResolver.setCacheable(true);\n        templateResolver.setOrder(1);\n        return templateResolver;\n    }\n}"
      }
    ]
  },
  {
    "pluginId": 90036,
    "title": "Server Side Template Injection (Blind)",
    "defaultRisk": "High",
    "cweid": "94",
    "description": "Blind Server Side Template Injection vulnerabilities occur when template injection exists but doesn't produce immediate visible output, requiring attackers to use out-of-band techniques or time delays to detect and exploit the vulnerability.",
    "simplified_description": "Your application has a hidden security vulnerability that allows attackers to inject malicious template code that runs silently on your server. This is like having a secret backdoor that attackers can use to execute commands or access information without anyone noticing - they can exfiltrate data slowly over time or wait for the right moment to attack.",
    "solution": "Implement comprehensive input validation, use secure template configurations, monitor for suspicious template behavior, implement rate limiting and anomaly detection, and regularly audit template usage.",
    "simplified_solution": "Validate all input before using it in templates, monitor template processing for unusual patterns or excessive processing time, implement security controls that detect out-of-band attacks, keep template engines updated with security patches, and use secure template development practices.",
    "references": [
      {
        "name": "Blind SSTI Detection",
        "url": "https://portswigger.net/research/server-side-template-injection"
      },
      {
        "name": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
        "url": "https://cwe.mitre.org/data/definitions/94.html"
      }
    ],
    "code_solution_samples": [
      {
        "type": "Blind SSTI Prevention",
        "solution_description": "Comprehensive blind SSTI prevention including monitoring, detection, and prevention of out-of-band template injection attacks.",
        "affected_files": "Template processing systems, monitoring tools, logging systems, security filters",
        "code": "// ==========================\n// BLIND SSTI DETECTION SERVICE\n// ==========================\n@Service\npublic class BlindSSTIDetectionService {\n    private static final Logger logger = LoggerFactory.getLogger(BlindSSTIDetectionService.class);\n    \n    private final Map<String, AtomicInteger> templateRequestCounts = new ConcurrentHashMap<>();\n    private final Map<String, Long> lastRequestTimes = new ConcurrentHashMap<>();\n    \n    @EventListener\n    public void handleTemplateProcessing(TemplateProcessingEvent event) {\n        String templateName = event.getTemplateName();\n        Map<String, Object> variables = event.getVariables();\n        long processingTime = event.getProcessingTime();\n        String clientIp = event.getClientIp();\n        \n        // Monitor for suspicious patterns\n        detectAnomalousPatterns(templateName, variables, processingTime, clientIp);\n        \n        // Check for time-based attacks\n        detectTimeBasedAttacks(templateName, processingTime, clientIp);\n        \n        // Update metrics\n        updateMetrics(templateName, clientIp);\n    }\n    \n    private void detectAnomalousPatterns(String templateName, Map<String, Object> variables, \n                                       long processingTime, String clientIp) {\n        // Check for unusual variable patterns\n        for (Map.Entry<String, Object> entry : variables.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            \n            if (isSuspiciousVariable(key, value)) {\n                logger.warn(\"Suspicious template variable detected - Template: {}, Variable: {}, Value: {}, IP: {}\", \n                           templateName, key, value, clientIp);\n                \n                // Trigger security response\n                handleSuspiciousActivity(clientIp, templateName, key, value);\n            }\n        }\n        \n        // Check for unusually long processing time\n        if (processingTime > 5000) { // 5 seconds\n            logger.warn(\"Long template processing time detected - Template: {}, Time: {}ms, IP: {}\", \n                       templateName, processingTime, clientIp);\n        }\n    }\n    \n    private boolean isSuspiciousVariable(String key, Object value) {\n        // Check for known SSTI payloads\n        if (value instanceof String) {\n            String stringValue = ((String) value).toLowerCase();\n            \n            String[] suspiciousPayloads = {\n                \"${\", \"#{\", \"[[\", \"%{\", \"*{\",\n                \"t(\", \"class\", \"runtime\", \"process\", \"system\",\n                \"cmd\", \"exec\", \"getclass\", \"getclassloader\",\n                \"forname\", \"constructor\", \"prototype\",\n                \"__\", \"_env\", \"_globals\", \"_import\",\n                \"ping\", \"nslookup\", \"curl\", \"wget\", \"nc\"\n            };\n            \n            for (String payload : suspiciousPayloads) {\n                if (stringValue.contains(payload)) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check for suspicious key names\n        String[] suspiciousKeys = {\n            \"template\", \"payload\", \"cmd\", \"exec\", \"code\",\n            \"input\", \"data\", \"query\", \"expression\"\n        };\n        \n        String lowerKey = key.toLowerCase();\n        for (String suspiciousKey : suspiciousKeys) {\n            if (lowerKey.contains(suspiciousKey)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void detectTimeBasedAttacks(String templateName, long processingTime, String clientIp) {\n        // Track processing times for this template\n        String key = templateName + \":\" + clientIp;\n        \n        // Check for patterns indicating time-based attacks\n        if (processingTime > 10000) { // 10 seconds\n            logger.warn(\"Potential time-based SSTI attack - Template: {}, Time: {}ms, IP: {}\", \n                       templateName, processingTime, clientIp);\n            \n            // Implement rate limiting\n            blockClientTemporarily(clientIp);\n        }\n        \n        // Check for incremental timing patterns\n        List<Long> recentTimes = getRecentProcessingTimes(key);\n        if (recentTimes.size() >= 5) {\n            double average = recentTimes.stream().mapToLong(Long::longValue).average().orElse(0);\n            double variance = recentTimes.stream()\n                .mapToLong(Long::longValue)\n                .map(time -> Math.pow(time - average, 2))\n                .average()\n                .orElse(0);\n            \n            // High variance might indicate timing attacks\n            if (variance > 1000000) { // Large variance\n                logger.warn(\"Suspicious timing pattern detected - Template: {}, IP: {}\", templateName, clientIp);\n            }\n        }\n    }\n    \n    private List<Long> getRecentProcessingTimes(String key) {\n        // Implement logic to track recent processing times\n        // This could use Redis or in-memory storage with expiration\n        return Collections.emptyList(); // Placeholder\n    }\n    \n    private void updateMetrics(String templateName, String clientIp) {\n        // Update request counts\n        templateRequestCounts.computeIfAbsent(templateName, k -> new AtomicInteger()).incrementAndGet();\n        lastRequestTimes.put(clientIp + \":\" + templateName, System.currentTimeMillis());\n    }\n    \n    private void handleSuspiciousActivity(String clientIp, String templateName, String variableKey, Object value) {\n        // Log security event\n        logger.error(\"SSTI attack blocked - IP: {}, Template: {}, Variable: {}, Value: {}\", \n                    clientIp, templateName, variableKey, value);\n        \n        // Block client temporarily\n        blockClientTemporarily(clientIp);\n        \n        // Notify security team\n        notifySecurityTeam(clientIp, templateName, variableKey, value);\n    }\n    \n    private void blockClientTemporarily(String clientIp) {\n        // Implement temporary IP blocking\n        // This could integrate with firewall or application-level blocking\n        logger.warn(\"Blocking client IP temporarily: {}\", clientIp);\n    }\n    \n    private void notifySecurityTeam(String clientIp, String templateName, String variableKey, Object value) {\n        // Implement security team notification\n        logger.error(\"SECURITY ALERT: SSTI attack from {} on template {} with variable {}: {}\", \n                    clientIp, templateName, variableKey, value);\n    }\n}\n\n// ==========================\n// SECURE TEMPLATE PROCESSOR WITH MONITORING\n// ==========================\n@Service\npublic class MonitoredTemplateService {\n    private static final Logger logger = LoggerFactory.getLogger(MonitoredTemplateService.class);\n    \n    private final SpringTemplateEngine templateEngine;\n    private final ApplicationEventPublisher eventPublisher;\n    private final InputValidator inputValidator;\n    \n    public String processTemplate(String templateName, Map<String, Object> variables, String clientIp) {\n        long startTime = System.currentTimeMillis();\n        \n        try {\n            // Validate inputs\n            if (!isValidTemplateName(templateName)) {\n                throw new SecurityException(\"Invalid template name: \" + templateName);\n            }\n            \n            Map<String, Object> sanitizedVariables = sanitizeVariables(variables);\n            \n            // Create context\n            Context context = new Context();\n            context.setVariables(sanitizedVariables);\n            \n            // Process template\n            String result = templateEngine.process(templateName, context);\n            \n            long processingTime = System.currentTimeMillis() - startTime;\n            \n            // Publish event for monitoring\n            eventPublisher.publishEvent(new TemplateProcessingEvent(\n                templateName, sanitizedVariables, processingTime, clientIp\n            ));\n            \n            return result;\n            \n        } catch (Exception e) {\n            long processingTime = System.currentTimeMillis() - startTime;\n            \n            logger.error(\"Template processing failed - Template: {}, Time: {}ms, IP: {}\", \n                       templateName, processingTime, clientIp, e);\n            \n            // Publish failure event\n            eventPublisher.publishEvent(new TemplateProcessingEvent(\n                templateName, variables, processingTime, clientIp, e\n            ));\n            \n            throw new RuntimeException(\"Template processing failed\", e);\n        }\n    }\n    \n    private boolean isValidTemplateName(String templateName) {\n        if (templateName == null || templateName.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous patterns\n        String[] dangerousPatterns = {\n            \"..\", \"/\", \"\\\\\", \"<\", \">\", \"\\\"\", \"'\", \"&\", \"|\",\n            \"${\", \"#{\", \"[[\", \"%{\", \"*{\"\n        };\n        \n        String lowerTemplateName = templateName.toLowerCase();\n        for (String pattern : dangerousPatterns) {\n            if (lowerTemplateName.contains(pattern)) {\n                return false;\n            }\n        }\n        \n        return templateName.matches(\"^[a-zA-Z0-9_-]+$\");\n    }\n    \n    private Map<String, Object> sanitizeVariables(Map<String, Object> variables) {\n        Map<String, Object> sanitized = new HashMap<>();\n        \n        for (Map.Entry<String, Object> entry : variables.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            \n            if (isValidVariableKey(key)) {\n                Object sanitizedValue = inputValidator.sanitize(value);\n                sanitized.put(key, sanitizedValue);\n            }\n        }\n        \n        return sanitized;\n    }\n    \n    private boolean isValidVariableKey(String key) {\n        return key != null && key.matches(\"^[a-zA-Z_][a-zA-Z0-9_]*$\");\n    }\n}\n\n// ==========================\n// TEMPLATE PROCESSING EVENT\n// ==========================\npublic class TemplateProcessingEvent extends ApplicationEvent {\n    private final String templateName;\n    private final Map<String, Object> variables;\n    private final long processingTime;\n    private final String clientIp;\n    private final Exception error;\n    \n    public TemplateProcessingEvent(String templateName, Map<String, Object> variables, \n                                 long processingTime, String clientIp) {\n        this(templateName, variables, processingTime, clientIp, null);\n    }\n    \n    public TemplateProcessingEvent(String templateName, Map<String, Object> variables, \n                                 long processingTime, String clientIp, Exception error) {\n        super(templateName);\n        this.templateName = templateName;\n        this.variables = variables;\n        this.processingTime = processingTime;\n        this.clientIp = clientIp;\n        this.error = error;\n    }\n    \n    // Getters\n    public String getTemplateName() { return templateName; }\n    public Map<String, Object> getVariables() { return variables; }\n    public long getProcessingTime() { return processingTime; }\n    public String getClientIp() { return clientIp; }\n    public Exception getError() { return error; }\n}\n\n// ==========================\n// ADVANCED INPUT VALIDATOR FOR TEMPLATES\n// ==========================\n@Component\npublic class TemplateInputValidator {\n    private static final Logger logger = LoggerFactory.getLogger(TemplateInputValidator.class);\n    \n    public Object sanitize(Object value) {\n        if (value == null) {\n            return null;\n        }\n        \n        if (value instanceof String) {\n            return sanitizeString((String) value);\n        } else if (value instanceof Map) {\n            return sanitizeMap((Map<String, Object>) value);\n        } else if (value instanceof Collection) {\n            return sanitizeCollection((Collection<?>) value);\n        } else {\n            return validateObject(value);\n        }\n    }\n    \n    private String sanitizeString(String value) {\n        if (value == null) {\n            return null;\n        }\n        \n        // Remove template injection patterns\n        String sanitized = value;\n        \n        // Remove template expression patterns\n        sanitized = sanitized.replaceAll(\"\\$\\{[^}]*\\}\", \"\");\n        sanitized = sanitized.replaceAll(\"#\\{[^}]*\\}\", \"\");\n        sanitized = sanitized.replaceAll(\"\\[\\[[^\\]]*\\]\\]\", \"\");\n        sanitized = sanitized.replaceAll(\"%\\{[^}]*\\}\", \"\");\n        sanitized = sanitized.replaceAll(\"\\*\\{[^}]*\\}\", \"\");\n        \n        // Remove dangerous method calls\n        sanitized = sanitized.replaceAll(\"T\\([^)]*\\)\", \"\");\n        sanitized = sanitized.replaceAll(\"class\\\\.forName\\\\([^)]*\\\\)\", \"\");\n        sanitized = sanitized.replaceAll(\"getClass\\\\([^)]*\\\\)\", \"\");\n        \n        // Log if anything was removed\n        if (!sanitized.equals(value)) {\n            logger.warn(\"Template injection attempt blocked: {}\", value);\n        }\n        \n        return sanitized;\n    }\n    \n    private Map<String, Object> sanitizeMap(Map<String, Object> map) {\n        Map<String, Object> sanitized = new HashMap<>();\n        \n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            \n            if (isValidKey(key)) {\n                sanitized.put(key, sanitize(value));\n            }\n        }\n        \n        return sanitized;\n    }\n    \n    private Collection<Object> sanitizeCollection(Collection<?> collection) {\n        return collection.stream()\n            .map(this::sanitize)\n            .collect(Collectors.toList());\n    }\n    \n    private Object validateObject(Object value) {\n        // Only allow safe object types\n        if (value instanceof Number || value instanceof Boolean || value instanceof Character) {\n            return value;\n        }\n        \n        if (value.getClass().isAnnotationPresent(Component.class)) {\n            return value;\n        }\n        \n        // Block other object types\n        logger.warn(\"Unsafe object type blocked in template: {}\", value.getClass().getName());\n        return null;\n    }\n    \n    private boolean isValidKey(String key) {\n        if (key == null || key.trim().isEmpty()) {\n            return false;\n        }\n        \n        // Check for dangerous key names\n        String[] dangerousKeys = {\n            \"class\", \"runtime\", \"process\", \"system\", \"exec\",\n            \"cmd\", \"shell\", \"eval\", \"constructor\", \"prototype\"\n        };\n        \n        String lowerKey = key.toLowerCase();\n        for (String dangerousKey : dangerousKeys) {\n            if (lowerKey.contains(dangerousKey)) {\n                return false;\n            }\n        }\n        \n        return key.matches(\"^[a-zA-Z_][a-zA-Z0-9_]*$\");\n    }\n}\n\n// ==========================\n// RATE LIMITING FOR TEMPLATE PROCESSING\n// ==========================\n@Component\npublic class TemplateRateLimiter {\n    private final Map<String, Map<String, AtomicInteger>> rateCounters = new ConcurrentHashMap<>();\n    \n    public boolean allowRequest(String templateName, String clientIp, int maxRequestsPerMinute) {\n        String key = templateName + \":\" + clientIp;\n        String currentMinute = getCurrentMinute();\n        \n        Map<String, AtomicInteger> templateCounters = rateCounters\n            .computeIfAbsent(key, k -> new ConcurrentHashMap<>());\n        \n        AtomicInteger counter = templateCounters.computeIfAbsent(currentMinute, k -> new AtomicInteger(0));\n        \n        int currentCount = counter.incrementAndGet();\n        \n        // Clean old counters\n        cleanOldCounters(templateCounters, currentMinute);\n        \n        return currentCount <= maxRequestsPerMinute;\n    }\n    \n    private String getCurrentMinute() {\n        return String.valueOf(System.currentTimeMillis() / 60000);\n    }\n    \n    private void cleanOldCounters(Map<String, AtomicInteger> counters, String currentMinute) {\n        long currentMinuteLong = Long.parseLong(currentMinute);\n        \n        counters.entrySet().removeIf(entry -> {\n            long entryMinute = Long.parseLong(entry.getKey());\n            return currentMinuteLong - entryMinute > 5; // Keep last 5 minutes\n        });\n    }\n}"
      }
    ]
  }
]